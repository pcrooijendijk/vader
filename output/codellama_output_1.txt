Patch:
diff --git a/client/src/server.js b/client/src/server.js
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/client/src/server.js
@@ -0,0 +1,50 @@
+'use strict';
+const express      = require('express');
+const http         = require('http');
+const io           = require('socket.io');
+const cors         = require('cors');
+const csurf        = require('csurf');
+const cookieParser = require('cookie-parser');
+
+const FETCH_INTERVAL = 5000;
+const PORT           = process.env.PORT || 4000;
+
+const tickers = [
+  'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'FB', 'TSLA'
+];
+
+const app = express();
+app.use(cors());
+app.use(cookieParser());
+app.use(express.urlencoded({ extended: true }));
+app.use(csurf({ cookie: true }));
+
+const server = http.createServer(app);
+const socketServer = io(server, {
+  cors: { origin: "*" }
+});
+
+// Middleware para obtener y enviar el token CSRF
+app.get('/csrf-token', (req, res) => {
+  res.json({ csrfToken: req.csrfToken() });
+});
+
+// Endpoint protegido contra CSRF
+app.post('/secure-action', (req, res) => {
+  res.json({ message: "Acci贸n realizada con protecci贸n CSRF." });
+});
+
+app.get('/', (req, res) => {
+  res.sendFile(__dirname + '/index.html');
+});
+
+socketServer.on('connection', (socket) => {
+  socket.on('start', () => {
+    trackTickers(socket);
+  });
+});
+
+server.listen(PORT, () => {
+  console.log(`Streaming service is running on http://localhost:${PORT}`);
+});


Metadata:
CWE: CWE-23 
Severity: High
Language: javascript

### Explanation:

In the "start" event handler, the socket is tracked with the "trackTickers" method.

In the "trackTickers" method, the fetching of the tickers is made with a setInterval function.

The "trackTickers" method is called on the "start" event handler, but it's not cleared, so the interval is never cleared and the code continues to fetch the tickers.

As a result, the tickers are fetched and pushed to the clients, but the clients do not receive the "update" event from the server.

### Recommendation:

The "trackTickers" method should be cleared when the "start" event is received.

### Proof of Concept:

```javascript
const express      = require('express');
const http         = require('http');
const io           = require('socket.io');
const cors         = require('cors');
const csurf        = require('csurf');
const cookieParser = require('cookie-parser');

const FETCH_INTERVAL = 5000;
const PORT           = process.env.PORT || 4000;

const tickers = [
  'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'FB', 'TSLA'
];

const app = express();
app.use(cors());
app.use(cookieParser());
app.use(express.urlencoded({ extended: true }));
app.use(csurf({ cookie: true }));

const server = http.createServer(app);
const socketServer = io(server, {
  cors: { origin: "*" }
});

// Middleware para obtener y enviar el token CSRF
app.get('/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Endpoint protegido contra CSRF
app.post('/secure-action', (req, res) => {
  res.json({ message: "Acci贸n realizada con protecci贸n CSRF." });
});

app.get('/', (req, res) => {
  res.sendFile(__dirname + '/index.html');
});

socketServer.on('connection', (socket) => {
  socket.on('start', () => {
    trackTickers(socket);
  });
});

server.listen(PORT, () => {
  console.log(`Streaming service is running on http://localhost:${PORT}`);
});

function trackTickers(socket) {
  let interval = setInterval(() => {
    fetchTickers(socket);
  }, FETCH_INTERVAL);

  socket.on('disconnect', () => {
    clearInterval(interval);
  });
}

function fetchTickers(socket) {
  let response = tickers.map((ticker) => {
    return { ticker: ticker };
  });
  socket.emit('update', { data: response });
}
```

### References:

* [https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_